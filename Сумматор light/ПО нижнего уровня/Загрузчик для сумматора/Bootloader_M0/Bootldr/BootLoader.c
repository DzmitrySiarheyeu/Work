#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

#include "config.h"

#include "loader.h"
#include "LPC11xx.h"
#include "sbl_config.h"
#include "sbl_iap.h"
#include "CRC.h"
#include "bus.h"
#include "DES.h"
#include "wdt.h"

//=============================================================================
// Frame types 




#define TYPE_EOF 0
#define TYPE_ERASE 1
#define TYPE_PREPARE 2
#define TYPE_DATA 3
#define TYPE_PROGRAM 4
#define TYPE_EEPROM 5
#define TYPE_LOCKBITS 6
#define TYPE_RESET 7

void pre_boot(int flag);
int check_ext_boot_req(void);

#define boot_program_page_core(addr, Buf, size) (write_flash((unsigned int *)addr, (char *)Buf, size))

__asm void boot(void)
{
	 LDR R0, =(0x30)
	 BX  R0
}


#define SYSOSCCTRL_Val        0x00000000
#define WDTOSCCTRL_Val        0x000000A0
#define SYSPLLCLKSEL_Val      0x00000001
#define SYSPLLCTRL_Val        0x00000023
#define MAINCLKSEL_Val        0x00000003
#define SYSAHBCLKDIV_Val      0x00000001
#define AHBCLKCTRL_Val        0x000100DF
#define SSP0CLKDIV_Val        0x00000001
#define UARTCLKDIV_Val        0x00000001
#define SSP1CLKDIV_Val        0x00000001

void ConfigurePLL(void)
{
	int i = 0;

	LPC_SYSCON->PDRUNCFG     &= ~(1 << 5);          /* Power-up System Osc      */
 	LPC_SYSCON->SYSOSCCTRL    = SYSOSCCTRL_Val;
  	for (i = 0; i < 200; i++) __NOP();
  	LPC_SYSCON->SYSPLLCLKSEL  = SYSPLLCLKSEL_Val;   /* Select PLL Input         */
  	LPC_SYSCON->SYSPLLCLKUEN  = 0x01;               /* Update Clock Source      */
  	LPC_SYSCON->SYSPLLCLKUEN  = 0x00;               /* Toggle Update Register   */
  	LPC_SYSCON->SYSPLLCLKUEN  = 0x01;
  	while (!(LPC_SYSCON->SYSPLLCLKUEN & 0x01));     /* Wait Until Updated       */
	                               /* System PLL Setup         */
  	LPC_SYSCON->SYSPLLCTRL    = SYSPLLCTRL_Val;
  	LPC_SYSCON->PDRUNCFG     &= ~(1 << 7);          /* Power-up SYSPLL          */
  	while (!(LPC_SYSCON->SYSPLLSTAT & 0x01));	      /* Wait Until PLL Locked    */
	
	
	                                /* Watchdog Oscillator Setup*/
  	LPC_SYSCON->WDTOSCCTRL    = WDTOSCCTRL_Val;
  	LPC_SYSCON->PDRUNCFG     &= ~(1 << 6);          /* Power-up WDT Clock       */
	
  	LPC_SYSCON->MAINCLKSEL    = MAINCLKSEL_Val;     /* Select PLL Clock Output  */
  	LPC_SYSCON->MAINCLKUEN    = 0x01;               /* Update MCLK Clock Source */
  	LPC_SYSCON->MAINCLKUEN    = 0x00;               /* Toggle Update Register   */
  	LPC_SYSCON->MAINCLKUEN    = 0x01;
  	while (!(LPC_SYSCON->MAINCLKUEN & 0x01));       /* Wait Until Updated       */
	

  	LPC_SYSCON->SYSAHBCLKDIV  = SYSAHBCLKDIV_Val;
  	LPC_SYSCON->SYSAHBCLKCTRL = AHBCLKCTRL_Val;
  	LPC_SYSCON->SSP0CLKDIV    = SSP0CLKDIV_Val;
  	LPC_SYSCON->UARTCLKDIV    = UARTCLKDIV_Val;
  	LPC_SYSCON->SSP1CLKDIV    = SSP1CLKDIV_Val;

}

int main(void)
{
	ConfigurePLL();

#ifdef BEBUG_OFF
	WDTInit(WDTO_1S);
#endif

	if( check_ext_boot_req() == 0)
		// Переход на загрузчик по ноге процессора
		pre_boot(0);

	// Loop forever (loops only if Application Section is damaged)
	for (;;)
	{
		unsigned short crc = 0;
		unsigned char *p = (unsigned char *)USER_FLASH_START;
		unsigned int   n = MEM_SIZE;
	
		do
		{
			crc = CRC(*p++, crc);
		}
		while (--n);
	
		// Application Section damaged
		//   -> do not jump to Reset Vector of the Application Section
		if (crc) 
			pre_boot(0);

		execute_user_code();
	}	   
}

char rxBuffer[BUFFER_SIZE] __attribute__ ((aligned (32)));	// Receive buffer
char buf[100];
unsigned char *r;
//unsigned char pageBuffer[PAGE_SIZE];	// Page is assembled here before

//=============================================================================
// Loader routine. For more information about the format of frames, please
// refer to the Application Note Documentation.

uint32_t sizr[100];
void loader(void)
{
	unsigned short frameSize;
		
	busInit();

	// Prepare bus for incoming frames...
	if( busPrepare() == 0)
		// Пришел запрос на стирание чипа
		full_chip_erase();

	//=============================================================================
	// Initial vector for cipher block unchaining (INITIALVECTOR_HI and LO are
	// defined in 'bootldr.h' which is generated by 'create' tool)

												// getting programmed to flash mem
	#if KEY_COUNT > 0
		unsigned long chainCipherBlock[2];		// Buffer for Cipher Block
												// Unchaining
		chainCipherBlock[0] = INITIALVECTOR_HI;
		chainCipherBlock[1] = INITIALVECTOR_LO;
	#endif

	int ll = 0;

	// Loop forever (the loop is broken by Watchdog when RESET record is
	// received)
	for (;;)
	{
		
		unsigned short crc;

		WDTFeed();

		// Get the frame size
		frameSize = ((unsigned char)busReceiveByte() << 8);
		frameSize |=(unsigned char)busReceiveByte();

		sizr[ll++] = frameSize;
														
		// Receive a frame of data from communication interface and calculate
		// its CRC
		char *p = NULL;
		unsigned short n = frameSize;

		if(frameSize > 100) p = rxBuffer;
		else p = buf;

		crc = 0;
		do
		{
			unsigned char ch;

			ch = busReceiveByte();

			*p++ = ch;
			crc = CRC(ch, crc);
				
			WDTFeed();
		}
		while (--n);
			
			busBusy();
		// CRC is OK?
		if (crc == 0x0000)
		{
			if(frameSize > 100) p = rxBuffer;
			else p = buf;		

			// Decrypt 8 bytes, CRC-bytes are ignored.
			#if KEY_COUNT > 0
			{
				 char *pp = 0;
				 if(frameSize > 100) pp = rxBuffer;
				 else pp = buf;

				frameSize -= 2;
				do
				{
			    	WDTFeed();
					desDecrypt(pp, (uint8_t *)chainCipherBlock);
					pp += 8;
				}
				while (frameSize -= 8);
			}
			#endif // KEY_COUNT > 0
			// Check that the signature is correct
			uint32_t *tt = (uint32_t *)p;
			if(*tt++ == SIGNATURE)
			{
				uint32_t address = 0;
				uint16_t size = 0;
				unsigned char type;
				p = (unsigned char *)tt;
				// Continue parsing the frames until the 'End Of Frame' is
				// received
				while ((type = *p++) != TYPE_EOF)
				{
			    	WDTFeed();

					address  = (*(unsigned char *)p++ << 16); 
					address |= (*(unsigned char *)p++ << 8);
					address |= (*(unsigned char *)p++ << 0);

				    size  = (*(unsigned char *)p++ << 8);
					size |= (*(unsigned char *)p++ << 0);

					switch (type)
					{
						// Erase page
						case TYPE_ERASE:
						// Fall-through!

						// Prepare for incoming data chunks by copying the page
						// contents into the page buffer
						case TYPE_PREPARE:
						{
							//unsigned char *q = pageBuffer;

//							do
//							{
////								//*q++ = 0xff;
//								p++;
//							}
//							while (--size);
							//p += size;
							size = 0;
							p -= 5;
							break;
						}								 

						// Chunk of data is written into the page buffer
						case TYPE_DATA:
						{
							r = p;
							p -= 5;
							size = 0;
							//	&pageBuffer[address];

//							do
//							{
//								p++;
//							}
//							while (--size);
							break;
						}

						// Program page buffer into flash page
						case TYPE_PROGRAM:
						{
							if((unsigned int)address < USER_FLASH_START){
								break;	
							}						
												   
							if((unsigned int)address < (MEM_SIZE + SHIFT_SIZE)){
								boot_program_page_core((unsigned int)(address), r, size * 2);
								break;
							}
							p -= 5;
						}

						// Write a chunk of data into EEPROM
						case TYPE_EEPROM:
							break;

						// Reset (let the Watchdog Timer expire)!
						case TYPE_RESET:
							busReplyByte(ERROR_OK);
							for(;;);
							
						// Nonsense frames, one byte long
						default:
							p -= 5;
							break;
					}
				}

				busReplyByte(ERROR_OK);
			}
			else
				busReplyByte(ERROR_CRC);
		}
    	else
    		busReplyByte(ERROR_CRC);   		
  	}
}

int check_ext_boot_req(void)
{
	LPC_IOCON->PIO3_0 = (2 << 3);

	if((LPC_GPIO3->DATA & 0x01) == 0)
		return 0;
	
	return 1;
}





