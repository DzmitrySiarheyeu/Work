
summator.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000020  00800100  00003924  00003a18  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003924  00000000  00000000  000000f4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .also_var     000003c0  00003b00  00003b00  00003aae  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bootloader   00000076  00003960  00003960  00003a38  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .bss          00000338  00800120  00800120  00003e6e  2**0
                  ALLOC
  5 .eeprom       000001eb  00810000  00810000  00003e6e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .debug_aranges 00000288  00000000  00000000  00004059  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 00000cd2  00000000  00000000  000042e1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   000055ce  00000000  00000000  00004fb3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00001c17  00000000  00000000  0000a581  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   0000337b  00000000  00000000  0000c198  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00000850  00000000  00000000  0000f514  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00000fb6  00000000  00000000  0000fd64  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    0000119a  00000000  00000000  00010d1a  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000068  00000000  00000000  00011eb4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 01 	jmp	0x268	; 0x268 <__ctors_end>
       4:	0c 94 51 01 	jmp	0x2a2	; 0x2a2 <__bad_interrupt>
       8:	0c 94 51 01 	jmp	0x2a2	; 0x2a2 <__bad_interrupt>
       c:	0c 94 51 01 	jmp	0x2a2	; 0x2a2 <__bad_interrupt>
      10:	0c 94 51 01 	jmp	0x2a2	; 0x2a2 <__bad_interrupt>
      14:	0c 94 51 01 	jmp	0x2a2	; 0x2a2 <__bad_interrupt>
      18:	0c 94 51 01 	jmp	0x2a2	; 0x2a2 <__bad_interrupt>
      1c:	0c 94 30 19 	jmp	0x3260	; 0x3260 <__vector_7>
      20:	0c 94 51 01 	jmp	0x2a2	; 0x2a2 <__bad_interrupt>
      24:	0c 94 51 01 	jmp	0x2a2	; 0x2a2 <__bad_interrupt>
      28:	0c 94 ff 05 	jmp	0xbfe	; 0xbfe <__vector_10>
      2c:	0c 94 51 01 	jmp	0x2a2	; 0x2a2 <__bad_interrupt>
      30:	0c 94 51 01 	jmp	0x2a2	; 0x2a2 <__bad_interrupt>
      34:	0c 94 e9 07 	jmp	0xfd2	; 0xfd2 <__vector_13>
      38:	0c 94 51 01 	jmp	0x2a2	; 0x2a2 <__bad_interrupt>
      3c:	0c 94 51 01 	jmp	0x2a2	; 0x2a2 <__bad_interrupt>
      40:	0c 94 c4 0b 	jmp	0x1788	; 0x1788 <__vector_16>
      44:	0c 94 51 01 	jmp	0x2a2	; 0x2a2 <__bad_interrupt>
      48:	0c 94 31 0c 	jmp	0x1862	; 0x1862 <__vector_18>
      4c:	0c 94 8b 0c 	jmp	0x1916	; 0x1916 <__vector_19>
      50:	0c 94 6d 0c 	jmp	0x18da	; 0x18da <__vector_20>
      54:	0c 94 51 01 	jmp	0x2a2	; 0x2a2 <__bad_interrupt>
      58:	0c 94 51 01 	jmp	0x2a2	; 0x2a2 <__bad_interrupt>
      5c:	0c 94 51 01 	jmp	0x2a2	; 0x2a2 <__bad_interrupt>
      60:	0c 94 51 01 	jmp	0x2a2	; 0x2a2 <__bad_interrupt>
      64:	0c 94 51 01 	jmp	0x2a2	; 0x2a2 <__bad_interrupt>

00000068 <auchCRCHi>:
      68:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
      78:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
      88:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
      98:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
      a8:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
      b8:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
      c8:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
      d8:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
      e8:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
      f8:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     108:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     118:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     128:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     138:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     148:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     158:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@

00000168 <auchCRCLo>:
     168:	00 c0 c1 01 c3 03 02 c2 c6 06 07 c7 05 c5 c4 04     ................
     178:	cc 0c 0d cd 0f cf ce 0e 0a ca cb 0b c9 09 08 c8     ................
     188:	d8 18 19 d9 1b db da 1a 1e de df 1f dd 1d 1c dc     ................
     198:	14 d4 d5 15 d7 17 16 d6 d2 12 13 d3 11 d1 d0 10     ................
     1a8:	f0 30 31 f1 33 f3 f2 32 36 f6 f7 37 f5 35 34 f4     .01.3..26..7.54.
     1b8:	3c fc fd 3d ff 3f 3e fe fa 3a 3b fb 39 f9 f8 38     <..=.?>..:;.9..8
     1c8:	28 e8 e9 29 eb 2b 2a ea ee 2e 2f ef 2d ed ec 2c     (..).+*.../.-..,
     1d8:	e4 24 25 e5 27 e7 e6 26 22 e2 e3 23 e1 21 20 e0     .$%.'..&"..#.! .
     1e8:	a0 60 61 a1 63 a3 a2 62 66 a6 a7 67 a5 65 64 a4     .`a.c..bf..g.ed.
     1f8:	6c ac ad 6d af 6f 6e ae aa 6a 6b ab 69 a9 a8 68     l..m.on..jk.i..h
     208:	78 b8 b9 79 bb 7b 7a ba be 7e 7f bf 7d bd bc 7c     x..y.{z..~..}..|
     218:	b4 74 75 b5 77 b7 b6 76 72 b2 b3 73 b1 71 70 b0     .tu.w..vr..s.qp.
     228:	50 90 91 51 93 53 52 92 96 56 57 97 55 95 94 54     P..Q.SR..VW.U..T
     238:	9c 5c 5d 9d 5f 9f 9e 5e 5a 9a 9b 5b 99 59 58 98     .\]._..^Z..[.YX.
     248:	88 48 49 89 4b 8b 8a 4a 4e 8e 8f 4f 8d 4d 4c 8c     .HI.K..JN..O.ML.
     258:	44 84 85 45 87 47 46 86 82 42 43 83 41 81 80 40     D..E.GF..BC.A..@

00000268 <__ctors_end>:
     268:	11 24       	eor	r1, r1
     26a:	1f be       	out	0x3f, r1	; 63
     26c:	cf ef       	ldi	r28, 0xFF	; 255
     26e:	d4 e0       	ldi	r29, 0x04	; 4
     270:	de bf       	out	0x3e, r29	; 62
     272:	cd bf       	out	0x3d, r28	; 61

00000274 <__do_copy_data>:
     274:	11 e0       	ldi	r17, 0x01	; 1
     276:	a0 e0       	ldi	r26, 0x00	; 0
     278:	b1 e0       	ldi	r27, 0x01	; 1
     27a:	e4 e2       	ldi	r30, 0x24	; 36
     27c:	f9 e3       	ldi	r31, 0x39	; 57
     27e:	02 c0       	rjmp	.+4      	; 0x284 <.do_copy_data_start>

00000280 <.do_copy_data_loop>:
     280:	05 90       	lpm	r0, Z+
     282:	0d 92       	st	X+, r0

00000284 <.do_copy_data_start>:
     284:	a0 32       	cpi	r26, 0x20	; 32
     286:	b1 07       	cpc	r27, r17
     288:	d9 f7       	brne	.-10     	; 0x280 <.do_copy_data_loop>

0000028a <__do_clear_bss>:
     28a:	14 e0       	ldi	r17, 0x04	; 4
     28c:	a0 e2       	ldi	r26, 0x20	; 32
     28e:	b1 e0       	ldi	r27, 0x01	; 1
     290:	01 c0       	rjmp	.+2      	; 0x294 <.do_clear_bss_start>

00000292 <.do_clear_bss_loop>:
     292:	1d 92       	st	X+, r1

00000294 <.do_clear_bss_start>:
     294:	a8 35       	cpi	r26, 0x58	; 88
     296:	b1 07       	cpc	r27, r17
     298:	e1 f7       	brne	.-8      	; 0x292 <.do_clear_bss_loop>
     29a:	0e 94 be 01 	call	0x37c	; 0x37c <main>
     29e:	0c 94 60 19 	jmp	0x32c0	; 0x32c0 <exit>

000002a2 <__bad_interrupt>:
     2a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000002a6 <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
     2a6:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
     2a8:	f9 99       	sbic	0x1f, 1	; 31
     2aa:	fe cf       	rjmp	.-4      	; 0x2a8 <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
     2ac:	32 bd       	out	0x22, r19	; 34
     2ae:	21 bd       	out	0x21, r18	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     2b0:	f8 9a       	sbi	0x1f, 0	; 31
     2b2:	80 b5       	in	r24, 0x20	; 32
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
     2b4:	08 95       	ret

000002b6 <ReservProcess>:
	sei(); 
}


inline void ReservProcess()
{
     2b6:	af 92       	push	r10
     2b8:	bf 92       	push	r11
     2ba:	cf 92       	push	r12
     2bc:	df 92       	push	r13
     2be:	ef 92       	push	r14
     2c0:	ff 92       	push	r15
     2c2:	0f 93       	push	r16
     2c4:	1f 93       	push	r17
    double RezervPoint = Reverse4(RegFile.mb_struct.Reserv);
     2c6:	60 91 81 02 	lds	r22, 0x0281
     2ca:	70 91 82 02 	lds	r23, 0x0282
     2ce:	80 91 83 02 	lds	r24, 0x0283
     2d2:	90 91 84 02 	lds	r25, 0x0284
     2d6:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <Reverse4>
     2da:	7b 01       	movw	r14, r22
     2dc:	8c 01       	movw	r16, r24
	
	if (VolumePercent < RezervPoint)
     2de:	a0 90 38 01 	lds	r10, 0x0138
     2e2:	b0 90 39 01 	lds	r11, 0x0139
     2e6:	c0 90 3a 01 	lds	r12, 0x013A
     2ea:	d0 90 3b 01 	lds	r13, 0x013B
     2ee:	c6 01       	movw	r24, r12
     2f0:	b5 01       	movw	r22, r10
     2f2:	a8 01       	movw	r20, r16
     2f4:	97 01       	movw	r18, r14
     2f6:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__cmpsf2>
     2fa:	88 23       	and	r24, r24
     2fc:	0c f4       	brge	.+2      	; 0x300 <ReservProcess+0x4a>
	{
		RESERV_ON;
     2fe:	5d 9a       	sbi	0x0b, 5	; 11
	}
	if (VolumePercent > RezervPoint + 0.01)	
     300:	c8 01       	movw	r24, r16
     302:	b7 01       	movw	r22, r14
     304:	2a e0       	ldi	r18, 0x0A	; 10
     306:	37 ed       	ldi	r19, 0xD7	; 215
     308:	43 e2       	ldi	r20, 0x23	; 35
     30a:	5c e3       	ldi	r21, 0x3C	; 60
     30c:	0e 94 11 1a 	call	0x3422	; 0x3422 <__addsf3>
     310:	9b 01       	movw	r18, r22
     312:	ac 01       	movw	r20, r24
     314:	c6 01       	movw	r24, r12
     316:	b5 01       	movw	r22, r10
     318:	0e 94 bf 1b 	call	0x377e	; 0x377e <__gesf2>
     31c:	18 16       	cp	r1, r24
     31e:	0c f4       	brge	.+2      	; 0x322 <ReservProcess+0x6c>
	{
		RESERV_OFF;
     320:	5d 98       	cbi	0x0b, 5	; 11
	}
	
}
     322:	1f 91       	pop	r17
     324:	0f 91       	pop	r16
     326:	ff 90       	pop	r15
     328:	ef 90       	pop	r14
     32a:	df 90       	pop	r13
     32c:	cf 90       	pop	r12
     32e:	bf 90       	pop	r11
     330:	af 90       	pop	r10
     332:	08 95       	ret

00000334 <Init>:
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
     334:	85 e7       	ldi	r24, 0x75	; 117
     336:	92 e0       	ldi	r25, 0x02	; 2
     338:	60 e0       	ldi	r22, 0x00	; 0
     33a:	70 e0       	ldi	r23, 0x00	; 0
     33c:	48 eb       	ldi	r20, 0xB8	; 184
     33e:	51 e0       	ldi	r21, 0x01	; 1
     340:	23 e5       	ldi	r18, 0x53	; 83
     342:	31 e0       	ldi	r19, 0x01	; 1
     344:	0e 94 87 19 	call	0x330e	; 0x330e <__eerd_block>
#include "omnicomm.h"

inline void Init()
{
    eeprom_read_block(&RegFile, &EepromRegFile, sizeof(REGISTER_FILE));
	RegFile.mb_struct.U_type = VERSION_PO;
     348:	82 e2       	ldi	r24, 0x22	; 34
     34a:	92 e2       	ldi	r25, 0x22	; 34
     34c:	90 93 76 02 	sts	0x0276, r25
     350:	80 93 75 02 	sts	0x0275, r24
	Read_parameters();; // Omnicomm
     354:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <Read_parameters>
//	RESET_FUSE_INIT; // Ќе хватает ножек на разъеме
    LED_INIT;
     358:	41 9a       	sbi	0x08, 1	; 8
     35a:	39 9a       	sbi	0x07, 1	; 7
    RESERV_INIT;
     35c:	5d 98       	cbi	0x0b, 5	; 11
     35e:	55 9a       	sbi	0x0a, 5	; 10
	LedTimerInit();
     360:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LedTimerInit>
    ROutInit();
     364:	0e 94 b7 05 	call	0xb6e	; 0xb6e <ROutInit>
	FOutInit();
     368:	0e 94 d5 18 	call	0x31aa	; 0x31aa <FOutInit>
#ifdef FREQUENCY_INPUT
    FreqDotInit();
     36c:	0e 94 b6 07 	call	0xf6c	; 0xf6c <FreqDotInit>
#endif
	VOutInit();
     370:	0e 94 2e 02 	call	0x45c	; 0x45c <VOutInit>
    InitUART();
     374:	0e 94 a9 0b 	call	0x1752	; 0x1752 <InitUART>
	
	sei(); 
     378:	78 94       	sei
}
     37a:	08 95       	ret

0000037c <main>:
	}
	
}

int main(void)
{
     37c:	1f 93       	push	r17
	wdt_enable(WDTO_1S);
     37e:	2e e0       	ldi	r18, 0x0E	; 14
     380:	88 e1       	ldi	r24, 0x18	; 24
     382:	90 e0       	ldi	r25, 0x00	; 0
     384:	0f b6       	in	r0, 0x3f	; 63
     386:	f8 94       	cli
     388:	a8 95       	wdr
     38a:	80 93 60 00 	sts	0x0060, r24
     38e:	0f be       	out	0x3f, r0	; 63
     390:	20 93 60 00 	sts	0x0060, r18
	unsigned char rout_error = 0; 
	unsigned char dot_error = 0;

   	Init();
     394:	0e 94 9a 01 	call	0x334	; 0x334 <Init>
	while (1)
	{
		wdt_reset();
     398:	a8 95       	wdr
	    ModbusProcess();
     39a:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <ModbusProcess>
        dot_error  = DotsProcess();
     39e:	0e 94 67 0f 	call	0x1ece	; 0x1ece <DotsProcess>
     3a2:	18 2f       	mov	r17, r24
		set_Freq(VolumePercent * 1000.0 + 500.0);
     3a4:	60 91 38 01 	lds	r22, 0x0138
     3a8:	70 91 39 01 	lds	r23, 0x0139
     3ac:	80 91 3a 01 	lds	r24, 0x013A
     3b0:	90 91 3b 01 	lds	r25, 0x013B
     3b4:	20 e0       	ldi	r18, 0x00	; 0
     3b6:	30 e0       	ldi	r19, 0x00	; 0
     3b8:	4a e7       	ldi	r20, 0x7A	; 122
     3ba:	54 e4       	ldi	r21, 0x44	; 68
     3bc:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__mulsf3>
     3c0:	20 e0       	ldi	r18, 0x00	; 0
     3c2:	30 e0       	ldi	r19, 0x00	; 0
     3c4:	4a ef       	ldi	r20, 0xFA	; 250
     3c6:	53 e4       	ldi	r21, 0x43	; 67
     3c8:	0e 94 11 1a 	call	0x3422	; 0x3422 <__addsf3>
     3cc:	0e 94 ea 18 	call	0x31d4	; 0x31d4 <set_Freq>
#ifdef	R_OUT_ENABLE
		rout_error = ROutProcess();
#endif
		VOutProcess();
     3d0:	0e 94 82 02 	call	0x504	; 0x504 <VOutProcess>
        ReservProcess();
     3d4:	0e 94 5b 01 	call	0x2b6	; 0x2b6 <ReservProcess>
		ErrorProcess(dot_error, rout_error);
     3d8:	81 2f       	mov	r24, r17
     3da:	60 e0       	ldi	r22, 0x00	; 0
     3dc:	0e 94 e5 0c 	call	0x19ca	; 0x19ca <ErrorProcess>
     3e0:	db cf       	rjmp	.-74     	; 0x398 <main+0x1c>

000003e2 <SPIMasterInit>:
#include "spi.h"

inline void SPIMasterInit(void)
{
    cbi(PRR,  PRSPI);   //On SPI
     3e2:	e4 e6       	ldi	r30, 0x64	; 100
     3e4:	f0 e0       	ldi	r31, 0x00	; 0
     3e6:	80 81       	ld	r24, Z
     3e8:	8b 7f       	andi	r24, 0xFB	; 251
     3ea:	80 83       	st	Z, r24

    sbi(SCK_DDR,    SCK_PIN);
     3ec:	25 9a       	sbi	0x04, 5	; 4
	sbi(MOSI_DDR,   MOSI_PIN);
     3ee:	23 9a       	sbi	0x04, 3	; 4
    sbi(SS_DDR,     SS_PIN);
     3f0:	22 9a       	sbi	0x04, 2	; 4
    sbi(POT_SS_DDR, POT_SS_PIN);
     3f2:	57 9a       	sbi	0x0a, 7	; 10

    UNSELECT_POT;
     3f4:	5f 9a       	sbi	0x0b, 7	; 11
    
    SET_SPI_CLOCK;
     3f6:	8d b5       	in	r24, 0x2d	; 45
     3f8:	8e 7f       	andi	r24, 0xFE	; 254
     3fa:	8d bd       	out	0x2d, r24	; 45
     3fc:	8c b5       	in	r24, 0x2c	; 44
     3fe:	8d 7f       	andi	r24, 0xFD	; 253
     400:	8c bd       	out	0x2c, r24	; 44
     402:	8c b5       	in	r24, 0x2c	; 44
     404:	8e 7f       	andi	r24, 0xFE	; 254
     406:	8c bd       	out	0x2c, r24	; 44

    sbi(SPCR, MSTR);    //Master
     408:	8c b5       	in	r24, 0x2c	; 44
     40a:	80 61       	ori	r24, 0x10	; 16
     40c:	8c bd       	out	0x2c, r24	; 44
    sbi(SPCR, SPE);     //ON
     40e:	8c b5       	in	r24, 0x2c	; 44
     410:	80 64       	ori	r24, 0x40	; 64
     412:	8c bd       	out	0x2c, r24	; 44
}
     414:	08 95       	ret

00000416 <SPIWrite>:

inline void SPIWrite(unsigned char a)
{
	SPDR = a;					
     416:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1 << SPIF)));
     418:	0d b4       	in	r0, 0x2d	; 45
     41a:	07 fe       	sbrs	r0, 7
     41c:	fd cf       	rjmp	.-6      	; 0x418 <SPIWrite+0x2>
}
     41e:	08 95       	ret

00000420 <PotSet>:
    PotSet(PotValue);

}

inline void PotSet(unsigned char b)
{
     420:	1f 93       	push	r17
     422:	18 2f       	mov	r17, r24
    SELECT_POT;
     424:	5f 98       	cbi	0x0b, 7	; 11
    SPIWrite(WRITE_DATA_0_COMMAND); // command
     426:	81 e1       	ldi	r24, 0x11	; 17
     428:	0e 94 0b 02 	call	0x416	; 0x416 <SPIWrite>
    SPIWrite(b);                    // data byte
     42c:	81 2f       	mov	r24, r17
     42e:	0e 94 0b 02 	call	0x416	; 0x416 <SPIWrite>
    UNSELECT_POT;
     432:	5f 9a       	sbi	0x0b, 7	; 11
}
     434:	1f 91       	pop	r17
     436:	08 95       	ret

00000438 <PotInit>:

double PotValue; 

inline void PotInit(void)
{
    SPIMasterInit();
     438:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <SPIMasterInit>
    
    PotValue = (POT_MAX_VALUE - POT_MIN_VALUE) / 2;
     43c:	80 e0       	ldi	r24, 0x00	; 0
     43e:	90 e0       	ldi	r25, 0x00	; 0
     440:	ac ec       	ldi	r26, 0xCC	; 204
     442:	b2 e4       	ldi	r27, 0x42	; 66
     444:	80 93 4f 01 	sts	0x014F, r24
     448:	90 93 50 01 	sts	0x0150, r25
     44c:	a0 93 51 01 	sts	0x0151, r26
     450:	b0 93 52 01 	sts	0x0152, r27
    
    PotSet(PotValue);
     454:	86 e6       	ldi	r24, 0x66	; 102
     456:	0e 94 10 02 	call	0x420	; 0x420 <PotSet>

}
     45a:	08 95       	ret

0000045c <VOutInit>:
#include "vout.h"

//----------------- V OUT TIMER1-------------
inline void VOutInit()
{
    cbi(PRR,  PRTIM1);      //On TIMER1
     45c:	e4 e6       	ldi	r30, 0x64	; 100
     45e:	f0 e0       	ldi	r31, 0x00	; 0
     460:	80 81       	ld	r24, Z
     462:	87 7f       	andi	r24, 0xF7	; 247
     464:	80 83       	st	Z, r24

    sbi(OC1B_DDR, OC1B_PIN);    // pin to out
     466:	22 9a       	sbi	0x04, 2	; 4

    TCCR1B = VOUT_TIMER_CLOCK_DIVIRDER;
     468:	a1 e8       	ldi	r26, 0x81	; 129
     46a:	b0 e0       	ldi	r27, 0x00	; 0
     46c:	81 e0       	ldi	r24, 0x01	; 1
     46e:	8c 93       	st	X, r24

    sbi(TCCR1A, COM1B1);    //  Clear OC1A/OC1B on Compare Match, set
     470:	e0 e8       	ldi	r30, 0x80	; 128
     472:	f0 e0       	ldi	r31, 0x00	; 0
     474:	80 81       	ld	r24, Z
     476:	80 62       	ori	r24, 0x20	; 32
     478:	80 83       	st	Z, r24
                            //  OC1A/OC1B at BOTTOM (non-inverting mode)

     // Fast PWM     OCR1A   BOTTOM  TOP
    sbi(TCCR1A, WGM10);
     47a:	80 81       	ld	r24, Z
     47c:	81 60       	ori	r24, 0x01	; 1
     47e:	80 83       	st	Z, r24
    sbi(TCCR1A, WGM11);
     480:	80 81       	ld	r24, Z
     482:	82 60       	ori	r24, 0x02	; 2
     484:	80 83       	st	Z, r24
    sbi(TCCR1B, WGM12);
     486:	8c 91       	ld	r24, X
     488:	88 60       	ori	r24, 0x08	; 8
     48a:	8c 93       	st	X, r24
    sbi(TCCR1B, WGM13);
     48c:	8c 91       	ld	r24, X
     48e:	80 61       	ori	r24, 0x10	; 16
     490:	8c 93       	st	X, r24

    OCR1A = VOUT_TIMER_MAX_TIMER_VALUE;
     492:	8f ef       	ldi	r24, 0xFF	; 255
     494:	9f ef       	ldi	r25, 0xFF	; 255
     496:	90 93 89 00 	sts	0x0089, r25
     49a:	80 93 88 00 	sts	0x0088, r24

    sbi(TCCR1B, WGM12);
     49e:	8c 91       	ld	r24, X
     4a0:	88 60       	ori	r24, 0x08	; 8
     4a2:	8c 93       	st	X, r24
    sbi(TCCR1B, WGM13);
     4a4:	8c 91       	ld	r24, X
     4a6:	80 61       	ori	r24, 0x10	; 16
     4a8:	8c 93       	st	X, r24
     
    // OFF PWM
    OCR1B = 0;
     4aa:	10 92 8b 00 	sts	0x008B, r1
     4ae:	10 92 8a 00 	sts	0x008A, r1

	// Interrupt enable
    sbi(TIMSK1, TOIE1);
     4b2:	ef e6       	ldi	r30, 0x6F	; 111
     4b4:	f0 e0       	ldi	r31, 0x00	; 0
     4b6:	80 81       	ld	r24, Z
     4b8:	81 60       	ori	r24, 0x01	; 1
     4ba:	80 83       	st	Z, r24
}
     4bc:	08 95       	ret

000004be <VOutWidthSet>:

unsigned short old_value = 0;
unsigned short new_value = 0;
inline void VOutWidthSet(unsigned short value)
{
     4be:	ac 01       	movw	r20, r24
    new_value = value;
     4c0:	90 93 23 01 	sts	0x0123, r25
     4c4:	80 93 22 01 	sts	0x0122, r24
	if ((value > (old_value + 100)) || (value < (old_value - 100)))
     4c8:	20 91 20 01 	lds	r18, 0x0120
     4cc:	30 91 21 01 	lds	r19, 0x0121
     4d0:	c9 01       	movw	r24, r18
     4d2:	8c 59       	subi	r24, 0x9C	; 156
     4d4:	9f 4f       	sbci	r25, 0xFF	; 255
     4d6:	84 17       	cp	r24, r20
     4d8:	95 07       	cpc	r25, r21
     4da:	28 f0       	brcs	.+10     	; 0x4e6 <VOutWidthSet+0x28>
     4dc:	24 56       	subi	r18, 0x64	; 100
     4de:	30 40       	sbci	r19, 0x00	; 0
     4e0:	42 17       	cp	r20, r18
     4e2:	53 07       	cpc	r21, r19
     4e4:	20 f4       	brcc	.+8      	; 0x4ee <VOutWidthSet+0x30>
	{
		old_value = value;
     4e6:	50 93 21 01 	sts	0x0121, r21
     4ea:	40 93 20 01 	sts	0x0120, r20
	}
	cli();
     4ee:	f8 94       	cli
	OCR1B = value;
     4f0:	50 93 8b 00 	sts	0x008B, r21
     4f4:	40 93 8a 00 	sts	0x008A, r20
	sei();
     4f8:	78 94       	sei
	
	old_value = value;
     4fa:	50 93 21 01 	sts	0x0121, r21
     4fe:	40 93 20 01 	sts	0x0120, r20
}
     502:	08 95       	ret

00000504 <VOutProcess>:
inline void VOutProcess()
{
    double k = K_12;
    double U;

	U = Reverse4(RegFile.mb_struct.U_max) * VolumePercent;
     504:	60 91 85 02 	lds	r22, 0x0285
     508:	70 91 86 02 	lds	r23, 0x0286
     50c:	80 91 87 02 	lds	r24, 0x0287
     510:	90 91 88 02 	lds	r25, 0x0288
     514:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <Reverse4>
	
	VOutWidthSet(VOUT_TIMER_MAX_TIMER_VALUE * (U / (k * VCC)));
     518:	20 91 38 01 	lds	r18, 0x0138
     51c:	30 91 39 01 	lds	r19, 0x0139
     520:	40 91 3a 01 	lds	r20, 0x013A
     524:	50 91 3b 01 	lds	r21, 0x013B
     528:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__mulsf3>
     52c:	20 e0       	ldi	r18, 0x00	; 0
     52e:	30 e0       	ldi	r19, 0x00	; 0
     530:	40 e7       	ldi	r20, 0x70	; 112
     532:	51 e4       	ldi	r21, 0x41	; 65
     534:	0e 94 79 1a 	call	0x34f2	; 0x34f2 <__divsf3>
     538:	20 e0       	ldi	r18, 0x00	; 0
     53a:	3f ef       	ldi	r19, 0xFF	; 255
     53c:	4f e7       	ldi	r20, 0x7F	; 127
     53e:	57 e4       	ldi	r21, 0x47	; 71
     540:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__mulsf3>
     544:	0e 94 e1 1a 	call	0x35c2	; 0x35c2 <__fixunssfsi>
     548:	ab 01       	movw	r20, r22

unsigned short old_value = 0;
unsigned short new_value = 0;
inline void VOutWidthSet(unsigned short value)
{
    new_value = value;
     54a:	70 93 23 01 	sts	0x0123, r23
     54e:	60 93 22 01 	sts	0x0122, r22
	if ((value > (old_value + 100)) || (value < (old_value - 100)))
     552:	20 91 20 01 	lds	r18, 0x0120
     556:	30 91 21 01 	lds	r19, 0x0121
     55a:	c9 01       	movw	r24, r18
     55c:	8c 59       	subi	r24, 0x9C	; 156
     55e:	9f 4f       	sbci	r25, 0xFF	; 255
     560:	84 17       	cp	r24, r20
     562:	95 07       	cpc	r25, r21
     564:	28 f0       	brcs	.+10     	; 0x570 <VOutProcess+0x6c>
     566:	24 56       	subi	r18, 0x64	; 100
     568:	30 40       	sbci	r19, 0x00	; 0
     56a:	42 17       	cp	r20, r18
     56c:	53 07       	cpc	r21, r19
     56e:	20 f4       	brcc	.+8      	; 0x578 <VOutProcess+0x74>
	{
		old_value = value;
     570:	50 93 21 01 	sts	0x0121, r21
     574:	40 93 20 01 	sts	0x0120, r20
	}
	cli();
     578:	f8 94       	cli
	OCR1B = value;
     57a:	50 93 8b 00 	sts	0x008B, r21
     57e:	40 93 8a 00 	sts	0x008A, r20
	sei();
     582:	78 94       	sei
	
	old_value = value;
     584:	50 93 21 01 	sts	0x0121, r21
     588:	40 93 20 01 	sts	0x0120, r20
    double U;

	U = Reverse4(RegFile.mb_struct.U_max) * VolumePercent;
	
	VOutWidthSet(VOUT_TIMER_MAX_TIMER_VALUE * (U / (k * VCC)));
}
     58c:	08 95       	ret

0000058e <ROutWidthSet>:
    sbi(OC0A_DDR, OC0A_PIN);
}

inline void ROutWidthSet(unsigned char value)
{
        OCR0A = value;
     58e:	87 bd       	out	0x27, r24	; 39
}
     590:	08 95       	ret

00000592 <GetLogR>:
    return SET_R_OK;
}

// вычисление процента заполнени€ датчика
double GetLogR(void)
{
     592:	2f 92       	push	r2
     594:	3f 92       	push	r3
     596:	4f 92       	push	r4
     598:	5f 92       	push	r5
     59a:	6f 92       	push	r6
     59c:	7f 92       	push	r7
     59e:	8f 92       	push	r8
     5a0:	9f 92       	push	r9
     5a2:	af 92       	push	r10
     5a4:	bf 92       	push	r11
     5a6:	cf 92       	push	r12
     5a8:	df 92       	push	r13
     5aa:	ef 92       	push	r14
     5ac:	ff 92       	push	r15
     5ae:	0f 93       	push	r16
     5b0:	1f 93       	push	r17
     5b2:	cf 93       	push	r28
     5b4:	df 93       	push	r29
     5b6:	57 e0       	ldi	r21, 0x07	; 7
     5b8:	a5 2e       	mov	r10, r21
     5ba:	01 c0       	rjmp	.+2      	; 0x5be <GetLogR+0x2c>
	byte i;
	double  temp;
	double  x1, x2, y1, y2;  // ѕеременные используемы дл€ вычислени€ по уравнению пр€мой промежуточного значени€ между двум€ табличными значени€ми
												    	
	i = LOG_PAR_COUNT - 2;
	while((VolumePercent < Reverse4(RegFile.mb_struct.log_param.Vtable[i])) && i > 0) i--; // Ќаходим после какой точки в таблице находитс€ потдерживаемое значение
     5bc:	aa 94       	dec	r10
     5be:	e0 90 38 01 	lds	r14, 0x0138
     5c2:	f0 90 39 01 	lds	r15, 0x0139
     5c6:	00 91 3a 01 	lds	r16, 0x013A
     5ca:	10 91 3b 01 	lds	r17, 0x013B
     5ce:	ca 2d       	mov	r28, r10
     5d0:	d0 e0       	ldi	r29, 0x00	; 0
     5d2:	fe 01       	movw	r30, r28
     5d4:	ee 0f       	add	r30, r30
     5d6:	ff 1f       	adc	r31, r31
     5d8:	ee 0f       	add	r30, r30
     5da:	ff 1f       	adc	r31, r31
     5dc:	eb 51       	subi	r30, 0x1B	; 27
     5de:	fc 4f       	sbci	r31, 0xFC	; 252
     5e0:	60 81       	ld	r22, Z
     5e2:	71 81       	ldd	r23, Z+1	; 0x01
     5e4:	82 81       	ldd	r24, Z+2	; 0x02
     5e6:	93 81       	ldd	r25, Z+3	; 0x03
     5e8:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <Reverse4>
     5ec:	9b 01       	movw	r18, r22
     5ee:	ac 01       	movw	r20, r24
     5f0:	c8 01       	movw	r24, r16
     5f2:	b7 01       	movw	r22, r14
     5f4:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__cmpsf2>
     5f8:	88 23       	and	r24, r24
     5fa:	14 f4       	brge	.+4      	; 0x600 <GetLogR+0x6e>
     5fc:	aa 20       	and	r10, r10
     5fe:	f1 f6       	brne	.-68     	; 0x5bc <GetLogR+0x2a>
	// ƒалее вычисл€ем по уравнению кривой промежуточное знаение между двум€ табличными
	// “акой подход дает вычисление конкретного значени€ ј÷ѕ приконкретном уровне топлива. “ем самым мы получаем не дискретную систему а непрерывную.
	// “аким образом мы избегаем колебаниие стрелки между двум€ табличными значени€ми
	
    x1 = Reverse4(RegFile.mb_struct.log_param.Vtable[i]); 
     600:	fe 01       	movw	r30, r28
     602:	ee 0f       	add	r30, r30
     604:	ff 1f       	adc	r31, r31
     606:	ee 0f       	add	r30, r30
     608:	ff 1f       	adc	r31, r31
     60a:	eb 51       	subi	r30, 0x1B	; 27
     60c:	fc 4f       	sbci	r31, 0xFC	; 252
     60e:	60 81       	ld	r22, Z
     610:	71 81       	ldd	r23, Z+1	; 0x01
     612:	82 81       	ldd	r24, Z+2	; 0x02
     614:	93 81       	ldd	r25, Z+3	; 0x03
     616:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <Reverse4>
     61a:	3b 01       	movw	r6, r22
     61c:	4c 01       	movw	r8, r24
	x2 = Reverse4(RegFile.mb_struct.log_param.Vtable[i+1]);
     61e:	fe 01       	movw	r30, r28
     620:	ee 0f       	add	r30, r30
     622:	ff 1f       	adc	r31, r31
     624:	ee 0f       	add	r30, r30
     626:	ff 1f       	adc	r31, r31
     628:	e7 51       	subi	r30, 0x17	; 23
     62a:	fc 4f       	sbci	r31, 0xFC	; 252
     62c:	60 81       	ld	r22, Z
     62e:	71 81       	ldd	r23, Z+1	; 0x01
     630:	82 81       	ldd	r24, Z+2	; 0x02
     632:	93 81       	ldd	r25, Z+3	; 0x03
     634:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <Reverse4>
     638:	1b 01       	movw	r2, r22
     63a:	2c 01       	movw	r4, r24
	
    y1 = Reverse4(RegFile.mb_struct.log_param.Rtable[i]);
     63c:	cc 0f       	add	r28, r28
     63e:	dd 1f       	adc	r29, r29
     640:	cc 0f       	add	r28, r28
     642:	dd 1f       	adc	r29, r29
     644:	fe 01       	movw	r30, r28
     646:	e7 5f       	subi	r30, 0xF7	; 247
     648:	fb 4f       	sbci	r31, 0xFB	; 251
     64a:	60 81       	ld	r22, Z
     64c:	71 81       	ldd	r23, Z+1	; 0x01
     64e:	82 81       	ldd	r24, Z+2	; 0x02
     650:	93 81       	ldd	r25, Z+3	; 0x03
     652:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <Reverse4>
     656:	5b 01       	movw	r10, r22
     658:	6c 01       	movw	r12, r24
	y2 = Reverse4(RegFile.mb_struct.log_param.Rtable[i+1]);
     65a:	c3 5f       	subi	r28, 0xF3	; 243
     65c:	db 4f       	sbci	r29, 0xFB	; 251
     65e:	68 81       	ld	r22, Y
     660:	79 81       	ldd	r23, Y+1	; 0x01
     662:	8a 81       	ldd	r24, Y+2	; 0x02
     664:	9b 81       	ldd	r25, Y+3	; 0x03
     666:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <Reverse4>
	
    temp  = (y2 - y1) * (VolumePercent - x1);
     66a:	a6 01       	movw	r20, r12
     66c:	95 01       	movw	r18, r10
     66e:	0e 94 10 1a 	call	0x3420	; 0x3420 <__subsf3>
     672:	7b 01       	movw	r14, r22
     674:	8c 01       	movw	r16, r24
     676:	60 91 38 01 	lds	r22, 0x0138
     67a:	70 91 39 01 	lds	r23, 0x0139
     67e:	80 91 3a 01 	lds	r24, 0x013A
     682:	90 91 3b 01 	lds	r25, 0x013B
     686:	a4 01       	movw	r20, r8
     688:	93 01       	movw	r18, r6
     68a:	0e 94 10 1a 	call	0x3420	; 0x3420 <__subsf3>
     68e:	9b 01       	movw	r18, r22
     690:	ac 01       	movw	r20, r24
     692:	c8 01       	movw	r24, r16
     694:	b7 01       	movw	r22, r14
     696:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__mulsf3>
     69a:	7b 01       	movw	r14, r22
     69c:	8c 01       	movw	r16, r24
	temp /= (x2 - x1);
     69e:	c2 01       	movw	r24, r4
     6a0:	b1 01       	movw	r22, r2
     6a2:	a4 01       	movw	r20, r8
     6a4:	93 01       	movw	r18, r6
     6a6:	0e 94 10 1a 	call	0x3420	; 0x3420 <__subsf3>
     6aa:	9b 01       	movw	r18, r22
     6ac:	ac 01       	movw	r20, r24
     6ae:	c8 01       	movw	r24, r16
     6b0:	b7 01       	movw	r22, r14
     6b2:	0e 94 79 1a 	call	0x34f2	; 0x34f2 <__divsf3>
     6b6:	a6 01       	movw	r20, r12
     6b8:	95 01       	movw	r18, r10
     6ba:	0e 94 11 1a 	call	0x3422	; 0x3422 <__addsf3>
	temp += (y1);
		
	return temp;
}
     6be:	df 91       	pop	r29
     6c0:	cf 91       	pop	r28
     6c2:	1f 91       	pop	r17
     6c4:	0f 91       	pop	r16
     6c6:	ff 90       	pop	r15
     6c8:	ef 90       	pop	r14
     6ca:	df 90       	pop	r13
     6cc:	cf 90       	pop	r12
     6ce:	bf 90       	pop	r11
     6d0:	af 90       	pop	r10
     6d2:	9f 90       	pop	r9
     6d4:	8f 90       	pop	r8
     6d6:	7f 90       	pop	r7
     6d8:	6f 90       	pop	r6
     6da:	5f 90       	pop	r5
     6dc:	4f 90       	pop	r4
     6de:	3f 90       	pop	r3
     6e0:	2f 90       	pop	r2
     6e2:	08 95       	ret

000006e4 <GetAIN_I_Value>:
double iR = 0;
inline double GetAIN_I_Value()
{
  	double value ;

	value = ADCGetRoundedValue(AIN_I_CHANNEL);
     6e4:	87 e0       	ldi	r24, 0x07	; 7
     6e6:	0e 94 5e 17 	call	0x2ebc	; 0x2ebc <ADCGetRoundedValue>
     6ea:	20 e0       	ldi	r18, 0x00	; 0
     6ec:	30 e0       	ldi	r19, 0x00	; 0
     6ee:	48 ea       	ldi	r20, 0xA8	; 168
     6f0:	51 e4       	ldi	r21, 0x41	; 65
     6f2:	0e 94 79 1a 	call	0x34f2	; 0x34f2 <__divsf3>
    value = value / (AIN_I_R * AIN_I_AMP_K);   
    return value;  
}
     6f6:	08 95       	ret

000006f8 <GetAIN_U_Value>:
double uR = 0;
inline double GetAIN_U_Value()
{
	double value ;

	value = ADCGetRoundedValue(AIN_U_CHANNEL);
     6f8:	86 e0       	ldi	r24, 0x06	; 6
     6fa:	0e 94 5e 17 	call	0x2ebc	; 0x2ebc <ADCGetRoundedValue>
	value = value * (AIN_U_LOW_R + AIN_U_HIGH_R) / AIN_U_LOW_R;
     6fe:	20 e0       	ldi	r18, 0x00	; 0
     700:	38 ed       	ldi	r19, 0xD8	; 216
     702:	46 ed       	ldi	r20, 0xD6	; 214
     704:	57 e4       	ldi	r21, 0x47	; 71
     706:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__mulsf3>
     70a:	20 e0       	ldi	r18, 0x00	; 0
     70c:	30 e4       	ldi	r19, 0x40	; 64
     70e:	4c e1       	ldi	r20, 0x1C	; 28
     710:	56 e4       	ldi	r21, 0x46	; 70
     712:	0e 94 79 1a 	call	0x34f2	; 0x34f2 <__divsf3>
    return value;  
}
     716:	08 95       	ret

00000718 <GetR>:
}

volatile double currentR = 0;

inline double GetR()
{
     718:	af 92       	push	r10
     71a:	bf 92       	push	r11
     71c:	cf 92       	push	r12
     71e:	df 92       	push	r13
     720:	ef 92       	push	r14
     722:	ff 92       	push	r15
     724:	0f 93       	push	r16
     726:	1f 93       	push	r17
	iR = GetAIN_I_Value();
     728:	0e 94 72 03 	call	0x6e4	; 0x6e4 <GetAIN_I_Value>
     72c:	60 93 28 01 	sts	0x0128, r22
     730:	70 93 29 01 	sts	0x0129, r23
     734:	80 93 2a 01 	sts	0x012A, r24
     738:	90 93 2b 01 	sts	0x012B, r25
	uR = GetAIN_U_Value();
     73c:	0e 94 7c 03 	call	0x6f8	; 0x6f8 <GetAIN_U_Value>
     740:	7b 01       	movw	r14, r22
     742:	8c 01       	movw	r16, r24
     744:	60 93 24 01 	sts	0x0124, r22
     748:	70 93 25 01 	sts	0x0125, r23
     74c:	80 93 26 01 	sts	0x0126, r24
     750:	90 93 27 01 	sts	0x0127, r25

	if(uR < 0.015)
     754:	2f e8       	ldi	r18, 0x8F	; 143
     756:	32 ec       	ldi	r19, 0xC2	; 194
     758:	45 e7       	ldi	r20, 0x75	; 117
     75a:	5c e3       	ldi	r21, 0x3C	; 60
     75c:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__cmpsf2>
     760:	88 23       	and	r24, r24
     762:	0c f4       	brge	.+2      	; 0x766 <GetR+0x4e>
     764:	43 c0       	rjmp	.+134    	; 0x7ec <GetR+0xd4>
		return -1;

	if (iR < 0.0001)
     766:	a0 90 28 01 	lds	r10, 0x0128
     76a:	b0 90 29 01 	lds	r11, 0x0129
     76e:	c0 90 2a 01 	lds	r12, 0x012A
     772:	d0 90 2b 01 	lds	r13, 0x012B
     776:	c6 01       	movw	r24, r12
     778:	b5 01       	movw	r22, r10
     77a:	27 e1       	ldi	r18, 0x17	; 23
     77c:	37 eb       	ldi	r19, 0xB7	; 183
     77e:	41 ed       	ldi	r20, 0xD1	; 209
     780:	58 e3       	ldi	r21, 0x38	; 56
     782:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__cmpsf2>
     786:	88 23       	and	r24, r24
     788:	b4 f5       	brge	.+108    	; 0x7f6 <GetR+0xde>
	{
		if (ROutPWMValue >= (ROUT_PWM_MIN + ROUT_PWM_STEP))
     78a:	60 91 53 01 	lds	r22, 0x0153
     78e:	70 91 54 01 	lds	r23, 0x0154
     792:	80 91 55 01 	lds	r24, 0x0155
     796:	90 91 56 01 	lds	r25, 0x0156
     79a:	2d ec       	ldi	r18, 0xCD	; 205
     79c:	3c ec       	ldi	r19, 0xCC	; 204
     79e:	4c e4       	ldi	r20, 0x4C	; 76
     7a0:	5d e3       	ldi	r21, 0x3D	; 61
     7a2:	0e 94 bf 1b 	call	0x377e	; 0x377e <__gesf2>
     7a6:	87 fd       	sbrc	r24, 7
     7a8:	21 c0       	rjmp	.+66     	; 0x7ec <GetR+0xd4>
            {
                // Using PWM
                ROutPWMValue -= ROUT_PWM_STEP;
     7aa:	60 91 53 01 	lds	r22, 0x0153
     7ae:	70 91 54 01 	lds	r23, 0x0154
     7b2:	80 91 55 01 	lds	r24, 0x0155
     7b6:	90 91 56 01 	lds	r25, 0x0156
     7ba:	2d ec       	ldi	r18, 0xCD	; 205
     7bc:	3c ec       	ldi	r19, 0xCC	; 204
     7be:	4c e4       	ldi	r20, 0x4C	; 76
     7c0:	5d e3       	ldi	r21, 0x3D	; 61
     7c2:	0e 94 10 1a 	call	0x3420	; 0x3420 <__subsf3>
     7c6:	60 93 53 01 	sts	0x0153, r22
     7ca:	70 93 54 01 	sts	0x0154, r23
     7ce:	80 93 55 01 	sts	0x0155, r24
     7d2:	90 93 56 01 	sts	0x0156, r25
                ROutWidthSet((unsigned char)ROutPWMValue);
     7d6:	60 91 53 01 	lds	r22, 0x0153
     7da:	70 91 54 01 	lds	r23, 0x0154
     7de:	80 91 55 01 	lds	r24, 0x0155
     7e2:	90 91 56 01 	lds	r25, 0x0156
     7e6:	0e 94 e1 1a 	call	0x35c2	; 0x35c2 <__fixunssfsi>
    sbi(OC0A_DDR, OC0A_PIN);
}

inline void ROutWidthSet(unsigned char value)
{
        OCR0A = value;
     7ea:	67 bd       	out	0x27, r22	; 39
     7ec:	e0 e0       	ldi	r30, 0x00	; 0
     7ee:	70 e0       	ldi	r23, 0x00	; 0
     7f0:	80 e8       	ldi	r24, 0x80	; 128
     7f2:	6f eb       	ldi	r22, 0xBF	; 191
     7f4:	1e c0       	rjmp	.+60     	; 0x832 <GetR+0x11a>
        return -1;
	}

    double iDivider = uR / (AIN_U_HIGH_R + AIN_U_LOW_R);
    
    iR += iDivider;
     7f6:	c8 01       	movw	r24, r16
     7f8:	b7 01       	movw	r22, r14
     7fa:	20 e0       	ldi	r18, 0x00	; 0
     7fc:	38 ed       	ldi	r19, 0xD8	; 216
     7fe:	46 ed       	ldi	r20, 0xD6	; 214
     800:	57 e4       	ldi	r21, 0x47	; 71
     802:	0e 94 79 1a 	call	0x34f2	; 0x34f2 <__divsf3>
     806:	9b 01       	movw	r18, r22
     808:	ac 01       	movw	r20, r24
     80a:	c6 01       	movw	r24, r12
     80c:	b5 01       	movw	r22, r10
     80e:	0e 94 11 1a 	call	0x3422	; 0x3422 <__addsf3>
     812:	9b 01       	movw	r18, r22
     814:	ac 01       	movw	r20, r24
     816:	60 93 28 01 	sts	0x0128, r22
     81a:	70 93 29 01 	sts	0x0129, r23
     81e:	80 93 2a 01 	sts	0x012A, r24
     822:	90 93 2b 01 	sts	0x012B, r25

    return (uR / iR);
     826:	c8 01       	movw	r24, r16
     828:	b7 01       	movw	r22, r14
     82a:	0e 94 79 1a 	call	0x34f2	; 0x34f2 <__divsf3>
     82e:	e6 2f       	mov	r30, r22
     830:	69 2f       	mov	r22, r25
}
     832:	2e 2f       	mov	r18, r30
     834:	37 2f       	mov	r19, r23
     836:	48 2f       	mov	r20, r24
     838:	56 2f       	mov	r21, r22
     83a:	b9 01       	movw	r22, r18
     83c:	ca 01       	movw	r24, r20
     83e:	1f 91       	pop	r17
     840:	0f 91       	pop	r16
     842:	ff 90       	pop	r15
     844:	ef 90       	pop	r14
     846:	df 90       	pop	r13
     848:	cf 90       	pop	r12
     84a:	bf 90       	pop	r11
     84c:	af 90       	pop	r10
     84e:	08 95       	ret

00000850 <SetR>:

inline unsigned char SetR(double newR, double maxR)
{
     850:	2f 92       	push	r2
     852:	3f 92       	push	r3
     854:	4f 92       	push	r4
     856:	5f 92       	push	r5
     858:	6f 92       	push	r6
     85a:	7f 92       	push	r7
     85c:	8f 92       	push	r8
     85e:	9f 92       	push	r9
     860:	af 92       	push	r10
     862:	bf 92       	push	r11
     864:	cf 92       	push	r12
     866:	df 92       	push	r13
     868:	ef 92       	push	r14
     86a:	ff 92       	push	r15
     86c:	0f 93       	push	r16
     86e:	1f 93       	push	r17
     870:	5b 01       	movw	r10, r22
     872:	6c 01       	movw	r12, r24
     874:	19 01       	movw	r2, r18
     876:	2a 01       	movw	r4, r20
    
	double delta_R;
	double pot_step;
	double pot_max;
	
    currentR = GetR();
     878:	0e 94 8c 03 	call	0x718	; 0x718 <GetR>
     87c:	60 93 2c 01 	sts	0x012C, r22
     880:	70 93 2d 01 	sts	0x012D, r23
     884:	80 93 2e 01 	sts	0x012E, r24
     888:	90 93 2f 01 	sts	0x012F, r25
	
	if(currentR == -1)
     88c:	60 91 2c 01 	lds	r22, 0x012C
     890:	70 91 2d 01 	lds	r23, 0x012D
     894:	80 91 2e 01 	lds	r24, 0x012E
     898:	90 91 2f 01 	lds	r25, 0x012F
     89c:	20 e0       	ldi	r18, 0x00	; 0
     89e:	30 e0       	ldi	r19, 0x00	; 0
     8a0:	40 e8       	ldi	r20, 0x80	; 128
     8a2:	5f eb       	ldi	r21, 0xBF	; 191
     8a4:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__cmpsf2>
     8a8:	88 23       	and	r24, r24
     8aa:	09 f4       	brne	.+2      	; 0x8ae <SetR+0x5e>
     8ac:	0e c1       	rjmp	.+540    	; 0xaca <SetR+0x27a>
		return SET_R_ERROR;
	
	delta_R = fabs(newR - currentR);
     8ae:	20 91 2c 01 	lds	r18, 0x012C
     8b2:	30 91 2d 01 	lds	r19, 0x012D
     8b6:	40 91 2e 01 	lds	r20, 0x012E
     8ba:	50 91 2f 01 	lds	r21, 0x012F
     8be:	c6 01       	movw	r24, r12
     8c0:	b5 01       	movw	r22, r10
     8c2:	0e 94 10 1a 	call	0x3420	; 0x3420 <__subsf3>
     8c6:	3b 01       	movw	r6, r22
     8c8:	4c 01       	movw	r8, r24
     8ca:	e8 94       	clt
     8cc:	97 f8       	bld	r9, 7

    if (delta_R <= DELTA_R)
     8ce:	c4 01       	movw	r24, r8
     8d0:	b3 01       	movw	r22, r6
     8d2:	20 e0       	ldi	r18, 0x00	; 0
     8d4:	30 e0       	ldi	r19, 0x00	; 0
     8d6:	40 e0       	ldi	r20, 0x00	; 0
     8d8:	5f e3       	ldi	r21, 0x3F	; 63
     8da:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__cmpsf2>
     8de:	18 16       	cp	r1, r24
     8e0:	0c f0       	brlt	.+2      	; 0x8e4 <SetR+0x94>
     8e2:	e0 c0       	rjmp	.+448    	; 0xaa4 <SetR+0x254>
        return SET_R_OK;

	if(delta_R > (maxR * 0.01))
     8e4:	c2 01       	movw	r24, r4
     8e6:	b1 01       	movw	r22, r2
     8e8:	2a e0       	ldi	r18, 0x0A	; 10
     8ea:	37 ed       	ldi	r19, 0xD7	; 215
     8ec:	43 e2       	ldi	r20, 0x23	; 35
     8ee:	5c e3       	ldi	r21, 0x3C	; 60
     8f0:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__mulsf3>
     8f4:	9b 01       	movw	r18, r22
     8f6:	ac 01       	movw	r20, r24
     8f8:	c4 01       	movw	r24, r8
     8fa:	b3 01       	movw	r22, r6
     8fc:	0e 94 bf 1b 	call	0x377e	; 0x377e <__gesf2>
     900:	18 16       	cp	r1, r24
     902:	5c f0       	brlt	.+22     	; 0x91a <SetR+0xca>
     904:	0f 2e       	mov	r0, r31
     906:	fd ec       	ldi	r31, 0xCD	; 205
     908:	ef 2e       	mov	r14, r31
     90a:	fc ec       	ldi	r31, 0xCC	; 204
     90c:	ff 2e       	mov	r15, r31
     90e:	fc e4       	ldi	r31, 0x4C	; 76
     910:	0f 2f       	mov	r16, r31
     912:	fd e3       	ldi	r31, 0x3D	; 61
     914:	1f 2f       	mov	r17, r31
     916:	f0 2d       	mov	r31, r0
     918:	0a c0       	rjmp	.+20     	; 0x92e <SetR+0xde>
     91a:	0f 2e       	mov	r0, r31
     91c:	f0 e0       	ldi	r31, 0x00	; 0
     91e:	ef 2e       	mov	r14, r31
     920:	f0 e0       	ldi	r31, 0x00	; 0
     922:	ff 2e       	mov	r15, r31
     924:	f0 e0       	ldi	r31, 0x00	; 0
     926:	0f 2f       	mov	r16, r31
     928:	ff e3       	ldi	r31, 0x3F	; 63
     92a:	1f 2f       	mov	r17, r31
     92c:	f0 2d       	mov	r31, r0
		pot_step = 0.5;
	else
		pot_step = POT_STEP;    

    if (currentR < newR)
     92e:	60 91 2c 01 	lds	r22, 0x012C
     932:	70 91 2d 01 	lds	r23, 0x012D
     936:	80 91 2e 01 	lds	r24, 0x012E
     93a:	90 91 2f 01 	lds	r25, 0x012F
     93e:	a6 01       	movw	r20, r12
     940:	95 01       	movw	r18, r10
     942:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__cmpsf2>
     946:	88 23       	and	r24, r24
     948:	0c f0       	brlt	.+2      	; 0x94c <SetR+0xfc>
     94a:	3f c0       	rjmp	.+126    	; 0x9ca <SetR+0x17a>
    {
		// need to increase R_OUT
        if (PotValue >= (POT_MIN_VALUE + pot_step) )
     94c:	a0 90 4f 01 	lds	r10, 0x014F
     950:	b0 90 50 01 	lds	r11, 0x0150
     954:	c0 90 51 01 	lds	r12, 0x0151
     958:	d0 90 52 01 	lds	r13, 0x0152
     95c:	c8 01       	movw	r24, r16
     95e:	b7 01       	movw	r22, r14
     960:	20 e0       	ldi	r18, 0x00	; 0
     962:	30 e0       	ldi	r19, 0x00	; 0
     964:	40 ec       	ldi	r20, 0xC0	; 192
     966:	50 e4       	ldi	r21, 0x40	; 64
     968:	0e 94 11 1a 	call	0x3422	; 0x3422 <__addsf3>
     96c:	9b 01       	movw	r18, r22
     96e:	ac 01       	movw	r20, r24
     970:	c6 01       	movw	r24, r12
     972:	b5 01       	movw	r22, r10
     974:	0e 94 bf 1b 	call	0x377e	; 0x377e <__gesf2>
     978:	88 23       	and	r24, r24
     97a:	3c f0       	brlt	.+14     	; 0x98a <SetR+0x13a>
        {
            // Using Digital Potentiometer if possible
            PotValue -= pot_step;
     97c:	c6 01       	movw	r24, r12
     97e:	b5 01       	movw	r22, r10
     980:	a8 01       	movw	r20, r16
     982:	97 01       	movw	r18, r14
     984:	0e 94 10 1a 	call	0x3420	; 0x3420 <__subsf3>
     988:	4d c0       	rjmp	.+154    	; 0xa24 <SetR+0x1d4>
            PotSet((unsigned char)PotValue);
        } 
        else
        {
            if (ROutPWMValue <= (ROUT_PWM_MAX - ROUT_PWM_STEP))
     98a:	60 91 53 01 	lds	r22, 0x0153
     98e:	70 91 54 01 	lds	r23, 0x0154
     992:	80 91 55 01 	lds	r24, 0x0155
     996:	90 91 56 01 	lds	r25, 0x0156
     99a:	23 e3       	ldi	r18, 0x33	; 51
     99c:	33 ef       	ldi	r19, 0xF3	; 243
     99e:	4e e7       	ldi	r20, 0x7E	; 126
     9a0:	53 e4       	ldi	r21, 0x43	; 67
     9a2:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__cmpsf2>
     9a6:	18 16       	cp	r1, r24
     9a8:	0c f4       	brge	.+2      	; 0x9ac <SetR+0x15c>
     9aa:	7e c0       	rjmp	.+252    	; 0xaa8 <SetR+0x258>
            {
                // Using PWM
                ROutPWMValue += ROUT_PWM_STEP;
     9ac:	60 91 53 01 	lds	r22, 0x0153
     9b0:	70 91 54 01 	lds	r23, 0x0154
     9b4:	80 91 55 01 	lds	r24, 0x0155
     9b8:	90 91 56 01 	lds	r25, 0x0156
     9bc:	2d ec       	ldi	r18, 0xCD	; 205
     9be:	3c ec       	ldi	r19, 0xCC	; 204
     9c0:	4c e4       	ldi	r20, 0x4C	; 76
     9c2:	5d e3       	ldi	r21, 0x3D	; 61
     9c4:	0e 94 11 1a 	call	0x3422	; 0x3422 <__addsf3>
     9c8:	5a c0       	rjmp	.+180    	; 0xa7e <SetR+0x22e>
            }
        }
    }
    else
    {
		if(newR < 35)
     9ca:	c6 01       	movw	r24, r12
     9cc:	b5 01       	movw	r22, r10
     9ce:	20 e0       	ldi	r18, 0x00	; 0
     9d0:	30 e0       	ldi	r19, 0x00	; 0
     9d2:	4c e0       	ldi	r20, 0x0C	; 12
     9d4:	52 e4       	ldi	r21, 0x42	; 66
     9d6:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__cmpsf2>
     9da:	87 fd       	sbrc	r24, 7
     9dc:	05 c0       	rjmp	.+10     	; 0x9e8 <SetR+0x198>
     9de:	60 e0       	ldi	r22, 0x00	; 0
     9e0:	70 e0       	ldi	r23, 0x00	; 0
     9e2:	82 e5       	ldi	r24, 0x52	; 82
     9e4:	93 e4       	ldi	r25, 0x43	; 67
     9e6:	04 c0       	rjmp	.+8      	; 0x9f0 <SetR+0x1a0>
     9e8:	60 e0       	ldi	r22, 0x00	; 0
     9ea:	70 e0       	ldi	r23, 0x00	; 0
     9ec:	8b e7       	ldi	r24, 0x7B	; 123
     9ee:	93 e4       	ldi	r25, 0x43	; 67
			pot_max = POT_VALUE(1000); // друга€ граница дл€ очень маленьких сопротивлений
		else
			pot_max = POT_MAX_VALUE;
        // need to decrease R_OUT
        if (PotValue <= (pot_max - pot_step) )
     9f0:	a0 90 4f 01 	lds	r10, 0x014F
     9f4:	b0 90 50 01 	lds	r11, 0x0150
     9f8:	c0 90 51 01 	lds	r12, 0x0151
     9fc:	d0 90 52 01 	lds	r13, 0x0152
     a00:	a8 01       	movw	r20, r16
     a02:	97 01       	movw	r18, r14
     a04:	0e 94 10 1a 	call	0x3420	; 0x3420 <__subsf3>
     a08:	9b 01       	movw	r18, r22
     a0a:	ac 01       	movw	r20, r24
     a0c:	c6 01       	movw	r24, r12
     a0e:	b5 01       	movw	r22, r10
     a10:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__cmpsf2>
     a14:	18 16       	cp	r1, r24
     a16:	ac f0       	brlt	.+42     	; 0xa42 <SetR+0x1f2>
        {
            // Using Digital Potentiometer if possible
            PotValue += pot_step;
     a18:	c6 01       	movw	r24, r12
     a1a:	b5 01       	movw	r22, r10
     a1c:	a8 01       	movw	r20, r16
     a1e:	97 01       	movw	r18, r14
     a20:	0e 94 11 1a 	call	0x3422	; 0x3422 <__addsf3>
     a24:	60 93 4f 01 	sts	0x014F, r22
     a28:	70 93 50 01 	sts	0x0150, r23
     a2c:	80 93 51 01 	sts	0x0151, r24
     a30:	90 93 52 01 	sts	0x0152, r25
            PotSet((unsigned char)PotValue);
     a34:	0e 94 e1 1a 	call	0x35c2	; 0x35c2 <__fixunssfsi>
     a38:	dc 01       	movw	r26, r24
     a3a:	cb 01       	movw	r24, r22
     a3c:	0e 94 10 02 	call	0x420	; 0x420 <PotSet>
     a40:	31 c0       	rjmp	.+98     	; 0xaa4 <SetR+0x254>
        } 
        else
        {
            if (ROutPWMValue >= (ROUT_PWM_MIN + ROUT_PWM_STEP))
     a42:	60 91 53 01 	lds	r22, 0x0153
     a46:	70 91 54 01 	lds	r23, 0x0154
     a4a:	80 91 55 01 	lds	r24, 0x0155
     a4e:	90 91 56 01 	lds	r25, 0x0156
     a52:	2d ec       	ldi	r18, 0xCD	; 205
     a54:	3c ec       	ldi	r19, 0xCC	; 204
     a56:	4c e4       	ldi	r20, 0x4C	; 76
     a58:	5d e3       	ldi	r21, 0x3D	; 61
     a5a:	0e 94 bf 1b 	call	0x377e	; 0x377e <__gesf2>
     a5e:	88 23       	and	r24, r24
     a60:	1c f1       	brlt	.+70     	; 0xaa8 <SetR+0x258>
            {
                // Using PWM
                ROutPWMValue -= ROUT_PWM_STEP;
     a62:	60 91 53 01 	lds	r22, 0x0153
     a66:	70 91 54 01 	lds	r23, 0x0154
     a6a:	80 91 55 01 	lds	r24, 0x0155
     a6e:	90 91 56 01 	lds	r25, 0x0156
     a72:	2d ec       	ldi	r18, 0xCD	; 205
     a74:	3c ec       	ldi	r19, 0xCC	; 204
     a76:	4c e4       	ldi	r20, 0x4C	; 76
     a78:	5d e3       	ldi	r21, 0x3D	; 61
     a7a:	0e 94 10 1a 	call	0x3420	; 0x3420 <__subsf3>
     a7e:	60 93 53 01 	sts	0x0153, r22
     a82:	70 93 54 01 	sts	0x0154, r23
     a86:	80 93 55 01 	sts	0x0155, r24
     a8a:	90 93 56 01 	sts	0x0156, r25
                ROutWidthSet((unsigned char)ROutPWMValue);
     a8e:	60 91 53 01 	lds	r22, 0x0153
     a92:	70 91 54 01 	lds	r23, 0x0154
     a96:	80 91 55 01 	lds	r24, 0x0155
     a9a:	90 91 56 01 	lds	r25, 0x0156
     a9e:	0e 94 e1 1a 	call	0x35c2	; 0x35c2 <__fixunssfsi>
    sbi(OC0A_DDR, OC0A_PIN);
}

inline void ROutWidthSet(unsigned char value)
{
        OCR0A = value;
     aa2:	67 bd       	out	0x27, r22	; 39
     aa4:	10 e0       	ldi	r17, 0x00	; 0
     aa6:	12 c0       	rjmp	.+36     	; 0xacc <SetR+0x27c>
     aa8:	10 e0       	ldi	r17, 0x00	; 0
     aaa:	c2 01       	movw	r24, r4
     aac:	b1 01       	movw	r22, r2
     aae:	2d ec       	ldi	r18, 0xCD	; 205
     ab0:	3c ec       	ldi	r19, 0xCC	; 204
     ab2:	4c e4       	ldi	r20, 0x4C	; 76
     ab4:	5e e3       	ldi	r21, 0x3E	; 62
     ab6:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__mulsf3>
     aba:	9b 01       	movw	r18, r22
     abc:	ac 01       	movw	r20, r24
     abe:	c4 01       	movw	r24, r8
     ac0:	b3 01       	movw	r22, r6
     ac2:	0e 94 bf 1b 	call	0x377e	; 0x377e <__gesf2>
     ac6:	18 16       	cp	r1, r24
     ac8:	0c f4       	brge	.+2      	; 0xacc <SetR+0x27c>
     aca:	11 e0       	ldi	r17, 0x01	; 1
            }
        }
    }
 
    return SET_R_OK;
}
     acc:	81 2f       	mov	r24, r17
     ace:	1f 91       	pop	r17
     ad0:	0f 91       	pop	r16
     ad2:	ff 90       	pop	r15
     ad4:	ef 90       	pop	r14
     ad6:	df 90       	pop	r13
     ad8:	cf 90       	pop	r12
     ada:	bf 90       	pop	r11
     adc:	af 90       	pop	r10
     ade:	9f 90       	pop	r9
     ae0:	8f 90       	pop	r8
     ae2:	7f 90       	pop	r7
     ae4:	6f 90       	pop	r6
     ae6:	5f 90       	pop	r5
     ae8:	4f 90       	pop	r4
     aea:	3f 90       	pop	r3
     aec:	2f 90       	pop	r2
     aee:	08 95       	ret

00000af0 <ROutProcess>:
		
	return temp;
}

unsigned char ROutProcess()
{
     af0:	ef 92       	push	r14
     af2:	ff 92       	push	r15
     af4:	0f 93       	push	r16
     af6:	1f 93       	push	r17
	double maxR;

	if (RegFile.mb_struct.Fl_logometr)
     af8:	80 91 79 02 	lds	r24, 0x0279
     afc:	90 91 7a 02 	lds	r25, 0x027A
     b00:	89 2b       	or	r24, r25
     b02:	11 f4       	brne	.+4      	; 0xb08 <ROutProcess+0x18>
     b04:	80 e0       	ldi	r24, 0x00	; 0
     b06:	2e c0       	rjmp	.+92     	; 0xb64 <ROutProcess+0x74>
    {
        maxR = Reverse4(RegFile.mb_struct.log_param.Rtable[ LOG_PAR_COUNT - 1 ]);
     b08:	60 91 29 04 	lds	r22, 0x0429
     b0c:	70 91 2a 04 	lds	r23, 0x042A
     b10:	80 91 2b 04 	lds	r24, 0x042B
     b14:	90 91 2c 04 	lds	r25, 0x042C
     b18:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <Reverse4>
     b1c:	7b 01       	movw	r14, r22
     b1e:	8c 01       	movw	r16, r24
		if(Reverse4(RegFile.mb_struct.log_param.Rtable[ 0 ]) > maxR) // провер€ем не инверсна€ ли у нас таблица сопротивлений
     b20:	60 91 09 04 	lds	r22, 0x0409
     b24:	70 91 0a 04 	lds	r23, 0x040A
     b28:	80 91 0b 04 	lds	r24, 0x040B
     b2c:	90 91 0c 04 	lds	r25, 0x040C
     b30:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <Reverse4>
     b34:	a8 01       	movw	r20, r16
     b36:	97 01       	movw	r18, r14
     b38:	0e 94 bf 1b 	call	0x377e	; 0x377e <__gesf2>
     b3c:	18 16       	cp	r1, r24
     b3e:	64 f4       	brge	.+24     	; 0xb58 <ROutProcess+0x68>
			maxR = Reverse4(RegFile.mb_struct.log_param.Rtable[ 0 ]); 
     b40:	60 91 09 04 	lds	r22, 0x0409
     b44:	70 91 0a 04 	lds	r23, 0x040A
     b48:	80 91 0b 04 	lds	r24, 0x040B
     b4c:	90 91 0c 04 	lds	r25, 0x040C
     b50:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <Reverse4>
     b54:	7b 01       	movw	r14, r22
     b56:	8c 01       	movw	r16, r24
		return SetR(GetLogR(), maxR);
     b58:	0e 94 c9 02 	call	0x592	; 0x592 <GetLogR>
     b5c:	a8 01       	movw	r20, r16
     b5e:	97 01       	movw	r18, r14
     b60:	0e 94 28 04 	call	0x850	; 0x850 <SetR>
    }
    
    return ERROR_OK;
}
     b64:	1f 91       	pop	r17
     b66:	0f 91       	pop	r16
     b68:	ff 90       	pop	r15
     b6a:	ef 90       	pop	r14
     b6c:	08 95       	ret

00000b6e <ROutInit>:

volatile double ROutPWMValue;

inline void ROutInit(void)
{   
    ADCInit();
     b6e:	0e 94 1f 17 	call	0x2e3e	; 0x2e3e <ADCInit>
    
    PotInit();  
     b72:	0e 94 1c 02 	call	0x438	; 0x438 <PotInit>

    cbi(PRR,  PRTIM0);      //On TIMER0
     b76:	80 91 64 00 	lds	r24, 0x0064
     b7a:	8f 7d       	andi	r24, 0xDF	; 223
     b7c:	80 93 64 00 	sts	0x0064, r24
 
    TCCR0B = ROUT_TIMER_CLOCK_DIVIRDER;
     b80:	82 e0       	ldi	r24, 0x02	; 2
     b82:	85 bd       	out	0x25, r24	; 37

	sbi(TCCR0A, COM0A1);    //  Clear OC0A on Compare Match, set OC0A at BOTTOM,
     b84:	84 b5       	in	r24, 0x24	; 36
     b86:	80 68       	ori	r24, 0x80	; 128
     b88:	84 bd       	out	0x24, r24	; 36
                            //  (non-inverting mode) 
	sbi(TCCR0A, WGM00);
     b8a:	84 b5       	in	r24, 0x24	; 36
     b8c:	81 60       	ori	r24, 0x01	; 1
     b8e:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM01);
     b90:	84 b5       	in	r24, 0x24	; 36
     b92:	82 60       	ori	r24, 0x02	; 2
     b94:	84 bd       	out	0x24, r24	; 36

	//настройка порта управл€ющего сигналом "—игнал ƒќ“"
	sbi(FREQ_OUT_PORT, FREQ_OUT_PIN);					//устанавливаетс€ 1 на выходе
     b96:	5b 9a       	sbi	0x0b, 3	; 11
	FREQ_OUT_DDR|=(1<<FREQ_OUT_PIN);	//порт программируетс€ как выход
     b98:	53 9a       	sbi	0x0a, 3	; 10

	if(RegFile.mb_struct.log_param.Rtable[ 0 ] > RegFile.mb_struct.log_param.Rtable[ LOG_PAR_COUNT - 1 ]) // провер€ем не инверсна€ ли у нас таблица сопротивлений
     b9a:	60 91 09 04 	lds	r22, 0x0409
     b9e:	70 91 0a 04 	lds	r23, 0x040A
     ba2:	80 91 0b 04 	lds	r24, 0x040B
     ba6:	90 91 0c 04 	lds	r25, 0x040C
     baa:	20 91 29 04 	lds	r18, 0x0429
     bae:	30 91 2a 04 	lds	r19, 0x042A
     bb2:	40 91 2b 04 	lds	r20, 0x042B
     bb6:	50 91 2c 04 	lds	r21, 0x042C
     bba:	0e 94 bf 1b 	call	0x377e	; 0x377e <__gesf2>
     bbe:	18 16       	cp	r1, r24
     bc0:	2c f4       	brge	.+10     	; 0xbcc <ROutInit+0x5e>
    	ROutPWMValue = 255; // ON PWM
     bc2:	80 e0       	ldi	r24, 0x00	; 0
     bc4:	90 e0       	ldi	r25, 0x00	; 0
     bc6:	af e7       	ldi	r26, 0x7F	; 127
     bc8:	b3 e4       	ldi	r27, 0x43	; 67
     bca:	04 c0       	rjmp	.+8      	; 0xbd4 <ROutInit+0x66>
	else ROutPWMValue = 0;  // OFF PWM
     bcc:	80 e0       	ldi	r24, 0x00	; 0
     bce:	90 e0       	ldi	r25, 0x00	; 0
     bd0:	a0 e0       	ldi	r26, 0x00	; 0
     bd2:	b0 e0       	ldi	r27, 0x00	; 0
     bd4:	80 93 53 01 	sts	0x0153, r24
     bd8:	90 93 54 01 	sts	0x0154, r25
     bdc:	a0 93 55 01 	sts	0x0155, r26
     be0:	b0 93 56 01 	sts	0x0156, r27

    OCR0A = ROutPWMValue;
     be4:	60 91 53 01 	lds	r22, 0x0153
     be8:	70 91 54 01 	lds	r23, 0x0154
     bec:	80 91 55 01 	lds	r24, 0x0155
     bf0:	90 91 56 01 	lds	r25, 0x0156
     bf4:	0e 94 e1 1a 	call	0x35c2	; 0x35c2 <__fixunssfsi>
     bf8:	67 bd       	out	0x27, r22	; 39

    // pin to out
    sbi(OC0A_DDR, OC0A_PIN);
     bfa:	56 9a       	sbi	0x0a, 6	; 10
}
     bfc:	08 95       	ret

00000bfe <__vector_10>:

	sbi(TIMSK1, ICIE1);
}

SIGNAL(SIG_INPUT_CAPTURE1)
{
     bfe:	1f 92       	push	r1
     c00:	0f 92       	push	r0
     c02:	0f b6       	in	r0, 0x3f	; 63
     c04:	0f 92       	push	r0
     c06:	11 24       	eor	r1, r1
     c08:	8f 93       	push	r24
     c0a:	9f 93       	push	r25
	switch(FREQ_DOT.State)
     c0c:	80 91 5b 01 	lds	r24, 0x015B
     c10:	81 30       	cpi	r24, 0x01	; 1
     c12:	19 f0       	breq	.+6      	; 0xc1a <__vector_10+0x1c>
     c14:	82 30       	cpi	r24, 0x02	; 2
     c16:	41 f5       	brne	.+80     	; 0xc68 <__vector_10+0x6a>
     c18:	0b c0       	rjmp	.+22     	; 0xc30 <__vector_10+0x32>
	{
		case START_FREQ_MEASURE:
				if(TIFR1 & (1 << TOV1))
     c1a:	b0 99       	sbic	0x16, 0	; 22
     c1c:	11 c0       	rjmp	.+34     	; 0xc40 <__vector_10+0x42>
				{
					FREQ_DOT.State = IDLE_FREQ_MEASURE;
					return;
				}
				FREQ_DOT.First_Capture = ICR1;
     c1e:	80 91 86 00 	lds	r24, 0x0086
     c22:	90 91 87 00 	lds	r25, 0x0087
     c26:	90 93 5d 01 	sts	0x015D, r25
     c2a:	80 93 5c 01 	sts	0x015C, r24
     c2e:	1c c0       	rjmp	.+56     	; 0xc68 <__vector_10+0x6a>
			break;
		case FREQ_MEASURE:
				if((FREQ_DOT.Count_Timer >= (N_Period_Measure - 1)) && (TIFR1 & (1 << TOV1)))
     c30:	80 91 57 01 	lds	r24, 0x0157
     c34:	90 91 58 01 	lds	r25, 0x0158
     c38:	43 97       	sbiw	r24, 0x13	; 19
     c3a:	28 f0       	brcs	.+10     	; 0xc46 <__vector_10+0x48>
     c3c:	b0 9b       	sbis	0x16, 0	; 22
     c3e:	03 c0       	rjmp	.+6      	; 0xc46 <__vector_10+0x48>
				{
					FREQ_DOT.State = IDLE_FREQ_MEASURE;
     c40:	10 92 5b 01 	sts	0x015B, r1
     c44:	11 c0       	rjmp	.+34     	; 0xc68 <__vector_10+0x6a>
					return;
				}
				FREQ_DOT.Count_Capture ++;
     c46:	80 91 59 01 	lds	r24, 0x0159
     c4a:	90 91 5a 01 	lds	r25, 0x015A
     c4e:	01 96       	adiw	r24, 0x01	; 1
     c50:	90 93 5a 01 	sts	0x015A, r25
     c54:	80 93 59 01 	sts	0x0159, r24
                FREQ_DOT.Last_Capture = ICR1;
     c58:	80 91 86 00 	lds	r24, 0x0086
     c5c:	90 91 87 00 	lds	r25, 0x0087
     c60:	90 93 5f 01 	sts	0x015F, r25
     c64:	80 93 5e 01 	sts	0x015E, r24
			break;
	}
}
     c68:	9f 91       	pop	r25
     c6a:	8f 91       	pop	r24
     c6c:	0f 90       	pop	r0
     c6e:	0f be       	out	0x3f, r0	; 63
     c70:	0f 90       	pop	r0
     c72:	1f 90       	pop	r1
     c74:	18 95       	reti

00000c76 <CoreFrequancyMeasure>:

double CoreFrequancyMeasure(void)
{
     c76:	af 92       	push	r10
     c78:	bf 92       	push	r11
     c7a:	cf 92       	push	r12
     c7c:	df 92       	push	r13
     c7e:	ef 92       	push	r14
     c80:	ff 92       	push	r15
     c82:	0f 93       	push	r16
     c84:	1f 93       	push	r17
	double freq;

	switch(FREQ_DOT.State)
     c86:	80 91 5b 01 	lds	r24, 0x015B
     c8a:	83 30       	cpi	r24, 0x03	; 3
     c8c:	29 f0       	breq	.+10     	; 0xc98 <CoreFrequancyMeasure+0x22>
     c8e:	e0 e0       	ldi	r30, 0x00	; 0
     c90:	70 e0       	ldi	r23, 0x00	; 0
     c92:	80 e8       	ldi	r24, 0x80	; 128
     c94:	6f eb       	ldi	r22, 0xBF	; 191
     c96:	8c c0       	rjmp	.+280    	; 0xdb0 <CoreFrequancyMeasure+0x13a>
	{
			case FREQ_REDY_MEASURE:
				FREQ_DOT.Tick_Counter  = ((long)VOUT_TIMER_MAX_TIMER_VALUE - (long)FREQ_DOT.First_Capture);
     c98:	20 91 5c 01 	lds	r18, 0x015C
     c9c:	30 91 5d 01 	lds	r19, 0x015D
     ca0:	40 e0       	ldi	r20, 0x00	; 0
     ca2:	50 e0       	ldi	r21, 0x00	; 0
     ca4:	8f ef       	ldi	r24, 0xFF	; 255
     ca6:	9f ef       	ldi	r25, 0xFF	; 255
     ca8:	a0 e0       	ldi	r26, 0x00	; 0
     caa:	b0 e0       	ldi	r27, 0x00	; 0
     cac:	82 1b       	sub	r24, r18
     cae:	93 0b       	sbc	r25, r19
     cb0:	a4 0b       	sbc	r26, r20
     cb2:	b5 0b       	sbc	r27, r21
     cb4:	80 93 60 01 	sts	0x0160, r24
     cb8:	90 93 61 01 	sts	0x0161, r25
     cbc:	a0 93 62 01 	sts	0x0162, r26
     cc0:	b0 93 63 01 	sts	0x0163, r27
				FREQ_DOT.Tick_Counter += ((long)VOUT_TIMER_MAX_TIMER_VALUE * (long)FREQ_DOT.Count_Timer);
     cc4:	e0 90 60 01 	lds	r14, 0x0160
     cc8:	f0 90 61 01 	lds	r15, 0x0161
     ccc:	00 91 62 01 	lds	r16, 0x0162
     cd0:	10 91 63 01 	lds	r17, 0x0163
     cd4:	60 91 57 01 	lds	r22, 0x0157
     cd8:	70 91 58 01 	lds	r23, 0x0158
     cdc:	80 e0       	ldi	r24, 0x00	; 0
     cde:	90 e0       	ldi	r25, 0x00	; 0
     ce0:	2f ef       	ldi	r18, 0xFF	; 255
     ce2:	3f ef       	ldi	r19, 0xFF	; 255
     ce4:	40 e0       	ldi	r20, 0x00	; 0
     ce6:	50 e0       	ldi	r21, 0x00	; 0
     ce8:	0e 94 26 1c 	call	0x384c	; 0x384c <__mulsi3>
     cec:	e6 0e       	add	r14, r22
     cee:	f7 1e       	adc	r15, r23
     cf0:	08 1f       	adc	r16, r24
     cf2:	19 1f       	adc	r17, r25
     cf4:	e0 92 60 01 	sts	0x0160, r14
     cf8:	f0 92 61 01 	sts	0x0161, r15
     cfc:	00 93 62 01 	sts	0x0162, r16
     d00:	10 93 63 01 	sts	0x0163, r17
				FREQ_DOT.Tick_Counter -= ((long)VOUT_TIMER_MAX_TIMER_VALUE - (long)FREQ_DOT.Last_Capture);
     d04:	20 91 60 01 	lds	r18, 0x0160
     d08:	30 91 61 01 	lds	r19, 0x0161
     d0c:	40 91 62 01 	lds	r20, 0x0162
     d10:	50 91 63 01 	lds	r21, 0x0163
     d14:	80 91 5e 01 	lds	r24, 0x015E
     d18:	90 91 5f 01 	lds	r25, 0x015F
     d1c:	2f 5f       	subi	r18, 0xFF	; 255
     d1e:	3f 4f       	sbci	r19, 0xFF	; 255
     d20:	40 40       	sbci	r20, 0x00	; 0
     d22:	50 40       	sbci	r21, 0x00	; 0
     d24:	a0 e0       	ldi	r26, 0x00	; 0
     d26:	b0 e0       	ldi	r27, 0x00	; 0
     d28:	28 0f       	add	r18, r24
     d2a:	39 1f       	adc	r19, r25
     d2c:	4a 1f       	adc	r20, r26
     d2e:	5b 1f       	adc	r21, r27
     d30:	20 93 60 01 	sts	0x0160, r18
     d34:	30 93 61 01 	sts	0x0161, r19
     d38:	40 93 62 01 	sts	0x0162, r20
     d3c:	50 93 63 01 	sts	0x0163, r21

				freq = ((double)TIMER1_CLOCK * (double)FREQ_DOT.Count_Capture) / (double)FREQ_DOT.Tick_Counter;
     d40:	60 91 59 01 	lds	r22, 0x0159
     d44:	70 91 5a 01 	lds	r23, 0x015A
     d48:	a0 90 60 01 	lds	r10, 0x0160
     d4c:	b0 90 61 01 	lds	r11, 0x0161
     d50:	c0 90 62 01 	lds	r12, 0x0162
     d54:	d0 90 63 01 	lds	r13, 0x0163
     d58:	80 e0       	ldi	r24, 0x00	; 0
     d5a:	90 e0       	ldi	r25, 0x00	; 0
     d5c:	0e 94 0d 1b 	call	0x361a	; 0x361a <__floatunsisf>
     d60:	20 e0       	ldi	r18, 0x00	; 0
     d62:	30 e0       	ldi	r19, 0x00	; 0
     d64:	41 e6       	ldi	r20, 0x61	; 97
     d66:	5b e4       	ldi	r21, 0x4B	; 75
     d68:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__mulsf3>
     d6c:	7b 01       	movw	r14, r22
     d6e:	8c 01       	movw	r16, r24
     d70:	c6 01       	movw	r24, r12
     d72:	b5 01       	movw	r22, r10
     d74:	0e 94 0f 1b 	call	0x361e	; 0x361e <__floatsisf>
     d78:	9b 01       	movw	r18, r22
     d7a:	ac 01       	movw	r20, r24
     d7c:	c8 01       	movw	r24, r16
     d7e:	b7 01       	movw	r22, r14
     d80:	0e 94 79 1a 	call	0x34f2	; 0x34f2 <__divsf3>
     d84:	e6 2f       	mov	r30, r22
     d86:	69 2f       	mov	r22, r25
			
				FREQ_DOT.First_Capture = 0;
     d88:	10 92 5d 01 	sts	0x015D, r1
     d8c:	10 92 5c 01 	sts	0x015C, r1
				FREQ_DOT.Last_Capture = 0;
     d90:	10 92 5f 01 	sts	0x015F, r1
     d94:	10 92 5e 01 	sts	0x015E, r1
				FREQ_DOT.Count_Timer = 0;
     d98:	10 92 58 01 	sts	0x0158, r1
     d9c:	10 92 57 01 	sts	0x0157, r1
				FREQ_DOT.Tick_Counter = 0;
     da0:	10 92 60 01 	sts	0x0160, r1
     da4:	10 92 61 01 	sts	0x0161, r1
     da8:	10 92 62 01 	sts	0x0162, r1
     dac:	10 92 63 01 	sts	0x0163, r1
			default:
			return -1.0;
				break;
		}
	return 0;
}
     db0:	2e 2f       	mov	r18, r30
     db2:	37 2f       	mov	r19, r23
     db4:	48 2f       	mov	r20, r24
     db6:	56 2f       	mov	r21, r22
     db8:	b9 01       	movw	r22, r18
     dba:	ca 01       	movw	r24, r20
     dbc:	1f 91       	pop	r17
     dbe:	0f 91       	pop	r16
     dc0:	ff 90       	pop	r15
     dc2:	ef 90       	pop	r14
     dc4:	df 90       	pop	r13
     dc6:	cf 90       	pop	r12
     dc8:	bf 90       	pop	r11
     dca:	af 90       	pop	r10
     dcc:	08 95       	ret

00000dce <SetDOTChannel>:

inline void SetDOTChannel(int dotIndex)
{
	FREQ_CONTROL_PORT &= ~(3 << FREQ_CONTROL_PIN_S0);
     dce:	28 b1       	in	r18, 0x08	; 8
     dd0:	2f 7c       	andi	r18, 0xCF	; 207
     dd2:	28 b9       	out	0x08, r18	; 8
	FREQ_CONTROL_PORT |= dotIndex << FREQ_CONTROL_PIN_S0;
     dd4:	28 b1       	in	r18, 0x08	; 8
     dd6:	34 e0       	ldi	r19, 0x04	; 4
     dd8:	88 0f       	add	r24, r24
     dda:	99 1f       	adc	r25, r25
     ddc:	3a 95       	dec	r19
     dde:	e1 f7       	brne	.-8      	; 0xdd8 <SetDOTChannel+0xa>
     de0:	28 2b       	or	r18, r24
     de2:	28 b9       	out	0x08, r18	; 8
	else
	{
		sbi(FREQ_CONTROL_PORT, FREQ_CONTROL_PIN_S0);
		cbi(FREQ_CONTROL_PORT, FREQ_CONTROL_PIN_S1);
	}*/
}
     de4:	08 95       	ret

00000de6 <FrequancyMeasure>:

inline void FrequancyMeasure(void)
{
     de6:	af 92       	push	r10
     de8:	bf 92       	push	r11
     dea:	cf 92       	push	r12
     dec:	df 92       	push	r13
     dee:	ef 92       	push	r14
     df0:	ff 92       	push	r15
     df2:	0f 93       	push	r16
     df4:	1f 93       	push	r17
	double freq = 0;
	double generatorFrequency;
	static int dotIndex = 0;
	static int FreqState = 0;
	
	if(FreqState == 0)
     df6:	80 91 30 01 	lds	r24, 0x0130
     dfa:	90 91 31 01 	lds	r25, 0x0131
     dfe:	89 2b       	or	r24, r25
     e00:	f1 f4       	brne	.+60     	; 0xe3e <FrequancyMeasure+0x58>
	{
		
		dotIndex ++;
     e02:	80 91 32 01 	lds	r24, 0x0132
     e06:	90 91 33 01 	lds	r25, 0x0133
     e0a:	01 96       	adiw	r24, 0x01	; 1
		dotIndex &= 0x3;
     e0c:	83 70       	andi	r24, 0x03	; 3
     e0e:	90 70       	andi	r25, 0x00	; 0
     e10:	90 93 33 01 	sts	0x0133, r25
     e14:	80 93 32 01 	sts	0x0132, r24
	return 0;
}

inline void SetDOTChannel(int dotIndex)
{
	FREQ_CONTROL_PORT &= ~(3 << FREQ_CONTROL_PIN_S0);
     e18:	28 b1       	in	r18, 0x08	; 8
     e1a:	2f 7c       	andi	r18, 0xCF	; 207
     e1c:	28 b9       	out	0x08, r18	; 8
	FREQ_CONTROL_PORT |= dotIndex << FREQ_CONTROL_PIN_S0;
     e1e:	28 b1       	in	r18, 0x08	; 8
     e20:	44 e0       	ldi	r20, 0x04	; 4
     e22:	88 0f       	add	r24, r24
     e24:	99 1f       	adc	r25, r25
     e26:	4a 95       	dec	r20
     e28:	e1 f7       	brne	.-8      	; 0xe22 <FrequancyMeasure+0x3c>
     e2a:	28 2b       	or	r18, r24
     e2c:	28 b9       	out	0x08, r18	; 8
	{
		
		dotIndex ++;
		dotIndex &= 0x3;
		SetDOTChannel(dotIndex);
		FREQ_DOT.State = IDLE_FREQ_MEASURE;
     e2e:	10 92 5b 01 	sts	0x015B, r1
		FreqState++;
     e32:	81 e0       	ldi	r24, 0x01	; 1
     e34:	90 e0       	ldi	r25, 0x00	; 0
     e36:	90 93 31 01 	sts	0x0131, r25
     e3a:	80 93 30 01 	sts	0x0130, r24
	}

	if(FreqState == 1)
     e3e:	80 91 30 01 	lds	r24, 0x0130
     e42:	90 91 31 01 	lds	r25, 0x0131
     e46:	01 97       	sbiw	r24, 0x01	; 1
     e48:	99 f4       	brne	.+38     	; 0xe70 <FrequancyMeasure+0x8a>
	{
		if(CoreFrequancyMeasure() == -1.0)
     e4a:	0e 94 3b 06 	call	0xc76	; 0xc76 <CoreFrequancyMeasure>
     e4e:	20 e0       	ldi	r18, 0x00	; 0
     e50:	30 e0       	ldi	r19, 0x00	; 0
     e52:	40 e8       	ldi	r20, 0x80	; 128
     e54:	5f eb       	ldi	r21, 0xBF	; 191
     e56:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__cmpsf2>
     e5a:	88 23       	and	r24, r24
     e5c:	09 f4       	brne	.+2      	; 0xe60 <FrequancyMeasure+0x7a>
     e5e:	7d c0       	rjmp	.+250    	; 0xf5a <FrequancyMeasure+0x174>
			return;
		FreqState++;
     e60:	82 e0       	ldi	r24, 0x02	; 2
     e62:	90 e0       	ldi	r25, 0x00	; 0
     e64:	90 93 31 01 	sts	0x0131, r25
     e68:	80 93 30 01 	sts	0x0130, r24
		FREQ_DOT.State = IDLE_FREQ_MEASURE;
     e6c:	10 92 5b 01 	sts	0x015B, r1
	}

	if(FreqState == 2)
     e70:	80 91 30 01 	lds	r24, 0x0130
     e74:	90 91 31 01 	lds	r25, 0x0131
     e78:	02 97       	sbiw	r24, 0x02	; 2
     e7a:	59 f0       	breq	.+22     	; 0xe92 <FrequancyMeasure+0xac>
     e7c:	0f 2e       	mov	r0, r31
     e7e:	f0 e0       	ldi	r31, 0x00	; 0
     e80:	ef 2e       	mov	r14, r31
     e82:	f0 e0       	ldi	r31, 0x00	; 0
     e84:	ff 2e       	mov	r15, r31
     e86:	f0 e0       	ldi	r31, 0x00	; 0
     e88:	0f 2f       	mov	r16, r31
     e8a:	f0 e0       	ldi	r31, 0x00	; 0
     e8c:	1f 2f       	mov	r17, r31
     e8e:	f0 2d       	mov	r31, r0
     e90:	11 c0       	rjmp	.+34     	; 0xeb4 <FrequancyMeasure+0xce>
	{
	
		freq = CoreFrequancyMeasure();
     e92:	0e 94 3b 06 	call	0xc76	; 0xc76 <CoreFrequancyMeasure>
     e96:	7b 01       	movw	r14, r22
     e98:	8c 01       	movw	r16, r24
		if(freq == -1.0)
     e9a:	20 e0       	ldi	r18, 0x00	; 0
     e9c:	30 e0       	ldi	r19, 0x00	; 0
     e9e:	40 e8       	ldi	r20, 0x80	; 128
     ea0:	5f eb       	ldi	r21, 0xBF	; 191
     ea2:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__cmpsf2>
     ea6:	88 23       	and	r24, r24
     ea8:	09 f4       	brne	.+2      	; 0xeac <FrequancyMeasure+0xc6>
     eaa:	57 c0       	rjmp	.+174    	; 0xf5a <FrequancyMeasure+0x174>
			return;
		FreqState = 0;
     eac:	10 92 31 01 	sts	0x0131, r1
     eb0:	10 92 30 01 	sts	0x0130, r1
	}

	generatorFrequency = Reverse4(RegFile.mb_struct.dot_info.DOT[dotIndex].frequency);
     eb4:	20 91 32 01 	lds	r18, 0x0132
     eb8:	30 91 33 01 	lds	r19, 0x0133
     ebc:	86 e5       	ldi	r24, 0x56	; 86
     ebe:	90 e0       	ldi	r25, 0x00	; 0
     ec0:	28 9f       	mul	r18, r24
     ec2:	f0 01       	movw	r30, r0
     ec4:	29 9f       	mul	r18, r25
     ec6:	f0 0d       	add	r31, r0
     ec8:	38 9f       	mul	r19, r24
     eca:	f0 0d       	add	r31, r0
     ecc:	11 24       	eor	r1, r1
     ece:	eb 58       	subi	r30, 0x8B	; 139
     ed0:	fd 4f       	sbci	r31, 0xFD	; 253
     ed2:	60 8d       	ldd	r22, Z+24	; 0x18
     ed4:	71 8d       	ldd	r23, Z+25	; 0x19
     ed6:	82 8d       	ldd	r24, Z+26	; 0x1a
     ed8:	93 8d       	ldd	r25, Z+27	; 0x1b
     eda:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <Reverse4>
     ede:	5b 01       	movw	r10, r22
     ee0:	6c 01       	movw	r12, r24
	if(generatorFrequency != 0)
     ee2:	20 e0       	ldi	r18, 0x00	; 0
     ee4:	30 e0       	ldi	r19, 0x00	; 0
     ee6:	40 e0       	ldi	r20, 0x00	; 0
     ee8:	50 e0       	ldi	r21, 0x00	; 0
     eea:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__cmpsf2>
     eee:	88 23       	and	r24, r24
     ef0:	29 f4       	brne	.+10     	; 0xefc <FrequancyMeasure+0x116>
     ef2:	ee 2d       	mov	r30, r14
     ef4:	7f 2d       	mov	r23, r15
     ef6:	80 2f       	mov	r24, r16
     ef8:	61 2f       	mov	r22, r17
     efa:	14 c0       	rjmp	.+40     	; 0xf24 <FrequancyMeasure+0x13e>
		generatorFrequency = generatorFrequency + 0.25 * (freq - generatorFrequency);
     efc:	c8 01       	movw	r24, r16
     efe:	b7 01       	movw	r22, r14
     f00:	a6 01       	movw	r20, r12
     f02:	95 01       	movw	r18, r10
     f04:	0e 94 10 1a 	call	0x3420	; 0x3420 <__subsf3>
     f08:	20 e0       	ldi	r18, 0x00	; 0
     f0a:	30 e0       	ldi	r19, 0x00	; 0
     f0c:	40 e8       	ldi	r20, 0x80	; 128
     f0e:	5e e3       	ldi	r21, 0x3E	; 62
     f10:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__mulsf3>
     f14:	9b 01       	movw	r18, r22
     f16:	ac 01       	movw	r20, r24
     f18:	c6 01       	movw	r24, r12
     f1a:	b5 01       	movw	r22, r10
     f1c:	0e 94 11 1a 	call	0x3422	; 0x3422 <__addsf3>
     f20:	e6 2f       	mov	r30, r22
     f22:	69 2f       	mov	r22, r25
	else
	generatorFrequency = freq;
	RegFile.mb_struct.dot_info.DOT[dotIndex].frequency = Reverse4(generatorFrequency);
     f24:	00 91 32 01 	lds	r16, 0x0132
     f28:	10 91 33 01 	lds	r17, 0x0133
     f2c:	2e 2f       	mov	r18, r30
     f2e:	37 2f       	mov	r19, r23
     f30:	48 2f       	mov	r20, r24
     f32:	56 2f       	mov	r21, r22
     f34:	b9 01       	movw	r22, r18
     f36:	ca 01       	movw	r24, r20
     f38:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <Reverse4>
     f3c:	26 e5       	ldi	r18, 0x56	; 86
     f3e:	30 e0       	ldi	r19, 0x00	; 0
     f40:	02 9f       	mul	r16, r18
     f42:	f0 01       	movw	r30, r0
     f44:	03 9f       	mul	r16, r19
     f46:	f0 0d       	add	r31, r0
     f48:	12 9f       	mul	r17, r18
     f4a:	f0 0d       	add	r31, r0
     f4c:	11 24       	eor	r1, r1
     f4e:	eb 58       	subi	r30, 0x8B	; 139
     f50:	fd 4f       	sbci	r31, 0xFD	; 253
     f52:	60 8f       	std	Z+24, r22	; 0x18
     f54:	71 8f       	std	Z+25, r23	; 0x19
     f56:	82 8f       	std	Z+26, r24	; 0x1a
     f58:	93 8f       	std	Z+27, r25	; 0x1b
}
     f5a:	1f 91       	pop	r17
     f5c:	0f 91       	pop	r16
     f5e:	ff 90       	pop	r15
     f60:	ef 90       	pop	r14
     f62:	df 90       	pop	r13
     f64:	cf 90       	pop	r12
     f66:	bf 90       	pop	r11
     f68:	af 90       	pop	r10
     f6a:	08 95       	ret

00000f6c <FreqDotInit>:
}

#ifdef FREQUENCY_INPUT

inline void FreqDotInit()
{
     f6c:	0f 93       	push	r16
     f6e:	1f 93       	push	r17
	double generatorFrequency;
	unsigned short dotIndex;
	unsigned short dotCount = Reverse2(RegFile.mb_struct.dot_info.N);
     f70:	80 91 89 02 	lds	r24, 0x0289
     f74:	90 91 8a 02 	lds	r25, 0x028A
     f78:	0e 94 f4 0f 	call	0x1fe8	; 0x1fe8 <Reverse2>
     f7c:	8c 01       	movw	r16, r24
	
	generatorFrequency = 0.0;
	generatorFrequency = Reverse4(generatorFrequency);	
     f7e:	60 e0       	ldi	r22, 0x00	; 0
     f80:	70 e0       	ldi	r23, 0x00	; 0
     f82:	80 e0       	ldi	r24, 0x00	; 0
     f84:	90 e0       	ldi	r25, 0x00	; 0
     f86:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <Reverse4>
     f8a:	ab 01       	movw	r20, r22
     f8c:	bc 01       	movw	r22, r24
     f8e:	ed e8       	ldi	r30, 0x8D	; 141
     f90:	f2 e0       	ldi	r31, 0x02	; 2
    for (dotIndex = 0; dotIndex < dotCount; dotIndex ++)
     f92:	86 e5       	ldi	r24, 0x56	; 86
     f94:	90 e0       	ldi	r25, 0x00	; 0
     f96:	08 9f       	mul	r16, r24
     f98:	90 01       	movw	r18, r0
     f9a:	09 9f       	mul	r16, r25
     f9c:	30 0d       	add	r19, r0
     f9e:	18 9f       	mul	r17, r24
     fa0:	30 0d       	add	r19, r0
     fa2:	11 24       	eor	r1, r1
     fa4:	2e 0f       	add	r18, r30
     fa6:	3f 1f       	adc	r19, r31
     fa8:	06 c0       	rjmp	.+12     	; 0xfb6 <FreqDotInit+0x4a>
    {
        RegFile.mb_struct.dot_info.DOT[dotIndex].frequency = generatorFrequency;     
     faa:	40 83       	st	Z, r20
     fac:	51 83       	std	Z+1, r21	; 0x01
     fae:	62 83       	std	Z+2, r22	; 0x02
     fb0:	73 83       	std	Z+3, r23	; 0x03
     fb2:	ea 5a       	subi	r30, 0xAA	; 170
     fb4:	ff 4f       	sbci	r31, 0xFF	; 255
	unsigned short dotIndex;
	unsigned short dotCount = Reverse2(RegFile.mb_struct.dot_info.N);
	
	generatorFrequency = 0.0;
	generatorFrequency = Reverse4(generatorFrequency);	
    for (dotIndex = 0; dotIndex < dotCount; dotIndex ++)
     fb6:	e2 17       	cp	r30, r18
     fb8:	f3 07       	cpc	r31, r19
     fba:	b9 f7       	brne	.-18     	; 0xfaa <FreqDotInit+0x3e>
    {
        RegFile.mb_struct.dot_info.DOT[dotIndex].frequency = generatorFrequency;     
    }
  
    cbi(FREQ_DDR, FREQ_PIN);
     fbc:	20 98       	cbi	0x04, 0	; 4
	sbi(FREQ_CONTROL_DDR, FREQ_CONTROL_PIN_S0);
     fbe:	3c 9a       	sbi	0x07, 4	; 7
	sbi(FREQ_CONTROL_DDR, FREQ_CONTROL_PIN_S1);
     fc0:	3d 9a       	sbi	0x07, 5	; 7

	sbi(TIMSK1, ICIE1);
     fc2:	80 91 6f 00 	lds	r24, 0x006F
     fc6:	80 62       	ori	r24, 0x20	; 32
     fc8:	80 93 6f 00 	sts	0x006F, r24
}
     fcc:	1f 91       	pop	r17
     fce:	0f 91       	pop	r16
     fd0:	08 95       	ret

00000fd2 <__vector_13>:
											// »змен€етс€ по фронтуи срезу поступающего сигнала на микроконтроллер.
											// ѕоэтому переменна€ freq содержит удвоенное число подсчитанных импульсов
volatile FREQ_REGISTR   FREQ_DOT;

SIGNAL(SIG_OVERFLOW1)
{
     fd2:	1f 92       	push	r1
     fd4:	0f 92       	push	r0
     fd6:	0f b6       	in	r0, 0x3f	; 63
     fd8:	0f 92       	push	r0
     fda:	11 24       	eor	r1, r1
     fdc:	2f 93       	push	r18
     fde:	3f 93       	push	r19
     fe0:	4f 93       	push	r20
     fe2:	5f 93       	push	r21
     fe4:	6f 93       	push	r22
     fe6:	7f 93       	push	r23
     fe8:	8f 93       	push	r24
     fea:	9f 93       	push	r25
     fec:	af 93       	push	r26
     fee:	bf 93       	push	r27
     ff0:	ef 93       	push	r30
     ff2:	ff 93       	push	r31
	switch(FREQ_DOT.State)
     ff4:	80 91 5b 01 	lds	r24, 0x015B
     ff8:	81 30       	cpi	r24, 0x01	; 1
     ffa:	29 f0       	breq	.+10     	; 0x1006 <__vector_13+0x34>
     ffc:	81 30       	cpi	r24, 0x01	; 1
     ffe:	f0 f0       	brcs	.+60     	; 0x103c <__vector_13+0x6a>
    1000:	82 30       	cpi	r24, 0x02	; 2
    1002:	f9 f4       	brne	.+62     	; 0x1042 <__vector_13+0x70>
    1004:	0a c0       	rjmp	.+20     	; 0x101a <__vector_13+0x48>
	{
		case START_FREQ_MEASURE:
				FREQ_DOT.Count_Timer = 0;
    1006:	10 92 58 01 	sts	0x0158, r1
    100a:	10 92 57 01 	sts	0x0157, r1
				FREQ_DOT.Count_Capture = 0;
    100e:	10 92 5a 01 	sts	0x015A, r1
    1012:	10 92 59 01 	sts	0x0159, r1
				FREQ_DOT.State = FREQ_MEASURE;
    1016:	82 e0       	ldi	r24, 0x02	; 2
    1018:	12 c0       	rjmp	.+36     	; 0x103e <__vector_13+0x6c>
			break;
		case FREQ_MEASURE:
				FREQ_DOT.Count_Timer++;
    101a:	80 91 57 01 	lds	r24, 0x0157
    101e:	90 91 58 01 	lds	r25, 0x0158
    1022:	01 96       	adiw	r24, 0x01	; 1
    1024:	90 93 58 01 	sts	0x0158, r25
    1028:	80 93 57 01 	sts	0x0157, r24
				if(FREQ_DOT.Count_Timer >= N_Period_Measure)
    102c:	80 91 57 01 	lds	r24, 0x0157
    1030:	90 91 58 01 	lds	r25, 0x0158
    1034:	44 97       	sbiw	r24, 0x14	; 20
    1036:	28 f0       	brcs	.+10     	; 0x1042 <__vector_13+0x70>
				{
					FREQ_DOT.State = FREQ_REDY_MEASURE;
    1038:	83 e0       	ldi	r24, 0x03	; 3
    103a:	01 c0       	rjmp	.+2      	; 0x103e <__vector_13+0x6c>
				}
			break;
		case IDLE_FREQ_MEASURE: FREQ_DOT.State = START_FREQ_MEASURE;
    103c:	81 e0       	ldi	r24, 0x01	; 1
    103e:	80 93 5b 01 	sts	0x015B, r24
			break;

	}
	error_led_isr();
    1042:	0e 94 f3 0c 	call	0x19e6	; 0x19e6 <error_led_isr>
}
    1046:	ff 91       	pop	r31
    1048:	ef 91       	pop	r30
    104a:	bf 91       	pop	r27
    104c:	af 91       	pop	r26
    104e:	9f 91       	pop	r25
    1050:	8f 91       	pop	r24
    1052:	7f 91       	pop	r23
    1054:	6f 91       	pop	r22
    1056:	5f 91       	pop	r21
    1058:	4f 91       	pop	r20
    105a:	3f 91       	pop	r19
    105c:	2f 91       	pop	r18
    105e:	0f 90       	pop	r0
    1060:	0f be       	out	0x3f, r0	; 63
    1062:	0f 90       	pop	r0
    1064:	1f 90       	pop	r1
    1066:	18 95       	reti

00001068 <MBClientReceive0>:
}


inline byte MBClientReceive0(void)
{
    return UartRecivePacket();
    1068:	0e 94 ee 0b 	call	0x17dc	; 0x17dc <UartRecivePacket>
}
    106c:	08 95       	ret

0000106e <MBSend>:
		return CRC_ERROR; //≈сли нет - вернуть ошибку
	return 0;
}

__MBCL_SEND__ void MBSend(unsigned char clientID, unsigned char size)
{
    106e:	ff 92       	push	r15
    1070:	0f 93       	push	r16
    1072:	cf 93       	push	r28
    1074:	df 93       	push	r29
    1076:	f8 2e       	mov	r15, r24
    1078:	06 2f       	mov	r16, r22
	unsigned int crc;

	if(size > 252)
    107a:	6d 3f       	cpi	r22, 0xFD	; 253
    107c:	90 f0       	brcs	.+36     	; 0x10a2 <MBSend+0x34>
	{
		CPT0[SLAVE_EXSEPT_ERR_CNTR].i++;		//нарастить соотв. каунтер
    107e:	80 91 6a 01 	lds	r24, 0x016A
    1082:	90 91 6b 01 	lds	r25, 0x016B
    1086:	01 96       	adiw	r24, 0x01	; 1
    1088:	90 93 6b 01 	sts	0x016B, r25
    108c:	80 93 6a 01 	sts	0x016A, r24
		DataBuffer0[1] |= MOD_ERROR_CODE_FLAG;	//  номеру ф-ции логически прибавить значение ошибки (0x80)
    1090:	80 91 78 01 	lds	r24, 0x0178
    1094:	80 68       	ori	r24, 0x80	; 128
    1096:	80 93 78 01 	sts	0x0178, r24
		DataBuffer0[2] = ILLEGAL_DATA_VALUE;			//записать код исключени€
    109a:	83 e0       	ldi	r24, 0x03	; 3
    109c:	80 93 79 01 	sts	0x0179, r24
    10a0:	02 e0       	ldi	r16, 0x02	; 2
		size = 2;
	}
	SET_DE485_0();
    10a2:	0e 94 9b 0b 	call	0x1736	; 0x1736 <SET_DE485_0>
	DataBuffer0[0] = clientID;	//первый эл-т буфера - номер хоста
    10a6:	c7 e7       	ldi	r28, 0x77	; 119
    10a8:	d1 e0       	ldi	r29, 0x01	; 1
    10aa:	f0 92 77 01 	sts	0x0177, r15
	//дописываем CRC
	crc=CRC16(DataBuffer0, size + 1, 0xFFFF);
    10ae:	60 2f       	mov	r22, r16
    10b0:	6f 5f       	subi	r22, 0xFF	; 255
    10b2:	ce 01       	movw	r24, r28
    10b4:	4f ef       	ldi	r20, 0xFF	; 255
    10b6:	5f ef       	ldi	r21, 0xFF	; 255
    10b8:	0e 94 80 0b 	call	0x1700	; 0x1700 <CRC16>
	DataBuffer0[size + 1]=(unsigned char)(crc & 0xFF);
    10bc:	e0 2f       	mov	r30, r16
    10be:	f0 e0       	ldi	r31, 0x00	; 0
    10c0:	ec 0f       	add	r30, r28
    10c2:	fd 1f       	adc	r31, r29
    10c4:	81 83       	std	Z+1, r24	; 0x01
	DataBuffer0[size + 2]=(unsigned char)(crc >> 8);
    10c6:	92 83       	std	Z+2, r25	; 0x02
	//Ќастраиваем указатель(используетс€ в обработчике прерывани€ UART) на буфер 
	pBuf0=DataBuffer0;
    10c8:	d0 93 72 02 	sts	0x0272, r29
    10cc:	c0 93 71 02 	sts	0x0271, r28
	BufferSize0=size + 3;		//размер посылаемого пакета размер данных+1(адрес)+2(CRC)
    10d0:	0d 5f       	subi	r16, 0xFD	; 253
    10d2:	00 93 34 01 	sts	0x0134, r16
	UCR0 |= (1 << UDRIE0);		//разрешение прерывани€
    10d6:	e0 91 73 02 	lds	r30, 0x0273
    10da:	f0 91 74 02 	lds	r31, 0x0274
    10de:	35 97       	sbiw	r30, 0x05	; 5
    10e0:	80 81       	ld	r24, Z
    10e2:	80 62       	ori	r24, 0x20	; 32
    10e4:	80 83       	st	Z, r24
	while (!(UCSR0B & (1 << RXEN0)));			//пока не очиститс€ буфер.
    10e6:	80 91 c1 00 	lds	r24, 0x00C1
    10ea:	84 ff       	sbrs	r24, 4
    10ec:	fc cf       	rjmp	.-8      	; 0x10e6 <MBSend+0x78>
	state0 = State_INITIAL; //”становить состо€ние инициализации
    10ee:	10 92 35 01 	sts	0x0135, r1
}
    10f2:	df 91       	pop	r29
    10f4:	cf 91       	pop	r28
    10f6:	0f 91       	pop	r16
    10f8:	ff 90       	pop	r15
    10fa:	08 95       	ret

000010fc <MBClientSend>:

inline void MBClientSend(unsigned char size)
{
    10fc:	68 2f       	mov	r22, r24
    MBSend(MBClientGetHostID0(), size);
    10fe:	80 91 00 01 	lds	r24, 0x0100
    1102:	0e 94 37 08 	call	0x106e	; 0x106e <MBSend>
}
    1106:	08 95       	ret

00001108 <SendErrorResponse>:
__ID__ byte hostID0 = 99;

// ѕосылка сообщени€ об ошибке
__SEND_ERROR__ void SendErrorResponse(byte ExceptionCode)
{
	CPT0[SLAVE_EXSEPT_ERR_CNTR].i++;		//нарастить соотв. каунтер
    1108:	20 91 6a 01 	lds	r18, 0x016A
    110c:	30 91 6b 01 	lds	r19, 0x016B
    1110:	2f 5f       	subi	r18, 0xFF	; 255
    1112:	3f 4f       	sbci	r19, 0xFF	; 255
    1114:	30 93 6b 01 	sts	0x016B, r19
    1118:	20 93 6a 01 	sts	0x016A, r18
	DataBuffer0[1] |= MOD_ERROR_CODE_FLAG;	//  номеру ф-ции логически прибавить значение ошибки (0x80)
    111c:	90 91 78 01 	lds	r25, 0x0178
    1120:	90 68       	ori	r25, 0x80	; 128
    1122:	90 93 78 01 	sts	0x0178, r25
	DataBuffer0[2] = ExceptionCode;			//записать код исключени€
    1126:	80 93 79 01 	sts	0x0179, r24
	MBClientSend(2);			//послать
    112a:	82 e0       	ldi	r24, 0x02	; 2
    112c:	0e 94 7e 08 	call	0x10fc	; 0x10fc <MBClientSend>
}
    1130:	08 95       	ret

00001132 <DiagnosticModbus0>:

// ќбработка ф-ции 0x08 - диагностика
__DIAGNOSTIC__ void DiagnosticModbus0(byte *buffer,byte Size)
{
    1132:	dc 01       	movw	r26, r24
	byte i;
	//≈сли код подф-ции возвращени€ какого-то счЄтчика
	if ((buffer[2] >= BUS_MESSAGE_COUNT) && (buffer[2] <= BUS_CHARRACTER_OVERRUN_COUNT))
    1134:	12 96       	adiw	r26, 0x02	; 2
    1136:	ec 91       	ld	r30, X
    1138:	12 97       	sbiw	r26, 0x02	; 2
    113a:	8e 2f       	mov	r24, r30
    113c:	8b 50       	subi	r24, 0x0B	; 11
    113e:	88 30       	cpi	r24, 0x08	; 8
    1140:	b0 f4       	brcc	.+44     	; 0x116e <DiagnosticModbus0+0x3c>
	{
		buffer[3] = CPT0[buffer[2] - 0x0A].b[1];	//вычисл€ем и возвращаем этот счЄтчик
    1142:	f0 e0       	ldi	r31, 0x00	; 0
    1144:	ee 0f       	add	r30, r30
    1146:	ff 1f       	adc	r31, r31
    1148:	e0 5b       	subi	r30, 0xB0	; 176
    114a:	fe 4f       	sbci	r31, 0xFE	; 254
    114c:	81 81       	ldd	r24, Z+1	; 0x01
    114e:	13 96       	adiw	r26, 0x03	; 3
    1150:	8c 93       	st	X, r24
    1152:	13 97       	sbiw	r26, 0x03	; 3
		buffer[4] = CPT0[buffer[2] - 0x0A].b[0];
    1154:	12 96       	adiw	r26, 0x02	; 2
    1156:	ec 91       	ld	r30, X
    1158:	12 97       	sbiw	r26, 0x02	; 2
    115a:	f0 e0       	ldi	r31, 0x00	; 0
    115c:	ee 0f       	add	r30, r30
    115e:	ff 1f       	adc	r31, r31
    1160:	e0 5b       	subi	r30, 0xB0	; 176
    1162:	fe 4f       	sbci	r31, 0xFE	; 254
    1164:	80 81       	ld	r24, Z
    1166:	14 96       	adiw	r26, 0x04	; 4
    1168:	8c 93       	st	X, r24
		Size = 5;								//установка размера сообщени€
		MBClientSend(Size);				//послать
    116a:	85 e0       	ldi	r24, 0x05	; 5
    116c:	12 c0       	rjmp	.+36     	; 0x1192 <DiagnosticModbus0+0x60>
		return;
	}
	switch(buffer[2])
    116e:	ee 23       	and	r30, r30
    1170:	79 f0       	breq	.+30     	; 0x1190 <DiagnosticModbus0+0x5e>
    1172:	ea 30       	cpi	r30, 0x0A	; 10
    1174:	49 f4       	brne	.+18     	; 0x1188 <DiagnosticModbus0+0x56>
    1176:	e6 e6       	ldi	r30, 0x66	; 102
    1178:	f1 e0       	ldi	r31, 0x01	; 1
	{
		case CLEAR_COUNTERS:					//подф-ци€ очистки счЄтчиков
			for(i = 1;i < 9;i++)				//собственно очищаем
				CPT0[i].i = 0;
    117a:	11 92       	st	Z+, r1
    117c:	11 92       	st	Z+, r1
		return;
	}
	switch(buffer[2])
	{
		case CLEAR_COUNTERS:					//подф-ци€ очистки счЄтчиков
			for(i = 1;i < 9;i++)				//собственно очищаем
    117e:	81 e0       	ldi	r24, 0x01	; 1
    1180:	e6 37       	cpi	r30, 0x76	; 118
    1182:	f8 07       	cpc	r31, r24
    1184:	d1 f7       	brne	.-12     	; 0x117a <DiagnosticModbus0+0x48>
    1186:	04 c0       	rjmp	.+8      	; 0x1190 <DiagnosticModbus0+0x5e>
				CPT0[i].i = 0;
			break;
		case RETURN_QUERY_DATA:					//подф-ци€ Ё’ќ
			break;								//ничего не делаем
		default:										//подф-ци€ неизвестна 
			SendErrorResponse(ILLEGAL_FUNCTION);	//ѕослать соответствующее исключение
    1188:	81 e0       	ldi	r24, 0x01	; 1
    118a:	0e 94 84 08 	call	0x1108	; 0x1108 <SendErrorResponse>
    118e:	08 95       	ret
			return;
	}
	MBClientSend(Size);//послать
    1190:	86 2f       	mov	r24, r22
    1192:	0e 94 7e 08 	call	0x10fc	; 0x10fc <MBClientSend>
    1196:	08 95       	ret

00001198 <CheckCRC0>:
}

byte CheckCRC0(void)
{
	//ѕровер€ем, совпадает ли пришедшее CRC с вычисленным
	if (CRC16(DataBuffer0, BufferSize0 - 2, 0xFFFF) != *(unsigned int *)(DataBuffer0 + BufferSize0 - 2))
    1198:	60 91 34 01 	lds	r22, 0x0134
    119c:	62 50       	subi	r22, 0x02	; 2
    119e:	87 e7       	ldi	r24, 0x77	; 119
    11a0:	91 e0       	ldi	r25, 0x01	; 1
    11a2:	4f ef       	ldi	r20, 0xFF	; 255
    11a4:	5f ef       	ldi	r21, 0xFF	; 255
    11a6:	0e 94 80 0b 	call	0x1700	; 0x1700 <CRC16>
    11aa:	e0 91 34 01 	lds	r30, 0x0134
    11ae:	f0 e0       	ldi	r31, 0x00	; 0
    11b0:	eb 58       	subi	r30, 0x8B	; 139
    11b2:	fe 4f       	sbci	r31, 0xFE	; 254
    11b4:	20 81       	ld	r18, Z
    11b6:	31 81       	ldd	r19, Z+1	; 0x01
    11b8:	82 17       	cp	r24, r18
    11ba:	93 07       	cpc	r25, r19
    11bc:	11 f4       	brne	.+4      	; 0x11c2 <CheckCRC0+0x2a>
    11be:	80 e0       	ldi	r24, 0x00	; 0
    11c0:	08 95       	ret
    11c2:	83 e0       	ldi	r24, 0x03	; 3
		return CRC_ERROR; //≈сли нет - вернуть ошибку
	return 0;
}
    11c4:	08 95       	ret

000011c6 <check_modbus_packet>:
}


// проверка на точ то прин€тый пакет - целый (не битый) пакет модбас
byte check_modbus_packet(unsigned char clientID)
{
    11c6:	1f 93       	push	r17
    11c8:	18 2f       	mov	r17, r24
	//контроль размера полученных данных
	if (!((BufferSize0 < 4) || (BufferSize0 > MBCLIENT_MAX_LENGHT)))
    11ca:	80 91 34 01 	lds	r24, 0x0134
    11ce:	84 30       	cpi	r24, 0x04	; 4
    11d0:	20 f1       	brcs	.+72     	; 0x121a <check_modbus_packet+0x54>
    11d2:	80 91 34 01 	lds	r24, 0x0134
    11d6:	8b 3f       	cpi	r24, 0xFB	; 251
    11d8:	00 f5       	brcc	.+64     	; 0x121a <check_modbus_packet+0x54>
	{
		//провер€ем CRC
		if(!CheckCRC0())
    11da:	0e 94 cc 08 	call	0x1198	; 0x1198 <CheckCRC0>
    11de:	88 23       	and	r24, r24
    11e0:	e1 f4       	brne	.+56     	; 0x121a <check_modbus_packet+0x54>
		{
			CPT0[BUS_MSG_CNTR].i++;
    11e2:	80 91 66 01 	lds	r24, 0x0166
    11e6:	90 91 67 01 	lds	r25, 0x0167
    11ea:	01 96       	adiw	r24, 0x01	; 1
    11ec:	90 93 67 01 	sts	0x0167, r25
    11f0:	80 93 66 01 	sts	0x0166, r24
			//провер€ем, нам ли предназначен пакет
			if ((DataBuffer0[0] == 0) || (DataBuffer0[0] == clientID))		
    11f4:	80 91 77 01 	lds	r24, 0x0177
    11f8:	88 23       	and	r24, r24
    11fa:	11 f0       	breq	.+4      	; 0x1200 <check_modbus_packet+0x3a>
    11fc:	81 17       	cp	r24, r17
    11fe:	b1 f4       	brne	.+44     	; 0x122c <check_modbus_packet+0x66>
			{
				//если всЄ правильно возвращаем длину	        
				CPT0[SLAVE_MSG_CNTR].i++;
    1200:	80 91 6c 01 	lds	r24, 0x016C
    1204:	90 91 6d 01 	lds	r25, 0x016D
    1208:	01 96       	adiw	r24, 0x01	; 1
    120a:	90 93 6d 01 	sts	0x016D, r25
    120e:	80 93 6c 01 	sts	0x016C, r24
				return (BufferSize0 - 3);
    1212:	80 91 34 01 	lds	r24, 0x0134
    1216:	83 50       	subi	r24, 0x03	; 3
    1218:	0a c0       	rjmp	.+20     	; 0x122e <check_modbus_packet+0x68>
		}
		else
			{CPT0[BUS_COM_ERR_CNTR].i++;}
	}
	else
	{CPT0[BUS_COM_ERR_CNTR].i++;}
    121a:	80 91 68 01 	lds	r24, 0x0168
    121e:	90 91 69 01 	lds	r25, 0x0169
    1222:	01 96       	adiw	r24, 0x01	; 1
    1224:	90 93 69 01 	sts	0x0169, r25
    1228:	80 93 68 01 	sts	0x0168, r24
    122c:	80 e0       	ldi	r24, 0x00	; 0
	
	return 0;
}
    122e:	1f 91       	pop	r17
    1230:	08 95       	ret

00001232 <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    1232:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    1234:	f9 99       	sbic	0x1f, 1	; 31
    1236:	fe cf       	rjmp	.-4      	; 0x1234 <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    1238:	32 bd       	out	0x22, r19	; 34
    123a:	21 bd       	out	0x21, r18	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    123c:	f8 9a       	sbi	0x1f, 0	; 31
    123e:	80 b5       	in	r24, 0x20	; 32
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
    1240:	08 95       	ret

00001242 <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    1242:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    1244:	f9 99       	sbic	0x1f, 1	; 31
    1246:	fe cf       	rjmp	.-4      	; 0x1244 <eeprom_write_byte+0x2>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    1248:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    124a:	32 bd       	out	0x22, r19	; 34
    124c:	21 bd       	out	0x21, r18	; 33
#endif
    EEDR = __value;
    124e:	60 bd       	out	0x20, r22	; 32

    __asm__ __volatile__ (
    1250:	0f b6       	in	r0, 0x3f	; 63
    1252:	f8 94       	cli
    1254:	fa 9a       	sbi	0x1f, 2	; 31
    1256:	f9 9a       	sbi	0x1f, 1	; 31
    1258:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
    125a:	08 95       	ret

0000125c <WriteFlash>:
			SendErrorResponse(ILLEGAL_DATA_ADRESS);
		 }
}

void WriteFlash(MEMORY_OPERATE *buffer)
{
    125c:	fc 01       	movw	r30, r24
	if(buffer->adress > MAX_BOOT_PAGE * SPM_PAGESIZE)
    125e:	62 81       	ldd	r22, Z+2	; 0x02
    1260:	73 81       	ldd	r23, Z+3	; 0x03
    1262:	84 81       	ldd	r24, Z+4	; 0x04
    1264:	95 81       	ldd	r25, Z+5	; 0x05
    1266:	61 38       	cpi	r22, 0x81	; 129
    1268:	22 e4       	ldi	r18, 0x42	; 66
    126a:	72 07       	cpc	r23, r18
    126c:	20 e0       	ldi	r18, 0x00	; 0
    126e:	82 07       	cpc	r24, r18
    1270:	20 e0       	ldi	r18, 0x00	; 0
    1272:	92 07       	cpc	r25, r18
    1274:	20 f0       	brcs	.+8      	; 0x127e <WriteFlash+0x22>
	{
		SendErrorResponse(ILLEGAL_DATA_ADRESS);
    1276:	82 e0       	ldi	r24, 0x02	; 2
    1278:	0e 94 84 08 	call	0x1108	; 0x1108 <SendErrorResponse>
    127c:	08 95       	ret
		return;
	}
	boot_program_page(buffer->adress, buffer->data, buffer->count);		
    127e:	af 01       	movw	r20, r30
    1280:	49 5f       	subi	r20, 0xF9	; 249
    1282:	5f 4f       	sbci	r21, 0xFF	; 255
    1284:	26 81       	ldd	r18, Z+6	; 0x06
    1286:	0e 94 b0 1c 	call	0x3960	; 0x3960 <boot_program_page>

	MBClientSend(7);
    128a:	87 e0       	ldi	r24, 0x07	; 7
    128c:	0e 94 7e 08 	call	0x10fc	; 0x10fc <MBClientSend>
    1290:	08 95       	ret

00001292 <modWriteOption>:
	//ѕосылаем прочитанное
	MBClientSend(p->count + 7);			
}

void modWriteOption(WRITE_OPTION *buffer)
{
    1292:	df 93       	push	r29
    1294:	cf 93       	push	r28
    1296:	00 d0       	rcall	.+0      	; 0x1298 <modWriteOption+0x6>
    1298:	00 d0       	rcall	.+0      	; 0x129a <modWriteOption+0x8>
    129a:	cd b7       	in	r28, 0x3d	; 61
    129c:	de b7       	in	r29, 0x3e	; 62
    129e:	9c 01       	movw	r18, r24
	unsigned long temp_Value0;

	*((unsigned char *)&temp_Value0    ) = *((unsigned char *)&buffer->boudrate0 + 3);
    12a0:	de 01       	movw	r26, r28
    12a2:	11 96       	adiw	r26, 0x01	; 1
    12a4:	fc 01       	movw	r30, r24
    12a6:	34 96       	adiw	r30, 0x04	; 4
    12a8:	83 81       	ldd	r24, Z+3	; 0x03
    12aa:	89 83       	std	Y+1, r24	; 0x01
	*((unsigned char *)&temp_Value0 + 1) = *((unsigned char *)&buffer->boudrate0 + 2);
    12ac:	82 81       	ldd	r24, Z+2	; 0x02
    12ae:	11 96       	adiw	r26, 0x01	; 1
    12b0:	8c 93       	st	X, r24
    12b2:	11 97       	sbiw	r26, 0x01	; 1
	*((unsigned char *)&temp_Value0 + 2) = *((unsigned char *)&buffer->boudrate0 + 1);
    12b4:	81 81       	ldd	r24, Z+1	; 0x01
    12b6:	12 96       	adiw	r26, 0x02	; 2
    12b8:	8c 93       	st	X, r24
    12ba:	12 97       	sbiw	r26, 0x02	; 2
	*((unsigned char *)&temp_Value0 + 3) = *((unsigned char *)&buffer->boudrate0    );
    12bc:	f9 01       	movw	r30, r18
    12be:	84 81       	ldd	r24, Z+4	; 0x04
    12c0:	13 96       	adiw	r26, 0x03	; 3
    12c2:	8c 93       	st	X, r24
	switch(temp_Value0)
    12c4:	89 81       	ldd	r24, Y+1	; 0x01
    12c6:	9a 81       	ldd	r25, Y+2	; 0x02
    12c8:	ab 81       	ldd	r26, Y+3	; 0x03
    12ca:	bc 81       	ldd	r27, Y+4	; 0x04
    12cc:	80 30       	cpi	r24, 0x00	; 0
    12ce:	fb e4       	ldi	r31, 0x4B	; 75
    12d0:	9f 07       	cpc	r25, r31
    12d2:	f0 e0       	ldi	r31, 0x00	; 0
    12d4:	af 07       	cpc	r26, r31
    12d6:	f0 e0       	ldi	r31, 0x00	; 0
    12d8:	bf 07       	cpc	r27, r31
    12da:	09 f4       	brne	.+2      	; 0x12de <modWriteOption+0x4c>
    12dc:	5b c0       	rjmp	.+182    	; 0x1394 <modWriteOption+0x102>
    12de:	81 30       	cpi	r24, 0x01	; 1
    12e0:	4b e4       	ldi	r20, 0x4B	; 75
    12e2:	94 07       	cpc	r25, r20
    12e4:	40 e0       	ldi	r20, 0x00	; 0
    12e6:	a4 07       	cpc	r26, r20
    12e8:	40 e0       	ldi	r20, 0x00	; 0
    12ea:	b4 07       	cpc	r27, r20
    12ec:	38 f5       	brcc	.+78     	; 0x133c <modWriteOption+0xaa>
    12ee:	80 3c       	cpi	r24, 0xC0	; 192
    12f0:	e2 e1       	ldi	r30, 0x12	; 18
    12f2:	9e 07       	cpc	r25, r30
    12f4:	e0 e0       	ldi	r30, 0x00	; 0
    12f6:	ae 07       	cpc	r26, r30
    12f8:	e0 e0       	ldi	r30, 0x00	; 0
    12fa:	be 07       	cpc	r27, r30
    12fc:	09 f4       	brne	.+2      	; 0x1300 <modWriteOption+0x6e>
    12fe:	4a c0       	rjmp	.+148    	; 0x1394 <modWriteOption+0x102>
    1300:	81 3c       	cpi	r24, 0xC1	; 193
    1302:	f2 e1       	ldi	r31, 0x12	; 18
    1304:	9f 07       	cpc	r25, r31
    1306:	f0 e0       	ldi	r31, 0x00	; 0
    1308:	af 07       	cpc	r26, r31
    130a:	f0 e0       	ldi	r31, 0x00	; 0
    130c:	bf 07       	cpc	r27, r31
    130e:	38 f4       	brcc	.+14     	; 0x131e <modWriteOption+0x8c>
    1310:	80 56       	subi	r24, 0x60	; 96
    1312:	99 40       	sbci	r25, 0x09	; 9
    1314:	a0 40       	sbci	r26, 0x00	; 0
    1316:	b0 40       	sbci	r27, 0x00	; 0
    1318:	09 f0       	breq	.+2      	; 0x131c <modWriteOption+0x8a>
    131a:	64 c0       	rjmp	.+200    	; 0x13e4 <modWriteOption+0x152>
    131c:	3b c0       	rjmp	.+118    	; 0x1394 <modWriteOption+0x102>
    131e:	80 38       	cpi	r24, 0x80	; 128
    1320:	e5 e2       	ldi	r30, 0x25	; 37
    1322:	9e 07       	cpc	r25, r30
    1324:	e0 e0       	ldi	r30, 0x00	; 0
    1326:	ae 07       	cpc	r26, r30
    1328:	e0 e0       	ldi	r30, 0x00	; 0
    132a:	be 07       	cpc	r27, r30
    132c:	99 f1       	breq	.+102    	; 0x1394 <modWriteOption+0x102>
    132e:	80 54       	subi	r24, 0x40	; 64
    1330:	98 43       	sbci	r25, 0x38	; 56
    1332:	a0 40       	sbci	r26, 0x00	; 0
    1334:	b0 40       	sbci	r27, 0x00	; 0
    1336:	09 f0       	breq	.+2      	; 0x133a <modWriteOption+0xa8>
    1338:	55 c0       	rjmp	.+170    	; 0x13e4 <modWriteOption+0x152>
    133a:	2c c0       	rjmp	.+88     	; 0x1394 <modWriteOption+0x102>
    133c:	80 30       	cpi	r24, 0x00	; 0
    133e:	41 ee       	ldi	r20, 0xE1	; 225
    1340:	94 07       	cpc	r25, r20
    1342:	40 e0       	ldi	r20, 0x00	; 0
    1344:	a4 07       	cpc	r26, r20
    1346:	40 e0       	ldi	r20, 0x00	; 0
    1348:	b4 07       	cpc	r27, r20
    134a:	21 f1       	breq	.+72     	; 0x1394 <modWriteOption+0x102>
    134c:	81 30       	cpi	r24, 0x01	; 1
    134e:	e1 ee       	ldi	r30, 0xE1	; 225
    1350:	9e 07       	cpc	r25, r30
    1352:	e0 e0       	ldi	r30, 0x00	; 0
    1354:	ae 07       	cpc	r26, r30
    1356:	e0 e0       	ldi	r30, 0x00	; 0
    1358:	be 07       	cpc	r27, r30
    135a:	78 f4       	brcc	.+30     	; 0x137a <modWriteOption+0xe8>
    135c:	80 38       	cpi	r24, 0x80	; 128
    135e:	f0 e7       	ldi	r31, 0x70	; 112
    1360:	9f 07       	cpc	r25, r31
    1362:	f0 e0       	ldi	r31, 0x00	; 0
    1364:	af 07       	cpc	r26, r31
    1366:	f0 e0       	ldi	r31, 0x00	; 0
    1368:	bf 07       	cpc	r27, r31
    136a:	a1 f0       	breq	.+40     	; 0x1394 <modWriteOption+0x102>
    136c:	80 50       	subi	r24, 0x00	; 0
    136e:	96 49       	sbci	r25, 0x96	; 150
    1370:	a0 40       	sbci	r26, 0x00	; 0
    1372:	b0 40       	sbci	r27, 0x00	; 0
    1374:	09 f0       	breq	.+2      	; 0x1378 <modWriteOption+0xe6>
    1376:	36 c0       	rjmp	.+108    	; 0x13e4 <modWriteOption+0x152>
    1378:	0d c0       	rjmp	.+26     	; 0x1394 <modWriteOption+0x102>
    137a:	80 30       	cpi	r24, 0x00	; 0
    137c:	ec e2       	ldi	r30, 0x2C	; 44
    137e:	9e 07       	cpc	r25, r30
    1380:	e1 e0       	ldi	r30, 0x01	; 1
    1382:	ae 07       	cpc	r26, r30
    1384:	e0 e0       	ldi	r30, 0x00	; 0
    1386:	be 07       	cpc	r27, r30
    1388:	29 f0       	breq	.+10     	; 0x1394 <modWriteOption+0x102>
    138a:	80 50       	subi	r24, 0x00	; 0
    138c:	92 4c       	sbci	r25, 0xC2	; 194
    138e:	a1 40       	sbci	r26, 0x01	; 1
    1390:	b0 40       	sbci	r27, 0x00	; 0
    1392:	41 f5       	brne	.+80     	; 0x13e4 <modWriteOption+0x152>
		default:SendErrorResponse(ILLEGAL_DATA_VALUE); 
				return;
			break;
	}

	if(((buffer->mode) < 2) && (buffer->ID0 > 0) && (buffer->ID1 > 0))
    1394:	f9 01       	movw	r30, r18
    1396:	81 81       	ldd	r24, Z+1	; 0x01
    1398:	82 30       	cpi	r24, 0x02	; 2
    139a:	20 f5       	brcc	.+72     	; 0x13e4 <modWriteOption+0x152>
    139c:	42 81       	ldd	r20, Z+2	; 0x02
    139e:	44 23       	and	r20, r20
    13a0:	09 f1       	breq	.+66     	; 0x13e4 <modWriteOption+0x152>
    13a2:	83 81       	ldd	r24, Z+3	; 0x03
    13a4:	88 23       	and	r24, r24
    13a6:	f1 f0       	breq	.+60     	; 0x13e4 <modWriteOption+0x152>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    13a8:	f9 99       	sbic	0x1f, 1	; 31
    13aa:	fe cf       	rjmp	.-4      	; 0x13a8 <modWriteOption+0x116>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    13ac:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    13ae:	88 eb       	ldi	r24, 0xB8	; 184
    13b0:	91 e0       	ldi	r25, 0x01	; 1
    13b2:	92 bd       	out	0x22, r25	; 34
    13b4:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    13b6:	40 bd       	out	0x20, r20	; 32

    __asm__ __volatile__ (
    13b8:	0f b6       	in	r0, 0x3f	; 63
    13ba:	f8 94       	cli
    13bc:	fa 9a       	sbi	0x1f, 2	; 31
    13be:	f9 9a       	sbi	0x1f, 1	; 31
    13c0:	0f be       	out	0x3f, r0	; 63
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    13c2:	89 eb       	ldi	r24, 0xB9	; 185
    13c4:	91 e0       	ldi	r25, 0x01	; 1
    13c6:	be 01       	movw	r22, r28
    13c8:	6f 5f       	subi	r22, 0xFF	; 255
    13ca:	7f 4f       	sbci	r23, 0xFF	; 255
    13cc:	44 e0       	ldi	r20, 0x04	; 4
    13ce:	50 e0       	ldi	r21, 0x00	; 0
    13d0:	21 e2       	ldi	r18, 0x21	; 33
    13d2:	39 e0       	ldi	r19, 0x09	; 9
    13d4:	0e 94 b9 19 	call	0x3372	; 0x3372 <__eewr_block>
	}
	else {
		SendErrorResponse(ILLEGAL_DATA_VALUE); return;
	}

	MBClientSend(sizeof(WRITE_OPTION));
    13d8:	8c e0       	ldi	r24, 0x0C	; 12
    13da:	0e 94 7e 08 	call	0x10fc	; 0x10fc <MBClientSend>

	InitUART();	
    13de:	0e 94 a9 0b 	call	0x1752	; 0x1752 <InitUART>
    13e2:	03 c0       	rjmp	.+6      	; 0x13ea <modWriteOption+0x158>
	{
		eeprom_write_byte((void*)&EEP_ID0, buffer->ID0);
		eeprom_write_block(&temp_Value0, (void*)&EEP_Boudrate0, sizeof(temp_Value0));		
	}
	else {
		SendErrorResponse(ILLEGAL_DATA_VALUE); return;
    13e4:	83 e0       	ldi	r24, 0x03	; 3
    13e6:	0e 94 84 08 	call	0x1108	; 0x1108 <SendErrorResponse>
	}

	MBClientSend(sizeof(WRITE_OPTION));

	InitUART();	
}
    13ea:	0f 90       	pop	r0
    13ec:	0f 90       	pop	r0
    13ee:	0f 90       	pop	r0
    13f0:	0f 90       	pop	r0
    13f2:	cf 91       	pop	r28
    13f4:	df 91       	pop	r29
    13f6:	08 95       	ret

000013f8 <MBReadMemory>:
	MBClientSend(7);
}

//„тение пам€ти
void MBReadMemory(MEMORY_OPERATE *p)
{
    13f8:	cf 93       	push	r28
    13fa:	df 93       	push	r29
    13fc:	ec 01       	movw	r28, r24
	//если хот€т считать много данных, то это плохо
	if(p->count > 245)
    13fe:	ee 81       	ldd	r30, Y+6	; 0x06
    1400:	e6 3f       	cpi	r30, 0xF6	; 246
    1402:	c0 f5       	brcc	.+112    	; 0x1474 <MBReadMemory+0x7c>
	{
		SendErrorResponse(ILLEGAL_DATA_VALUE);
		return;
	}
	switch(p->device)
    1404:	89 81       	ldd	r24, Y+1	; 0x01
    1406:	88 23       	and	r24, r24
    1408:	19 f0       	breq	.+6      	; 0x1410 <MBReadMemory+0x18>
    140a:	81 30       	cpi	r24, 0x01	; 1
    140c:	99 f5       	brne	.+102    	; 0x1474 <MBReadMemory+0x7c>
    140e:	17 c0       	rjmp	.+46     	; 0x143e <MBReadMemory+0x46>
	{
	case 0:
		//тут считываем из еепром, только если последний адрес < 512, больше в меге168 нет
		if (p->adress + p->count > (SPM_PAGESIZE * MAX_BOOT_PAGE))
    1410:	2a 81       	ldd	r18, Y+2	; 0x02
    1412:	3b 81       	ldd	r19, Y+3	; 0x03
    1414:	4c 81       	ldd	r20, Y+4	; 0x04
    1416:	5d 81       	ldd	r21, Y+5	; 0x05
    1418:	da 01       	movw	r26, r20
    141a:	c9 01       	movw	r24, r18
    141c:	8e 0f       	add	r24, r30
    141e:	91 1d       	adc	r25, r1
    1420:	a1 1d       	adc	r26, r1
    1422:	b1 1d       	adc	r27, r1
    1424:	81 58       	subi	r24, 0x81	; 129
    1426:	92 44       	sbci	r25, 0x42	; 66
    1428:	a0 40       	sbci	r26, 0x00	; 0
    142a:	b0 40       	sbci	r27, 0x00	; 0
    142c:	b8 f4       	brcc	.+46     	; 0x145c <MBReadMemory+0x64>
			//тут все плохо
			SendErrorResponse(ILLEGAL_DATA_ADRESS);
			return;
		}
		//собственно считываем
		memcpy_P(p->data, (void *)((unsigned int)p->adress), p->count);
    142e:	ce 01       	movw	r24, r28
    1430:	07 96       	adiw	r24, 0x07	; 7
    1432:	b9 01       	movw	r22, r18
    1434:	4e 2f       	mov	r20, r30
    1436:	50 e0       	ldi	r21, 0x00	; 0
    1438:	0e 94 63 19 	call	0x32c6	; 0x32c6 <memcpy_P>
    143c:	1f c0       	rjmp	.+62     	; 0x147c <MBReadMemory+0x84>
	
		break;
	case 1:
		//тут считываем из еепром, только если последний адрес < 512, больше в меге168 нет
		if (p->adress + p->count > 512)
    143e:	2a 81       	ldd	r18, Y+2	; 0x02
    1440:	3b 81       	ldd	r19, Y+3	; 0x03
    1442:	4c 81       	ldd	r20, Y+4	; 0x04
    1444:	5d 81       	ldd	r21, Y+5	; 0x05
    1446:	da 01       	movw	r26, r20
    1448:	c9 01       	movw	r24, r18
    144a:	8e 0f       	add	r24, r30
    144c:	91 1d       	adc	r25, r1
    144e:	a1 1d       	adc	r26, r1
    1450:	b1 1d       	adc	r27, r1
    1452:	81 50       	subi	r24, 0x01	; 1
    1454:	92 40       	sbci	r25, 0x02	; 2
    1456:	a0 40       	sbci	r26, 0x00	; 0
    1458:	b0 40       	sbci	r27, 0x00	; 0
    145a:	10 f0       	brcs	.+4      	; 0x1460 <MBReadMemory+0x68>
		{
			//тут все плохо
			SendErrorResponse(ILLEGAL_DATA_ADRESS);
    145c:	82 e0       	ldi	r24, 0x02	; 2
    145e:	0b c0       	rjmp	.+22     	; 0x1476 <MBReadMemory+0x7e>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    1460:	ce 01       	movw	r24, r28
    1462:	07 96       	adiw	r24, 0x07	; 7
    1464:	b9 01       	movw	r22, r18
    1466:	4e 2f       	mov	r20, r30
    1468:	50 e0       	ldi	r21, 0x00	; 0
    146a:	29 e1       	ldi	r18, 0x19	; 25
    146c:	39 e0       	ldi	r19, 0x09	; 9
    146e:	0e 94 87 19 	call	0x330e	; 0x330e <__eerd_block>
    1472:	04 c0       	rjmp	.+8      	; 0x147c <MBReadMemory+0x84>
		memmove(p->data, (void *)((unsigned int)p->adress), p->count);
	
		break;*/
	default:
		//другой пам€ти у нас нет
		SendErrorResponse(ILLEGAL_DATA_VALUE);
    1474:	83 e0       	ldi	r24, 0x03	; 3
    1476:	0e 94 84 08 	call	0x1108	; 0x1108 <SendErrorResponse>
    147a:	04 c0       	rjmp	.+8      	; 0x1484 <MBReadMemory+0x8c>
		return;
	}
	//ѕосылаем прочитанное
	MBClientSend(p->count + 7);			
    147c:	8e 81       	ldd	r24, Y+6	; 0x06
    147e:	89 5f       	subi	r24, 0xF9	; 249
    1480:	0e 94 7e 08 	call	0x10fc	; 0x10fc <MBClientSend>
}
    1484:	df 91       	pop	r29
    1486:	cf 91       	pop	r28
    1488:	08 95       	ret

0000148a <modReadInputRegisters>:
	}
}

//функци€ 0х04 чтение внутренних "регистров" устройства
void modReadInputRegisters(READ_INPUT_REGS *regTask)
{
    148a:	cf 93       	push	r28
    148c:	df 93       	push	r29
    148e:	ec 01       	movw	r28, r24
	unsigned short requestAddress;
	unsigned short requestRegister;

	requestAddress = ((unsigned short)(regTask->request.st_adr_hi << 8))|((unsigned short)(regTask->request.st_adr_lo));
    1490:	99 81       	ldd	r25, Y+1	; 0x01
    1492:	80 e0       	ldi	r24, 0x00	; 0
    1494:	2a 81       	ldd	r18, Y+2	; 0x02
    1496:	42 2f       	mov	r20, r18
    1498:	50 e0       	ldi	r21, 0x00	; 0
    149a:	48 2b       	or	r20, r24
    149c:	59 2b       	or	r21, r25
	requestRegister = ((unsigned short)(regTask->request.quantity_hi << 8))|((unsigned short)(regTask->request.quantity_lo));
    149e:	9b 81       	ldd	r25, Y+3	; 0x03
    14a0:	80 e0       	ldi	r24, 0x00	; 0
    14a2:	2c 81       	ldd	r18, Y+4	; 0x04
    14a4:	30 e0       	ldi	r19, 0x00	; 0
    14a6:	28 2b       	or	r18, r24
    14a8:	39 2b       	or	r19, r25
	regTask->response.count = (byte)(requestRegister * 2);
    14aa:	f9 01       	movw	r30, r18
    14ac:	ee 0f       	add	r30, r30
    14ae:	ff 1f       	adc	r31, r31
    14b0:	e9 83       	std	Y+1, r30	; 0x01

	if(requestAddress <  sizeof(REGISTER_FILE)/2)
    14b2:	4c 3d       	cpi	r20, 0xDC	; 220
    14b4:	51 05       	cpc	r21, r1
    14b6:	c8 f4       	brcc	.+50     	; 0x14ea <modReadInputRegisters+0x60>
	{
		if((requestAddress + requestRegister) <= (sizeof(REGISTER_FILE)/2))
    14b8:	24 0f       	add	r18, r20
    14ba:	35 1f       	adc	r19, r21
    14bc:	2d 3d       	cpi	r18, 0xDD	; 221
    14be:	31 05       	cpc	r19, r1
    14c0:	90 f4       	brcc	.+36     	; 0x14e6 <modReadInputRegisters+0x5c>
		{
			memcpy(regTask->response.InpRegs,&(RegFile.mb_array[requestAddress]), regTask->response.count);
    14c2:	9e 01       	movw	r18, r28
    14c4:	2e 5f       	subi	r18, 0xFE	; 254
    14c6:	3f 4f       	sbci	r19, 0xFF	; 255
    14c8:	44 0f       	add	r20, r20
    14ca:	55 1f       	adc	r21, r21
    14cc:	4b 58       	subi	r20, 0x8B	; 139
    14ce:	5d 4f       	sbci	r21, 0xFD	; 253
    14d0:	c9 01       	movw	r24, r18
    14d2:	ba 01       	movw	r22, r20
    14d4:	4e 2f       	mov	r20, r30
    14d6:	50 e0       	ldi	r21, 0x00	; 0
    14d8:	0e 94 6c 19 	call	0x32d8	; 0x32d8 <memcpy>
			MBClientSend(2+regTask->response.count);
    14dc:	89 81       	ldd	r24, Y+1	; 0x01
    14de:	8e 5f       	subi	r24, 0xFE	; 254
    14e0:	0e 94 7e 08 	call	0x10fc	; 0x10fc <MBClientSend>
    14e4:	05 c0       	rjmp	.+10     	; 0x14f0 <modReadInputRegisters+0x66>
		}
		else {
				SendErrorResponse(ILLEGAL_DATA_VALUE);	
    14e6:	83 e0       	ldi	r24, 0x03	; 3
    14e8:	01 c0       	rjmp	.+2      	; 0x14ec <modReadInputRegisters+0x62>
			 }
	} 
	else {
			SendErrorResponse(ILLEGAL_DATA_ADRESS);
    14ea:	82 e0       	ldi	r24, 0x02	; 2
    14ec:	0e 94 84 08 	call	0x1108	; 0x1108 <SendErrorResponse>
		 }
}
    14f0:	df 91       	pop	r29
    14f2:	cf 91       	pop	r28
    14f4:	08 95       	ret

000014f6 <CheckRegisterValue>:

        SREG = sreg;
    }

inline unsigned char CheckRegisterValue(unsigned short address, unsigned short value)
{
    14f6:	cf 92       	push	r12
    14f8:	df 92       	push	r13
    14fa:	ef 92       	push	r14
    14fc:	ff 92       	push	r15
    14fe:	0f 93       	push	r16
    1500:	1f 93       	push	r17
    1502:	cf 93       	push	r28
    1504:	df 93       	push	r29
    1506:	8c 01       	movw	r16, r24
    1508:	7b 01       	movw	r14, r22
	unsigned short regValue;
	
	unsigned short i;

	regAddres = (unsigned char*)&RegFile.mb_struct.dot_info.N - (unsigned char*)&RegFile;
    regValue = Reverse2(value);
    150a:	cb 01       	movw	r24, r22
    150c:	0e 94 f4 0f 	call	0x1fe8	; 0x1fe8 <Reverse2>
	
	if (address * 2 == regAddres && (regValue == 0 || regValue > MAX_DOT_COUNT))
    1510:	00 0f       	add	r16, r16
    1512:	11 1f       	adc	r17, r17
    1514:	04 31       	cpi	r16, 0x14	; 20
    1516:	11 05       	cpc	r17, r1
    1518:	d9 f4       	brne	.+54     	; 0x1550 <CheckRegisterValue+0x5a>
    151a:	01 97       	sbiw	r24, 0x01	; 1
    151c:	04 97       	sbiw	r24, 0x04	; 4
    151e:	c0 f0       	brcs	.+48     	; 0x1550 <CheckRegisterValue+0x5a>
    1520:	27 c0       	rjmp	.+78     	; 0x1570 <CheckRegisterValue+0x7a>
    	return false;
    }
    
    for(i = 0; i < Reverse2(RegFile.mb_struct.dot_info.N); i ++)
    {
        regValue = Reverse2(value);
    1522:	c7 01       	movw	r24, r14
    1524:	0e 94 f4 0f 	call	0x1fe8	; 0x1fe8 <Reverse2>
    1528:	9c 01       	movw	r18, r24
		regAddres = (unsigned char *)& RegFile.mb_struct.dot_info.DOT[i].N - (unsigned char*)&RegFile;
		if (address * 2  == regAddres && (regValue < 2 || regValue > DOT_PAR_COUNT))
    152a:	cc 9d       	mul	r28, r12
    152c:	c0 01       	movw	r24, r0
    152e:	cd 9d       	mul	r28, r13
    1530:	90 0d       	add	r25, r0
    1532:	dc 9d       	mul	r29, r12
    1534:	90 0d       	add	r25, r0
    1536:	11 24       	eor	r1, r1
    1538:	84 59       	subi	r24, 0x94	; 148
    153a:	9f 4f       	sbci	r25, 0xFF	; 255
    153c:	08 17       	cp	r16, r24
    153e:	19 07       	cpc	r17, r25
    1540:	29 f4       	brne	.+10     	; 0x154c <CheckRegisterValue+0x56>
    1542:	22 50       	subi	r18, 0x02	; 2
    1544:	30 40       	sbci	r19, 0x00	; 0
    1546:	2d 31       	cpi	r18, 0x1D	; 29
    1548:	31 05       	cpc	r19, r1
    154a:	90 f4       	brcc	.+36     	; 0x1570 <CheckRegisterValue+0x7a>
	if (address * 2 == regAddres && (regValue == 0 || regValue > MAX_DOT_COUNT))
    {
    	return false;
    }
    
    for(i = 0; i < Reverse2(RegFile.mb_struct.dot_info.N); i ++)
    154c:	21 96       	adiw	r28, 0x01	; 1
    154e:	05 c0       	rjmp	.+10     	; 0x155a <CheckRegisterValue+0x64>
    1550:	c0 e0       	ldi	r28, 0x00	; 0
    1552:	d0 e0       	ldi	r29, 0x00	; 0
    {
        regValue = Reverse2(value);
		regAddres = (unsigned char *)& RegFile.mb_struct.dot_info.DOT[i].N - (unsigned char*)&RegFile;
		if (address * 2  == regAddres && (regValue < 2 || regValue > DOT_PAR_COUNT))
    1554:	26 e5       	ldi	r18, 0x56	; 86
    1556:	c2 2e       	mov	r12, r18
    1558:	d1 2c       	mov	r13, r1
	if (address * 2 == regAddres && (regValue == 0 || regValue > MAX_DOT_COUNT))
    {
    	return false;
    }
    
    for(i = 0; i < Reverse2(RegFile.mb_struct.dot_info.N); i ++)
    155a:	80 91 89 02 	lds	r24, 0x0289
    155e:	90 91 8a 02 	lds	r25, 0x028A
    1562:	0e 94 f4 0f 	call	0x1fe8	; 0x1fe8 <Reverse2>
    1566:	c8 17       	cp	r28, r24
    1568:	d9 07       	cpc	r29, r25
    156a:	d8 f2       	brcs	.-74     	; 0x1522 <CheckRegisterValue+0x2c>
    156c:	81 e0       	ldi	r24, 0x01	; 1
    156e:	01 c0       	rjmp	.+2      	; 0x1572 <CheckRegisterValue+0x7c>
    1570:	80 e0       	ldi	r24, 0x00	; 0
			return false;
        }
    }

    return true;
}
    1572:	df 91       	pop	r29
    1574:	cf 91       	pop	r28
    1576:	1f 91       	pop	r17
    1578:	0f 91       	pop	r16
    157a:	ff 90       	pop	r15
    157c:	ef 90       	pop	r14
    157e:	df 90       	pop	r13
    1580:	cf 90       	pop	r12
    1582:	08 95       	ret

00001584 <modWriteSingleRegister>:

void modWriteSingleRegister(WRITE_SINGLE_REGISTER* regTask)
{
    1584:	ef 92       	push	r14
    1586:	ff 92       	push	r15
    1588:	0f 93       	push	r16
    158a:	1f 93       	push	r17
    158c:	df 93       	push	r29
    158e:	cf 93       	push	r28
    1590:	00 d0       	rcall	.+0      	; 0x1592 <modWriteSingleRegister+0xe>
    1592:	cd b7       	in	r28, 0x3d	; 61
    1594:	de b7       	in	r29, 0x3e	; 62
    1596:	fc 01       	movw	r30, r24
	unsigned short requestAddress;
	unsigned short requestAddressBase;
    unsigned short ValueRegister;

	requestAddressBase = ((unsigned short)(regTask->st_adr_hi << 8))|((unsigned short)(regTask->st_adr_lo));
    1598:	91 81       	ldd	r25, Z+1	; 0x01
    159a:	80 e0       	ldi	r24, 0x00	; 0
    159c:	22 81       	ldd	r18, Z+2	; 0x02
    159e:	02 2f       	mov	r16, r18
    15a0:	10 e0       	ldi	r17, 0x00	; 0
    15a2:	08 2b       	or	r16, r24
    15a4:	19 2b       	or	r17, r25

	ValueRegister = ( ((unsigned short)regTask->value_lo << 8)|(((unsigned short)regTask->value_hi) ));
    15a6:	94 81       	ldd	r25, Z+4	; 0x04
    15a8:	80 e0       	ldi	r24, 0x00	; 0
    15aa:	23 81       	ldd	r18, Z+3	; 0x03
    15ac:	62 2f       	mov	r22, r18
    15ae:	70 e0       	ldi	r23, 0x00	; 0
    15b0:	68 2b       	or	r22, r24
    15b2:	79 2b       	or	r23, r25
    15b4:	7a 83       	std	Y+2, r23	; 0x02
    15b6:	69 83       	std	Y+1, r22	; 0x01

	if(requestAddressBase <  sizeof(REGISTER_FILE))
    15b8:	81 e0       	ldi	r24, 0x01	; 1
    15ba:	08 3b       	cpi	r16, 0xB8	; 184
    15bc:	18 07       	cpc	r17, r24
    15be:	08 f0       	brcs	.+2      	; 0x15c2 <modWriteSingleRegister+0x3e>
    15c0:	42 c0       	rjmp	.+132    	; 0x1646 <modWriteSingleRegister+0xc2>
	{
		requestAddress = requestAddressBase;
		if(requestAddress >= sizeof(REGISTER_FILE)/2) // «начит хотим писать только в ќ«”, без записи в EEPROM
    15c2:	0c 3d       	cpi	r16, 0xDC	; 220
    15c4:	11 05       	cpc	r17, r1
    15c6:	10 f4       	brcc	.+4      	; 0x15cc <modWriteSingleRegister+0x48>
    15c8:	78 01       	movw	r14, r16
    15ca:	06 c0       	rjmp	.+12     	; 0x15d8 <modWriteSingleRegister+0x54>
			requestAddress = requestAddressBase - sizeof(REGISTER_FILE)/2;
    15cc:	54 e2       	ldi	r21, 0x24	; 36
    15ce:	e5 2e       	mov	r14, r21
    15d0:	5f ef       	ldi	r21, 0xFF	; 255
    15d2:	f5 2e       	mov	r15, r21
    15d4:	e0 0e       	add	r14, r16
    15d6:	f1 1e       	adc	r15, r17
		if (!CheckRegisterValue(requestAddress, ValueRegister))
    15d8:	c7 01       	movw	r24, r14
    15da:	0e 94 7b 0a 	call	0x14f6	; 0x14f6 <CheckRegisterValue>
    15de:	88 23       	and	r24, r24
    15e0:	11 f4       	brne	.+4      	; 0x15e6 <modWriteSingleRegister+0x62>
        {
            SendErrorResponse(ILLEGAL_DATA_VALUE);
    15e2:	83 e0       	ldi	r24, 0x03	; 3
    15e4:	31 c0       	rjmp	.+98     	; 0x1648 <modWriteSingleRegister+0xc4>
    15e6:	ee 0c       	add	r14, r14
    15e8:	ff 1c       	adc	r15, r15
        }
        else
        {
			if(requestAddressBase >= sizeof(REGISTER_FILE)/2)
    15ea:	0c 3d       	cpi	r16, 0xDC	; 220
    15ec:	11 05       	cpc	r17, r1
    15ee:	50 f0       	brcs	.+20     	; 0x1604 <modWriteSingleRegister+0x80>
			{
				memcpy(&RegFile.mb_array[requestAddress], &ValueRegister, sizeof(ValueRegister));
    15f0:	e5 e7       	ldi	r30, 0x75	; 117
    15f2:	f2 e0       	ldi	r31, 0x02	; 2
    15f4:	ee 0e       	add	r14, r30
    15f6:	ff 1e       	adc	r15, r31
    15f8:	89 81       	ldd	r24, Y+1	; 0x01
    15fa:	9a 81       	ldd	r25, Y+2	; 0x02
    15fc:	f7 01       	movw	r30, r14
    15fe:	91 83       	std	Z+1, r25	; 0x01
    1600:	80 83       	st	Z, r24
    1602:	17 c0       	rjmp	.+46     	; 0x1632 <modWriteSingleRegister+0xae>
				RegFile.mb_struct.U_type = VERSION_PO;
			}
			else
			{
            	eeprom_write_block(&ValueRegister, &EepromRegFile.mb_array[requestAddress], sizeof(ValueRegister));
    1604:	87 01       	movw	r16, r14
    1606:	00 50       	subi	r16, 0x00	; 0
    1608:	10 40       	sbci	r17, 0x00	; 0
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    160a:	c8 01       	movw	r24, r16
    160c:	be 01       	movw	r22, r28
    160e:	6f 5f       	subi	r22, 0xFF	; 255
    1610:	7f 4f       	sbci	r23, 0xFF	; 255
    1612:	42 e0       	ldi	r20, 0x02	; 2
    1614:	50 e0       	ldi	r21, 0x00	; 0
    1616:	21 e2       	ldi	r18, 0x21	; 33
    1618:	39 e0       	ldi	r19, 0x09	; 9
    161a:	0e 94 b9 19 	call	0x3372	; 0x3372 <__eewr_block>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    161e:	c7 01       	movw	r24, r14
    1620:	8b 58       	subi	r24, 0x8B	; 139
    1622:	9d 4f       	sbci	r25, 0xFD	; 253
    1624:	b8 01       	movw	r22, r16
    1626:	42 e0       	ldi	r20, 0x02	; 2
    1628:	50 e0       	ldi	r21, 0x00	; 0
    162a:	29 e1       	ldi	r18, 0x19	; 25
    162c:	39 e0       	ldi	r19, 0x09	; 9
    162e:	0e 94 87 19 	call	0x330e	; 0x330e <__eerd_block>
				eeprom_read_block(&RegFile.mb_array[requestAddress], &EepromRegFile.mb_array[requestAddress], sizeof(ValueRegister));
				RegFile.mb_struct.U_type = VERSION_PO;
    1632:	82 e2       	ldi	r24, 0x22	; 34
    1634:	92 e2       	ldi	r25, 0x22	; 34
    1636:	90 93 76 02 	sts	0x0276, r25
    163a:	80 93 75 02 	sts	0x0275, r24
			}
		    MBClientSend(sizeof(WRITE_SINGLE_REGISTER));
    163e:	85 e0       	ldi	r24, 0x05	; 5
    1640:	0e 94 7e 08 	call	0x10fc	; 0x10fc <MBClientSend>
    1644:	03 c0       	rjmp	.+6      	; 0x164c <modWriteSingleRegister+0xc8>
        }
	}
	else 
    {
		SendErrorResponse(ILLEGAL_DATA_ADRESS);
    1646:	82 e0       	ldi	r24, 0x02	; 2
    1648:	0e 94 84 08 	call	0x1108	; 0x1108 <SendErrorResponse>
	}
}
    164c:	0f 90       	pop	r0
    164e:	0f 90       	pop	r0
    1650:	cf 91       	pop	r28
    1652:	df 91       	pop	r29
    1654:	1f 91       	pop	r17
    1656:	0f 91       	pop	r16
    1658:	ff 90       	pop	r15
    165a:	ef 90       	pop	r14
    165c:	08 95       	ret

0000165e <MBClientProcess>:
	InitUART();	
}


void MBClientProcess(byte *buffer,byte Size)
{
    165e:	fc 01       	movw	r30, r24
	switch(buffer[0])
    1660:	80 81       	ld	r24, Z
    1662:	88 30       	cpi	r24, 0x08	; 8
    1664:	11 f1       	breq	.+68     	; 0x16aa <MBClientProcess+0x4c>
    1666:	89 30       	cpi	r24, 0x09	; 9
    1668:	28 f4       	brcc	.+10     	; 0x1674 <MBClientProcess+0x16>
    166a:	84 30       	cpi	r24, 0x04	; 4
    166c:	51 f0       	breq	.+20     	; 0x1682 <MBClientProcess+0x24>
    166e:	86 30       	cpi	r24, 0x06	; 6
    1670:	01 f5       	brne	.+64     	; 0x16b2 <MBClientProcess+0x54>
    1672:	0b c0       	rjmp	.+22     	; 0x168a <MBClientProcess+0x2c>
    1674:	86 34       	cpi	r24, 0x46	; 70
    1676:	69 f0       	breq	.+26     	; 0x1692 <MBClientProcess+0x34>
    1678:	87 34       	cpi	r24, 0x47	; 71
    167a:	99 f0       	breq	.+38     	; 0x16a2 <MBClientProcess+0x44>
    167c:	85 34       	cpi	r24, 0x45	; 69
    167e:	c9 f4       	brne	.+50     	; 0x16b2 <MBClientProcess+0x54>
    1680:	0c c0       	rjmp	.+24     	; 0x169a <MBClientProcess+0x3c>
	{
		case MOD_READ_INPUT_REGISTER:
			modReadInputRegisters((READ_INPUT_REGS *)buffer);	
    1682:	cf 01       	movw	r24, r30
    1684:	0e 94 45 0a 	call	0x148a	; 0x148a <modReadInputRegisters>
    1688:	08 95       	ret
			break;
		case MOD_WRITE_SINGLE_REGISTER:
			modWriteSingleRegister((WRITE_SINGLE_REGISTER*)buffer);
    168a:	cf 01       	movw	r24, r30
    168c:	0e 94 c2 0a 	call	0x1584	; 0x1584 <modWriteSingleRegister>
    1690:	08 95       	ret
			break;
		case MOD_READ_FLASH:
			MBReadMemory((MEMORY_OPERATE *)buffer);
    1692:	cf 01       	movw	r24, r30
    1694:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <MBReadMemory>
    1698:	08 95       	ret
			break;
		case MOD_WRITE_FLASH :
			WriteFlash((MEMORY_OPERATE *)buffer);
    169a:	cf 01       	movw	r24, r30
    169c:	0e 94 2e 09 	call	0x125c	; 0x125c <WriteFlash>
    16a0:	08 95       	ret
			break;	
		case MOD_WRITE_OPTION :
			modWriteOption((WRITE_OPTION *)buffer);
    16a2:	cf 01       	movw	r24, r30
    16a4:	0e 94 49 09 	call	0x1292	; 0x1292 <modWriteOption>
    16a8:	08 95       	ret
			break;
        case MOD_DIAGNOSTIC:
			DiagnosticModbus0(buffer,Size);
    16aa:	cf 01       	movw	r24, r30
    16ac:	0e 94 99 08 	call	0x1132	; 0x1132 <DiagnosticModbus0>
    16b0:	08 95       	ret
			break;

        default:
			SendErrorResponse(ILLEGAL_FUNCTION);
    16b2:	81 e0       	ldi	r24, 0x01	; 1
    16b4:	0e 94 84 08 	call	0x1108	; 0x1108 <SendErrorResponse>
    16b8:	08 95       	ret

000016ba <ModbusProcess>:
	}
}

inline void ModbusProcess()
{
    16ba:	1f 93       	push	r17
	unsigned char packet_size;

    if (!RegFile.mb_struct.Configured || RegFile.mb_struct.dot_info.fl_freq)
    16bc:	80 91 7b 02 	lds	r24, 0x027B
    16c0:	90 91 7c 02 	lds	r25, 0x027C
    16c4:	89 2b       	or	r24, r25
    16c6:	31 f0       	breq	.+12     	; 0x16d4 <ModbusProcess+0x1a>
    16c8:	80 91 8b 02 	lds	r24, 0x028B
    16cc:	90 91 8c 02 	lds	r25, 0x028C
    16d0:	89 2b       	or	r24, r25
    16d2:	a1 f0       	breq	.+40     	; 0x16fc <ModbusProcess+0x42>
	{
		packet_size = UartRecivePacket();
    16d4:	0e 94 ee 0b 	call	0x17dc	; 0x17dc <UartRecivePacket>
    16d8:	18 2f       	mov	r17, r24
	
		if(packet_size)
    16da:	88 23       	and	r24, r24
    16dc:	69 f0       	breq	.+26     	; 0x16f8 <ModbusProcess+0x3e>
		{
			if(check_modbus_packet(MBClientGetHostID0()))
    16de:	80 91 00 01 	lds	r24, 0x0100
    16e2:	0e 94 e3 08 	call	0x11c6	; 0x11c6 <check_modbus_packet>
    16e6:	88 23       	and	r24, r24
    16e8:	39 f0       	breq	.+14     	; 0x16f8 <ModbusProcess+0x3e>
			{
				report_on = 0;  // отключаем омникомовский репит
    16ea:	10 92 50 04 	sts	0x0450, r1
				MBClientProcess(DataBuffer0 + 1, packet_size);
    16ee:	88 e7       	ldi	r24, 0x78	; 120
    16f0:	91 e0       	ldi	r25, 0x01	; 1
    16f2:	61 2f       	mov	r22, r17
    16f4:	0e 94 2f 0b 	call	0x165e	; 0x165e <MBClientProcess>
			}
			//do_omnicom();
		}
		do_omnicom();				
    16f8:	0e 94 68 11 	call	0x22d0	; 0x22d0 <do_omnicom>
	
}

#endif
}
    16fc:	1f 91       	pop	r17
    16fe:	08 95       	ret

00001700 <CRC16>:
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80,
		0x40
	};

unsigned int __CRC16__ CRC16 (byte * puchMsg, byte usDataLen, unsigned int prevCRC) /* The function returns the CRC as a unsigned short type */
{
    1700:	dc 01       	movw	r26, r24
    1702:	0f c0       	rjmp	.+30     	; 0x1722 <CRC16+0x22>
	unsigned char uchCRCHi = prevCRC >> 8; //0xFF ; /* high byte of CRC initialized */
	unsigned char uchCRCLo = prevCRC & 0xFF;//0xFF ; /* low byte of CRC initialized */
	unsigned int uIndex; /* will index into CRC lookup table */
	while (usDataLen--) /* pass through message buffer */
	{
		uIndex = uchCRCLo ^ *puchMsg++ ; /* calculate the CRC */
    1704:	ed 91       	ld	r30, X+
    1706:	e4 27       	eor	r30, r20
    1708:	2e 2f       	mov	r18, r30
    170a:	30 e0       	ldi	r19, 0x00	; 0
		uchCRCLo = uchCRCHi ^ pgm_read_byte(auchCRCHi + uIndex);
    170c:	c9 01       	movw	r24, r18
    170e:	88 59       	subi	r24, 0x98	; 152
    1710:	9f 4f       	sbci	r25, 0xFF	; 255
    1712:	fc 01       	movw	r30, r24
    1714:	44 91       	lpm	r20, Z+
    1716:	45 27       	eor	r20, r21
		uchCRCHi = pgm_read_byte(auchCRCLo + uIndex);
    1718:	28 59       	subi	r18, 0x98	; 152
    171a:	3e 4f       	sbci	r19, 0xFE	; 254
    171c:	f9 01       	movw	r30, r18
    171e:	54 91       	lpm	r21, Z+
    1720:	61 50       	subi	r22, 0x01	; 1
unsigned int __CRC16__ CRC16 (byte * puchMsg, byte usDataLen, unsigned int prevCRC) /* The function returns the CRC as a unsigned short type */
{
	unsigned char uchCRCHi = prevCRC >> 8; //0xFF ; /* high byte of CRC initialized */
	unsigned char uchCRCLo = prevCRC & 0xFF;//0xFF ; /* low byte of CRC initialized */
	unsigned int uIndex; /* will index into CRC lookup table */
	while (usDataLen--) /* pass through message buffer */
    1722:	66 23       	and	r22, r22
    1724:	79 f7       	brne	.-34     	; 0x1704 <CRC16+0x4>
    1726:	95 2f       	mov	r25, r21
    1728:	80 e0       	ldi	r24, 0x00	; 0
    172a:	24 2f       	mov	r18, r20
    172c:	30 e0       	ldi	r19, 0x00	; 0
    172e:	28 2b       	or	r18, r24
    1730:	39 2b       	or	r19, r25
		uIndex = uchCRCLo ^ *puchMsg++ ; /* calculate the CRC */
		uchCRCLo = uchCRCHi ^ pgm_read_byte(auchCRCHi + uIndex);
		uchCRCHi = pgm_read_byte(auchCRCLo + uIndex);
	}
	return (uchCRCHi << 8 | uchCRCLo) ;
}
    1732:	c9 01       	movw	r24, r18
    1734:	08 95       	ret

00001736 <SET_DE485_0>:
byte DataBuffer0[ MBCLIENT_MAX_LENGHT ];
__ALSO_VAR__ volatile byte BufferSize0 = 0;

__ALSO_VAR__ volatile byte state0 = State_INITIAL;

void SET_DE485_0(void){ cbi(UCSR0B, RXEN0); sbi(PORT_DE, PIN_DE); }
    1736:	e1 ec       	ldi	r30, 0xC1	; 193
    1738:	f0 e0       	ldi	r31, 0x00	; 0
    173a:	80 81       	ld	r24, Z
    173c:	8f 7e       	andi	r24, 0xEF	; 239
    173e:	80 83       	st	Z, r24
    1740:	5a 9a       	sbi	0x0b, 2	; 11
    1742:	08 95       	ret

00001744 <CLR_DE485_0>:
void CLR_DE485_0(void){ cbi(PORT_DE, PIN_DE); sbi(UCSR0B, RXEN0); }
    1744:	5a 98       	cbi	0x0b, 2	; 11
    1746:	e1 ec       	ldi	r30, 0xC1	; 193
    1748:	f0 e0       	ldi	r31, 0x00	; 0
    174a:	80 81       	ld	r24, Z
    174c:	80 61       	ori	r24, 0x10	; 16
    174e:	80 83       	st	Z, r24
    1750:	08 95       	ret

00001752 <InitUART>:
void InitUART(void)
{
	//unsigned long BRATE;

	// настройка UART
	UCSR0B |= (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
    1752:	e1 ec       	ldi	r30, 0xC1	; 193
    1754:	f0 e0       	ldi	r31, 0x00	; 0
    1756:	80 81       	ld	r24, Z
    1758:	88 69       	ori	r24, 0x98	; 152
    175a:	80 83       	st	Z, r24
	pUDR0 = &UDR0;
    175c:	86 ec       	ldi	r24, 0xC6	; 198
    175e:	90 e0       	ldi	r25, 0x00	; 0
    1760:	90 93 74 02 	sts	0x0274, r25
    1764:	80 93 73 02 	sts	0x0273, r24
	// настройка порта 
	cbi(PORT_DE, PIN_DE);
    1768:	5a 98       	cbi	0x0b, 2	; 11
	DDR_DE |= (1 << PIN_DE);
    176a:	52 9a       	sbi	0x0a, 2	; 10
}

static inline void MBClientSetBaudrate0(byte baudrate)
{
	//установить скорость UBRR=(Fck/(16*baudrate))-1
	UBR0 = baudrate;
    176c:	8f e2       	ldi	r24, 0x2F	; 47
    176e:	80 93 c4 00 	sts	0x00C4, r24

static inline void MBClientSetHostID0(byte host)
{
	//сохранить адрес этого клиента в EEPROM
	//в переменной hostID
	hostID0 = host;
    1772:	83 e6       	ldi	r24, 0x63	; 99
    1774:	80 93 00 01 	sts	0x0100, r24
	MBClientSetBaudrate0((byte)(F_CPU/16/19200 - 1));
	//код устройства задаетс€
	MBClientSetHostID0(99);//eeprom_read_byte((void*)&EEP_ID0));

	//есть цела€ теори€ почему так должно быть
	PORTD=1<<0;
    1778:	81 e0       	ldi	r24, 0x01	; 1
    177a:	8b b9       	out	0x0b, r24	; 11

	sbi(TIMSK0, TOIE0);	
    177c:	ee e6       	ldi	r30, 0x6E	; 110
    177e:	f0 e0       	ldi	r31, 0x00	; 0
    1780:	80 81       	ld	r24, Z
    1782:	81 60       	ori	r24, 0x01	; 1
    1784:	80 83       	st	Z, r24
}
    1786:	08 95       	ret

00001788 <__vector_16>:

SIGNAL(SIG_OVERFLOW0)
{
    1788:	1f 92       	push	r1
    178a:	0f 92       	push	r0
    178c:	0f b6       	in	r0, 0x3f	; 63
    178e:	0f 92       	push	r0
    1790:	11 24       	eor	r1, r1
    1792:	8f 93       	push	r24
    1794:	9f 93       	push	r25
    1796:	af 93       	push	r26
    1798:	bf 93       	push	r27

//”величивает таймер. ¬ставл€ть в обработчик прерывани€ 8-битного таймера
//настроенного на счЄт CK 3,6864Mhz
static inline void MBClientIncTimer0(void)
{
	timer0++;//нарастим таймер
    179a:	80 91 76 01 	lds	r24, 0x0176
    179e:	8f 5f       	subi	r24, 0xFF	; 255
    17a0:	80 93 76 01 	sts	0x0176, r24
	MBClientIncTimer0();
	omnicomm_timer++;
    17a4:	80 91 2d 04 	lds	r24, 0x042D
    17a8:	90 91 2e 04 	lds	r25, 0x042E
    17ac:	a0 91 2f 04 	lds	r26, 0x042F
    17b0:	b0 91 30 04 	lds	r27, 0x0430
    17b4:	01 96       	adiw	r24, 0x01	; 1
    17b6:	a1 1d       	adc	r26, r1
    17b8:	b1 1d       	adc	r27, r1
    17ba:	80 93 2d 04 	sts	0x042D, r24
    17be:	90 93 2e 04 	sts	0x042E, r25
    17c2:	a0 93 2f 04 	sts	0x042F, r26
    17c6:	b0 93 30 04 	sts	0x0430, r27
}
    17ca:	bf 91       	pop	r27
    17cc:	af 91       	pop	r26
    17ce:	9f 91       	pop	r25
    17d0:	8f 91       	pop	r24
    17d2:	0f 90       	pop	r0
    17d4:	0f be       	out	0x3f, r0	; 63
    17d6:	0f 90       	pop	r0
    17d8:	1f 90       	pop	r1
    17da:	18 95       	reti

000017dc <UartRecivePacket>:

__MBCL_RECEIVE__ byte UartRecivePacket(void)
{
	static byte stage = 0;
		
	switch(stage)
    17dc:	80 91 36 01 	lds	r24, 0x0136
    17e0:	81 30       	cpi	r24, 0x01	; 1
    17e2:	e9 f0       	breq	.+58     	; 0x181e <UartRecivePacket+0x42>
    17e4:	81 30       	cpi	r24, 0x01	; 1
    17e6:	28 f0       	brcs	.+10     	; 0x17f2 <UartRecivePacket+0x16>
    17e8:	82 30       	cpi	r24, 0x02	; 2
    17ea:	31 f1       	breq	.+76     	; 0x1838 <UartRecivePacket+0x5c>
    17ec:	83 30       	cpi	r24, 0x03	; 3
    17ee:	b9 f5       	brne	.+110    	; 0x185e <UartRecivePacket+0x82>
    17f0:	2d c0       	rjmp	.+90     	; 0x184c <UartRecivePacket+0x70>
				CLR_DE485_0();
			}
			break;
		case 2:
			*/
			if(state0 == State_INITIAL)
    17f2:	80 91 35 01 	lds	r24, 0x0135
    17f6:	88 23       	and	r24, r24
    17f8:	61 f4       	brne	.+24     	; 0x1812 <UartRecivePacket+0x36>
			{
				if(timer0 > T35_Ticks)
    17fa:	80 91 76 01 	lds	r24, 0x0176
    17fe:	8d 31       	cpi	r24, 0x1D	; 29
    1800:	70 f1       	brcs	.+92     	; 0x185e <UartRecivePacket+0x82>
				{
					stage++;
    1802:	81 e0       	ldi	r24, 0x01	; 1
    1804:	80 93 36 01 	sts	0x0136, r24
					BufferSize0 = 0;
    1808:	10 92 34 01 	sts	0x0134, r1
					state0 = State_IDLE; //”становить состо€ние инициализации
    180c:	80 93 35 01 	sts	0x0135, r24
    1810:	11 c0       	rjmp	.+34     	; 0x1834 <UartRecivePacket+0x58>
				}
			}
			else
			{
				state0 = State_IDLE; //”становить состо€ние инициализации
    1812:	81 e0       	ldi	r24, 0x01	; 1
    1814:	80 93 35 01 	sts	0x0135, r24
				BufferSize0 = 0;
    1818:	10 92 34 01 	sts	0x0134, r1
    181c:	09 c0       	rjmp	.+18     	; 0x1830 <UartRecivePacket+0x54>
				stage++;
			}
			break;
		case 1:
			if(state0 == State_RECEIVING || state0 == State_WAITING)
    181e:	80 91 35 01 	lds	r24, 0x0135
    1822:	82 30       	cpi	r24, 0x02	; 2
    1824:	21 f0       	breq	.+8      	; 0x182e <UartRecivePacket+0x52>
    1826:	80 91 35 01 	lds	r24, 0x0135
    182a:	85 30       	cpi	r24, 0x05	; 5
    182c:	c1 f4       	brne	.+48     	; 0x185e <UartRecivePacket+0x82>
			{
				stage++;
    182e:	82 e0       	ldi	r24, 0x02	; 2
    1830:	80 93 36 01 	sts	0x0136, r24
    1834:	80 e0       	ldi	r24, 0x00	; 0
    1836:	08 95       	ret
			}
			break;
		case 2:
			if(timer0 > T15_Ticks)
    1838:	80 91 76 01 	lds	r24, 0x0176
    183c:	8e 30       	cpi	r24, 0x0E	; 14
    183e:	30 f0       	brcs	.+12     	; 0x184c <UartRecivePacket+0x70>
			{
				stage++;
    1840:	83 e0       	ldi	r24, 0x03	; 3
    1842:	80 93 36 01 	sts	0x0136, r24
				state0=State_WAITING;
    1846:	85 e0       	ldi	r24, 0x05	; 5
    1848:	80 93 35 01 	sts	0x0135, r24
			}
		case 3:
			if(timer0 > T35_Ticks)
    184c:	80 91 76 01 	lds	r24, 0x0176
    1850:	8d 31       	cpi	r24, 0x1D	; 29
    1852:	28 f0       	brcs	.+10     	; 0x185e <UartRecivePacket+0x82>
			{
				stage = 0;
    1854:	10 92 36 01 	sts	0x0136, r1
				return BufferSize0;
    1858:	80 91 34 01 	lds	r24, 0x0134
    185c:	08 95       	ret
    185e:	80 e0       	ldi	r24, 0x00	; 0
			}	
			break;

	}
	return 0;
}
    1860:	08 95       	ret

00001862 <__vector_18>:

//обработка прерывани€ приЄма данных в UART
SIGNAL(USART_RX_vect)
{
    1862:	1f 92       	push	r1
    1864:	0f 92       	push	r0
    1866:	0f b6       	in	r0, 0x3f	; 63
    1868:	0f 92       	push	r0
    186a:	11 24       	eor	r1, r1
    186c:	8f 93       	push	r24
    186e:	9f 93       	push	r25
    1870:	ef 93       	push	r30
    1872:	ff 93       	push	r31

	byte temp = *pUDR0;
    1874:	e0 91 73 02 	lds	r30, 0x0273
    1878:	f0 91 74 02 	lds	r31, 0x0274
    187c:	90 81       	ld	r25, Z
	//≈сли находимс€ между 1.5 и 3.5 временными интервалами
	if (state0 == State_WAITING)
    187e:	80 91 35 01 	lds	r24, 0x0135
    1882:	85 30       	cpi	r24, 0x05	; 5
    1884:	19 f4       	brne	.+6      	; 0x188c <__vector_18+0x2a>
	{
		//очистить буфер и выйти
		BufferSize0 = 0;
    1886:	10 92 34 01 	sts	0x0134, r1
    188a:	1e c0       	rjmp	.+60     	; 0x18c8 <__vector_18+0x66>
		return;
	}
	//≈сли не в состо€нии инициализации
	if (state0 != State_INITIAL)
    188c:	80 91 35 01 	lds	r24, 0x0135
    1890:	88 23       	and	r24, r24
    1892:	c1 f0       	breq	.+48     	; 0x18c4 <__vector_18+0x62>
	{
		if (BufferSize0 == 0) state0=State_RECEIVING;//ѕерейти в состо€ние приЄма
    1894:	80 91 34 01 	lds	r24, 0x0134
    1898:	88 23       	and	r24, r24
    189a:	19 f4       	brne	.+6      	; 0x18a2 <__vector_18+0x40>
    189c:	82 e0       	ldi	r24, 0x02	; 2
    189e:	80 93 35 01 	sts	0x0135, r24
		DataBuffer0[ BufferSize0++ ] = temp; //считать полученные данные в буфер
    18a2:	80 91 34 01 	lds	r24, 0x0134
    18a6:	e8 2f       	mov	r30, r24
    18a8:	f0 e0       	ldi	r31, 0x00	; 0
    18aa:	e9 58       	subi	r30, 0x89	; 137
    18ac:	fe 4f       	sbci	r31, 0xFE	; 254
    18ae:	90 83       	st	Z, r25
    18b0:	8f 5f       	subi	r24, 0xFF	; 255
    18b2:	80 93 34 01 	sts	0x0134, r24
		if(BufferSize0 >= USART_PACKET_MAX_LENGHT)//если размер буфера превысил максимальное значение
    18b6:	80 91 34 01 	lds	r24, 0x0134
    18ba:	8a 3f       	cpi	r24, 0xFA	; 250
    18bc:	18 f0       	brcs	.+6      	; 0x18c4 <__vector_18+0x62>
			state0 = State_WAITING;//перейти в состо€ние ожидани€
    18be:	85 e0       	ldi	r24, 0x05	; 5
    18c0:	80 93 35 01 	sts	0x0135, r24
extern byte hostID0;

static inline void StartModbusTimer0(void)
{
	//«апуск таймера
	timer0 = 0;
    18c4:	10 92 76 01 	sts	0x0176, r1
	}
	StartModbusTimer0();//запуск таймера
}
    18c8:	ff 91       	pop	r31
    18ca:	ef 91       	pop	r30
    18cc:	9f 91       	pop	r25
    18ce:	8f 91       	pop	r24
    18d0:	0f 90       	pop	r0
    18d2:	0f be       	out	0x3f, r0	; 63
    18d4:	0f 90       	pop	r0
    18d6:	1f 90       	pop	r1
    18d8:	18 95       	reti

000018da <__vector_20>:

SIGNAL(USART_TX_vect)
{
    18da:	1f 92       	push	r1
    18dc:	0f 92       	push	r0
    18de:	0f b6       	in	r0, 0x3f	; 63
    18e0:	0f 92       	push	r0
    18e2:	11 24       	eor	r1, r1
    18e4:	8f 93       	push	r24
    18e6:	ef 93       	push	r30
    18e8:	ff 93       	push	r31
	cbi(UCSR0B, TXCIE0);
    18ea:	e1 ec       	ldi	r30, 0xC1	; 193
    18ec:	f0 e0       	ldi	r31, 0x00	; 0
    18ee:	80 81       	ld	r24, Z
    18f0:	8f 7b       	andi	r24, 0xBF	; 191
    18f2:	80 83       	st	Z, r24
__ALSO_VAR__ volatile byte BufferSize0 = 0;

__ALSO_VAR__ volatile byte state0 = State_INITIAL;

void SET_DE485_0(void){ cbi(UCSR0B, RXEN0); sbi(PORT_DE, PIN_DE); }
void CLR_DE485_0(void){ cbi(PORT_DE, PIN_DE); sbi(UCSR0B, RXEN0); }
    18f4:	5a 98       	cbi	0x0b, 2	; 11
    18f6:	80 81       	ld	r24, Z
    18f8:	80 61       	ori	r24, 0x10	; 16
    18fa:	80 83       	st	Z, r24

SIGNAL(USART_TX_vect)
{
	cbi(UCSR0B, TXCIE0);
	CLR_DE485_0();
	state0 = State_IDLE; //”становить состо€ние инициализации	
    18fc:	81 e0       	ldi	r24, 0x01	; 1
    18fe:	80 93 35 01 	sts	0x0135, r24
    1902:	10 92 76 01 	sts	0x0176, r1
	StartModbusTimer0();
}
    1906:	ff 91       	pop	r31
    1908:	ef 91       	pop	r30
    190a:	8f 91       	pop	r24
    190c:	0f 90       	pop	r0
    190e:	0f be       	out	0x3f, r0	; 63
    1910:	0f 90       	pop	r0
    1912:	1f 90       	pop	r1
    1914:	18 95       	reti

00001916 <__vector_19>:

SIGNAL(USART_UDRE_vect)
{
    1916:	1f 92       	push	r1
    1918:	0f 92       	push	r0
    191a:	0f b6       	in	r0, 0x3f	; 63
    191c:	0f 92       	push	r0
    191e:	11 24       	eor	r1, r1
    1920:	8f 93       	push	r24
    1922:	9f 93       	push	r25
    1924:	af 93       	push	r26
    1926:	bf 93       	push	r27
    1928:	ef 93       	push	r30
    192a:	ff 93       	push	r31

	*pUDR0 = *pBuf0; /* start transmition */
    192c:	a0 91 73 02 	lds	r26, 0x0273
    1930:	b0 91 74 02 	lds	r27, 0x0274
    1934:	e0 91 71 02 	lds	r30, 0x0271
    1938:	f0 91 72 02 	lds	r31, 0x0272
    193c:	80 81       	ld	r24, Z
    193e:	8c 93       	st	X, r24
	pBuf0++;
    1940:	80 91 71 02 	lds	r24, 0x0271
    1944:	90 91 72 02 	lds	r25, 0x0272
    1948:	01 96       	adiw	r24, 0x01	; 1
    194a:	90 93 72 02 	sts	0x0272, r25
    194e:	80 93 71 02 	sts	0x0271, r24
	BufferSize0--;
    1952:	80 91 34 01 	lds	r24, 0x0134
    1956:	81 50       	subi	r24, 0x01	; 1
    1958:	80 93 34 01 	sts	0x0134, r24
	if(!BufferSize0)
    195c:	80 91 34 01 	lds	r24, 0x0134
    1960:	88 23       	and	r24, r24
    1962:	69 f4       	brne	.+26     	; 0x197e <__vector_19+0x68>
	{
		cbi(UCR0, UDRIE0); /* disable UDRE interrupt */
    1964:	e0 91 73 02 	lds	r30, 0x0273
    1968:	f0 91 74 02 	lds	r31, 0x0274
    196c:	35 97       	sbiw	r30, 0x05	; 5
    196e:	80 81       	ld	r24, Z
    1970:	8f 7d       	andi	r24, 0xDF	; 223
    1972:	80 83       	st	Z, r24
		sbi(UCSR0B,TXCIE0);
    1974:	80 91 c1 00 	lds	r24, 0x00C1
    1978:	80 64       	ori	r24, 0x40	; 64
    197a:	80 93 c1 00 	sts	0x00C1, r24
	}
}
    197e:	ff 91       	pop	r31
    1980:	ef 91       	pop	r30
    1982:	bf 91       	pop	r27
    1984:	af 91       	pop	r26
    1986:	9f 91       	pop	r25
    1988:	8f 91       	pop	r24
    198a:	0f 90       	pop	r0
    198c:	0f be       	out	0x3f, r0	; 63
    198e:	0f 90       	pop	r0
    1990:	1f 90       	pop	r1
    1992:	18 95       	reti

00001994 <get_double_P>:

__ATTR_EEPROM__ byte  EEP_ID0 = 99;	
__ATTR_EEPROM__ unsigned long   EEP_Boudrate0 = DEFAULT_BAUDRATE;

double get_double_P(PGM_VOID_P p)
{
    1994:	df 93       	push	r29
    1996:	cf 93       	push	r28
    1998:	00 d0       	rcall	.+0      	; 0x199a <get_double_P+0x6>
    199a:	00 d0       	rcall	.+0      	; 0x199c <get_double_P+0x8>
    199c:	cd b7       	in	r28, 0x3d	; 61
    199e:	de b7       	in	r29, 0x3e	; 62
    19a0:	bc 01       	movw	r22, r24
	double temp;
	memcpy_P(&temp, p, sizeof(temp));
    19a2:	ce 01       	movw	r24, r28
    19a4:	01 96       	adiw	r24, 0x01	; 1
    19a6:	44 e0       	ldi	r20, 0x04	; 4
    19a8:	50 e0       	ldi	r21, 0x00	; 0
    19aa:	0e 94 63 19 	call	0x32c6	; 0x32c6 <memcpy_P>
	return temp;
}
    19ae:	29 81       	ldd	r18, Y+1	; 0x01
    19b0:	3a 81       	ldd	r19, Y+2	; 0x02
    19b2:	4b 81       	ldd	r20, Y+3	; 0x03
    19b4:	5c 81       	ldd	r21, Y+4	; 0x04
    19b6:	b9 01       	movw	r22, r18
    19b8:	ca 01       	movw	r24, r20
    19ba:	0f 90       	pop	r0
    19bc:	0f 90       	pop	r0
    19be:	0f 90       	pop	r0
    19c0:	0f 90       	pop	r0
    19c2:	cf 91       	pop	r28
    19c4:	df 91       	pop	r29
    19c6:	08 95       	ret

000019c8 <LedTimerInit>:
volatile unsigned char Flashed = 0;

inline void LedTimerInit(void)
{
   
}
    19c8:	08 95       	ret

000019ca <ErrorProcess>:

inline void ErrorProcess(unsigned char dotError, unsigned char rOutError)
{
    if (dotError != ERROR_OK)
    19ca:	88 23       	and	r24, r24
    19cc:	19 f4       	brne	.+6      	; 0x19d4 <ErrorProcess+0xa>
    {
        INDICATE_ERROR(dotError);
        return;
    }
    
    if (rOutError != ERROR_OK)
    19ce:	66 23       	and	r22, r22
    19d0:	39 f0       	breq	.+14     	; 0x19e0 <ErrorProcess+0x16>
    {
        INDICATE_ERROR(rOutError);
    19d2:	86 2f       	mov	r24, r22
    19d4:	90 e0       	ldi	r25, 0x00	; 0
    19d6:	88 0f       	add	r24, r24
    19d8:	99 1f       	adc	r25, r25
    19da:	80 93 01 01 	sts	0x0101, r24
    19de:	08 95       	ret
        return;
    }
    
    INDICATE_ERROR(ERROR_OK);
    19e0:	10 92 01 01 	sts	0x0101, r1
    19e4:	08 95       	ret

000019e6 <error_led_isr>:
}

void error_led_isr(void)
{	
    if (Delay)
    19e6:	80 91 02 01 	lds	r24, 0x0102
    19ea:	90 91 03 01 	lds	r25, 0x0103
    19ee:	89 2b       	or	r24, r25
    19f0:	31 f0       	breq	.+12     	; 0x19fe <error_led_isr+0x18>
    {
        Delay --;
    19f2:	80 91 02 01 	lds	r24, 0x0102
    19f6:	90 91 03 01 	lds	r25, 0x0103
    19fa:	01 97       	sbiw	r24, 0x01	; 1
    19fc:	17 c0       	rjmp	.+46     	; 0x1a2c <error_led_isr+0x46>
    }
    else
    {
        LED_TOGGLE;
    19fe:	88 b1       	in	r24, 0x08	; 8
    1a00:	92 e0       	ldi	r25, 0x02	; 2
    1a02:	89 27       	eor	r24, r25
    1a04:	88 b9       	out	0x08, r24	; 8
        Flashed ++;
    1a06:	80 91 37 01 	lds	r24, 0x0137
    1a0a:	8f 5f       	subi	r24, 0xFF	; 255
    1a0c:	80 93 37 01 	sts	0x0137, r24
        
        if (Flashed >= FlashCount)
    1a10:	90 91 37 01 	lds	r25, 0x0137
    1a14:	80 91 01 01 	lds	r24, 0x0101
    1a18:	98 17       	cp	r25, r24
    1a1a:	30 f0       	brcs	.+12     	; 0x1a28 <error_led_isr+0x42>
        {
            LED_ON;
    1a1c:	41 98       	cbi	0x08, 1	; 8
            Flashed = 0;
    1a1e:	10 92 37 01 	sts	0x0137, r1
            Delay = BETWEN_GROUP_DELAY;
    1a22:	82 ec       	ldi	r24, 0xC2	; 194
    1a24:	91 e0       	ldi	r25, 0x01	; 1
    1a26:	02 c0       	rjmp	.+4      	; 0x1a2c <error_led_isr+0x46>
        }
        else
        {
            Delay = BETWEN_FLASH_DELAY;
    1a28:	83 e4       	ldi	r24, 0x43	; 67
    1a2a:	90 e0       	ldi	r25, 0x00	; 0
    1a2c:	90 93 03 01 	sts	0x0103, r25
    1a30:	80 93 02 01 	sts	0x0102, r24
    1a34:	08 95       	ret

00001a36 <GetFullTanksVolume>:
    
    return sum;
}

double GetFullTanksVolume()
{
    1a36:	8f 92       	push	r8
    1a38:	9f 92       	push	r9
    1a3a:	af 92       	push	r10
    1a3c:	bf 92       	push	r11
    1a3e:	df 92       	push	r13
    1a40:	ef 92       	push	r14
    1a42:	ff 92       	push	r15
    1a44:	0f 93       	push	r16
    1a46:	1f 93       	push	r17
    1a48:	cf 93       	push	r28
    1a4a:	df 93       	push	r29
    1a4c:	dd 24       	eor	r13, r13
    1a4e:	0f 2e       	mov	r0, r31
    1a50:	f0 e0       	ldi	r31, 0x00	; 0
    1a52:	ef 2e       	mov	r14, r31
    1a54:	f0 e0       	ldi	r31, 0x00	; 0
    1a56:	ff 2e       	mov	r15, r31
    1a58:	f0 e0       	ldi	r31, 0x00	; 0
    1a5a:	0f 2f       	mov	r16, r31
    1a5c:	f0 e0       	ldi	r31, 0x00	; 0
    1a5e:	1f 2f       	mov	r17, r31
    1a60:	f0 2d       	mov	r31, r0
    byte i;
    double sum = 0; // чтобы, если у нас нет датчиков небыло делени€ на ноль
    for (i = 0; i < Reverse2(RegFile.mb_struct.dot_info.N); i++)
    {
        unsigned short lastVolume = Reverse2(RegFile.mb_struct.dot_info.DOT[i].N) - 1;
    1a62:	26 e5       	ldi	r18, 0x56	; 86
    1a64:	82 2e       	mov	r8, r18
    1a66:	91 2c       	mov	r9, r1
        sum += (get_double_P(&(ProgramDotTable[i].Vtable[lastVolume])));
    1a68:	9c e3       	ldi	r25, 0x3C	; 60
    1a6a:	a9 2e       	mov	r10, r25
    1a6c:	b1 2c       	mov	r11, r1
    1a6e:	28 c0       	rjmp	.+80     	; 0x1ac0 <GetFullTanksVolume+0x8a>
{
    byte i;
    double sum = 0; // чтобы, если у нас нет датчиков небыло делени€ на ноль
    for (i = 0; i < Reverse2(RegFile.mb_struct.dot_info.N); i++)
    {
        unsigned short lastVolume = Reverse2(RegFile.mb_struct.dot_info.DOT[i].N) - 1;
    1a70:	c8 9d       	mul	r28, r8
    1a72:	f0 01       	movw	r30, r0
    1a74:	c9 9d       	mul	r28, r9
    1a76:	f0 0d       	add	r31, r0
    1a78:	d8 9d       	mul	r29, r8
    1a7a:	f0 0d       	add	r31, r0
    1a7c:	11 24       	eor	r1, r1
    1a7e:	ef 51       	subi	r30, 0x1F	; 31
    1a80:	fd 4f       	sbci	r31, 0xFD	; 253
    1a82:	80 81       	ld	r24, Z
    1a84:	91 81       	ldd	r25, Z+1	; 0x01
    1a86:	0e 94 f4 0f 	call	0x1fe8	; 0x1fe8 <Reverse2>
        sum += (get_double_P(&(ProgramDotTable[i].Vtable[lastVolume])));
    1a8a:	ca 9d       	mul	r28, r10
    1a8c:	90 01       	movw	r18, r0
    1a8e:	cb 9d       	mul	r28, r11
    1a90:	30 0d       	add	r19, r0
    1a92:	da 9d       	mul	r29, r10
    1a94:	30 0d       	add	r19, r0
    1a96:	11 24       	eor	r1, r1
    1a98:	28 0f       	add	r18, r24
    1a9a:	39 1f       	adc	r19, r25
    1a9c:	22 0f       	add	r18, r18
    1a9e:	33 1f       	adc	r19, r19
    1aa0:	22 0f       	add	r18, r18
    1aa2:	33 1f       	adc	r19, r19
    1aa4:	c9 01       	movw	r24, r18
    1aa6:	8c 58       	subi	r24, 0x8C	; 140
    1aa8:	94 4c       	sbci	r25, 0xC4	; 196
    1aaa:	0e 94 ca 0c 	call	0x1994	; 0x1994 <get_double_P>
    1aae:	9b 01       	movw	r18, r22
    1ab0:	ac 01       	movw	r20, r24
    1ab2:	c8 01       	movw	r24, r16
    1ab4:	b7 01       	movw	r22, r14
    1ab6:	0e 94 11 1a 	call	0x3422	; 0x3422 <__addsf3>
    1aba:	7b 01       	movw	r14, r22
    1abc:	8c 01       	movw	r16, r24

double GetFullTanksVolume()
{
    byte i;
    double sum = 0; // чтобы, если у нас нет датчиков небыло делени€ на ноль
    for (i = 0; i < Reverse2(RegFile.mb_struct.dot_info.N); i++)
    1abe:	d3 94       	inc	r13
    1ac0:	80 91 89 02 	lds	r24, 0x0289
    1ac4:	90 91 8a 02 	lds	r25, 0x028A
    1ac8:	0e 94 f4 0f 	call	0x1fe8	; 0x1fe8 <Reverse2>
    1acc:	cd 2d       	mov	r28, r13
    1ace:	d0 e0       	ldi	r29, 0x00	; 0
    1ad0:	c8 17       	cp	r28, r24
    1ad2:	d9 07       	cpc	r29, r25
    1ad4:	68 f2       	brcs	.-102    	; 0x1a70 <GetFullTanksVolume+0x3a>
        unsigned short lastVolume = Reverse2(RegFile.mb_struct.dot_info.DOT[i].N) - 1;
        sum += (get_double_P(&(ProgramDotTable[i].Vtable[lastVolume])));
    }
    
    return sum;
}
    1ad6:	b7 01       	movw	r22, r14
    1ad8:	c8 01       	movw	r24, r16
    1ada:	df 91       	pop	r29
    1adc:	cf 91       	pop	r28
    1ade:	1f 91       	pop	r17
    1ae0:	0f 91       	pop	r16
    1ae2:	ff 90       	pop	r15
    1ae4:	ef 90       	pop	r14
    1ae6:	df 90       	pop	r13
    1ae8:	bf 90       	pop	r11
    1aea:	af 90       	pop	r10
    1aec:	9f 90       	pop	r9
    1aee:	8f 90       	pop	r8
    1af0:	08 95       	ret

00001af2 <get_high_frequency>:
    return (get_double_P(&(ProgramDotTable[dotIndex].Ftable[ 0 ]))); //RegFile.mb_struct.dot_info.DOT[dotIndex].Ftable[ 0 ]); 
}


static inline double get_high_frequency(int dotIndex)
{
    1af2:	0f 93       	push	r16
    1af4:	1f 93       	push	r17
    1af6:	8c 01       	movw	r16, r24
	unsigned short lastVolume = Reverse2(RegFile.mb_struct.dot_info.DOT[dotIndex].N) - 1;
    1af8:	86 e5       	ldi	r24, 0x56	; 86
    1afa:	90 e0       	ldi	r25, 0x00	; 0
    1afc:	08 9f       	mul	r16, r24
    1afe:	f0 01       	movw	r30, r0
    1b00:	09 9f       	mul	r16, r25
    1b02:	f0 0d       	add	r31, r0
    1b04:	18 9f       	mul	r17, r24
    1b06:	f0 0d       	add	r31, r0
    1b08:	11 24       	eor	r1, r1
    1b0a:	ef 51       	subi	r30, 0x1F	; 31
    1b0c:	fd 4f       	sbci	r31, 0xFD	; 253
    1b0e:	80 81       	ld	r24, Z
    1b10:	91 81       	ldd	r25, Z+1	; 0x01
    1b12:	0e 94 f4 0f 	call	0x1fe8	; 0x1fe8 <Reverse2>
    return (get_double_P(&(ProgramDotTable[dotIndex].Ftable[ lastVolume ])));//Reverse4(RegFile.mb_struct.dot_info.DOT[dotIndex].Ftable[lastVolume]); 
    1b16:	2c e3       	ldi	r18, 0x3C	; 60
    1b18:	30 e0       	ldi	r19, 0x00	; 0
    1b1a:	a9 01       	movw	r20, r18
    1b1c:	04 9f       	mul	r16, r20
    1b1e:	90 01       	movw	r18, r0
    1b20:	05 9f       	mul	r16, r21
    1b22:	30 0d       	add	r19, r0
    1b24:	14 9f       	mul	r17, r20
    1b26:	30 0d       	add	r19, r0
    1b28:	11 24       	eor	r1, r1
    1b2a:	28 0f       	add	r18, r24
    1b2c:	39 1f       	adc	r19, r25
    1b2e:	22 0f       	add	r18, r18
    1b30:	33 1f       	adc	r19, r19
    1b32:	22 0f       	add	r18, r18
    1b34:	33 1f       	adc	r19, r19
    1b36:	c9 01       	movw	r24, r18
    1b38:	84 50       	subi	r24, 0x04	; 4
    1b3a:	95 4c       	sbci	r25, 0xC5	; 197
    1b3c:	0e 94 ca 0c 	call	0x1994	; 0x1994 <get_double_P>
}
    1b40:	1f 91       	pop	r17
    1b42:	0f 91       	pop	r16
    1b44:	08 95       	ret

00001b46 <GetDotVolume>:

double VolumePercent = 0;      // Volume from all tanks

// вычисление процента заполнени€ датчика
double GetDotVolume(int dotIndex)
{
    1b46:	2f 92       	push	r2
    1b48:	3f 92       	push	r3
    1b4a:	4f 92       	push	r4
    1b4c:	5f 92       	push	r5
    1b4e:	6f 92       	push	r6
    1b50:	7f 92       	push	r7
    1b52:	8f 92       	push	r8
    1b54:	9f 92       	push	r9
    1b56:	af 92       	push	r10
    1b58:	bf 92       	push	r11
    1b5a:	cf 92       	push	r12
    1b5c:	df 92       	push	r13
    1b5e:	ef 92       	push	r14
    1b60:	ff 92       	push	r15
    1b62:	0f 93       	push	r16
    1b64:	1f 93       	push	r17
    1b66:	df 93       	push	r29
    1b68:	cf 93       	push	r28
    1b6a:	00 d0       	rcall	.+0      	; 0x1b6c <GetDotVolume+0x26>
    1b6c:	00 d0       	rcall	.+0      	; 0x1b6e <GetDotVolume+0x28>
    1b6e:	cd b7       	in	r28, 0x3d	; 61
    1b70:	de b7       	in	r29, 0x3e	; 62
    1b72:	5c 01       	movw	r10, r24
	byte i;
	double  temp;
	double  x, x1, x2, y1, y2;  // ѕеременные используемы дл€ вычислени€ по уравнению пр€мой промежуточного значени€ между двум€ табличными значени€ми ј÷ѕ
	DOT_PARAM * dotParam = &(RegFile.mb_struct.dot_info.DOT[dotIndex]);
    1b74:	86 e5       	ldi	r24, 0x56	; 86
    1b76:	90 e0       	ldi	r25, 0x00	; 0
    1b78:	a8 9e       	mul	r10, r24
    1b7a:	60 01       	movw	r12, r0
    1b7c:	a9 9e       	mul	r10, r25
    1b7e:	d0 0c       	add	r13, r0
    1b80:	b8 9e       	mul	r11, r24
    1b82:	d0 0c       	add	r13, r0
    1b84:	11 24       	eor	r1, r1
    1b86:	8d e8       	ldi	r24, 0x8D	; 141
    1b88:	92 e0       	ldi	r25, 0x02	; 2
    1b8a:	c8 0e       	add	r12, r24
    1b8c:	d9 1e       	adc	r13, r25

	x =	Reverse4(dotParam->frequency);
    1b8e:	f6 01       	movw	r30, r12
    1b90:	60 81       	ld	r22, Z
    1b92:	71 81       	ldd	r23, Z+1	; 0x01
    1b94:	82 81       	ldd	r24, Z+2	; 0x02
    1b96:	93 81       	ldd	r25, Z+3	; 0x03
    1b98:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <Reverse4>
    1b9c:	69 83       	std	Y+1, r22	; 0x01
    1b9e:	7a 83       	std	Y+2, r23	; 0x02
    1ba0:	8b 83       	std	Y+3, r24	; 0x03
    1ba2:	9c 83       	std	Y+4, r25	; 0x04

	// Ќаходим максимально допустимую частоту датчика
	// ¬ообще то она долджна быть DEFAULT_DOT_MAX_FREQ, но если она вдруг задана выше то мы должны это учесть
	temp = get_high_frequency(dotIndex);
    1ba4:	c5 01       	movw	r24, r10
    1ba6:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <get_high_frequency>
    1baa:	7b 01       	movw	r14, r22
    1bac:	8c 01       	movw	r16, r24
	if(temp < DEFAULT_DOT_MAX_FREQ)
    1bae:	20 e0       	ldi	r18, 0x00	; 0
    1bb0:	30 e8       	ldi	r19, 0x80	; 128
    1bb2:	4b eb       	ldi	r20, 0xBB	; 187
    1bb4:	54 e4       	ldi	r21, 0x44	; 68
    1bb6:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__cmpsf2>
    1bba:	88 23       	and	r24, r24
    1bbc:	54 f4       	brge	.+20     	; 0x1bd2 <GetDotVolume+0x8c>
    1bbe:	0f 2e       	mov	r0, r31
    1bc0:	f0 e0       	ldi	r31, 0x00	; 0
    1bc2:	ef 2e       	mov	r14, r31
    1bc4:	f0 e8       	ldi	r31, 0x80	; 128
    1bc6:	ff 2e       	mov	r15, r31
    1bc8:	fb eb       	ldi	r31, 0xBB	; 187
    1bca:	0f 2f       	mov	r16, r31
    1bcc:	f4 e4       	ldi	r31, 0x44	; 68
    1bce:	1f 2f       	mov	r17, r31
    1bd0:	f0 2d       	mov	r31, r0
#define DEFAULT_DOT_MAX_FREQ	1500
//-------------SET--------------------

static inline double get_low_frequency(int dotIndex)
{
    return (get_double_P(&(ProgramDotTable[dotIndex].Ftable[ 0 ]))); //RegFile.mb_struct.dot_info.DOT[dotIndex].Ftable[ 0 ]); 
    1bd2:	80 ef       	ldi	r24, 0xF0	; 240
    1bd4:	90 e0       	ldi	r25, 0x00	; 0
    1bd6:	a8 9e       	mul	r10, r24
    1bd8:	40 01       	movw	r8, r0
    1bda:	a9 9e       	mul	r10, r25
    1bdc:	90 0c       	add	r9, r0
    1bde:	b8 9e       	mul	r11, r24
    1be0:	90 0c       	add	r9, r0
    1be2:	11 24       	eor	r1, r1
    1be4:	80 e0       	ldi	r24, 0x00	; 0
    1be6:	9b e3       	ldi	r25, 0x3B	; 59
    1be8:	88 0e       	add	r8, r24
    1bea:	99 1e       	adc	r9, r25
    1bec:	c4 01       	movw	r24, r8
    1bee:	0e 94 ca 0c 	call	0x1994	; 0x1994 <get_double_P>
		temp = DEFAULT_DOT_MAX_FREQ;

	if (x >= (get_low_frequency(dotIndex) - DOT_DELTA)  && x <= (temp + DOT_DELTA)){
    1bf2:	20 e0       	ldi	r18, 0x00	; 0
    1bf4:	30 e0       	ldi	r19, 0x00	; 0
    1bf6:	48 e4       	ldi	r20, 0x48	; 72
    1bf8:	52 e4       	ldi	r21, 0x42	; 66
    1bfa:	0e 94 10 1a 	call	0x3420	; 0x3420 <__subsf3>
    1bfe:	9b 01       	movw	r18, r22
    1c00:	ac 01       	movw	r20, r24
    1c02:	69 81       	ldd	r22, Y+1	; 0x01
    1c04:	7a 81       	ldd	r23, Y+2	; 0x02
    1c06:	8b 81       	ldd	r24, Y+3	; 0x03
    1c08:	9c 81       	ldd	r25, Y+4	; 0x04
    1c0a:	0e 94 bf 1b 	call	0x377e	; 0x377e <__gesf2>
    1c0e:	88 23       	and	r24, r24
    1c10:	0c f4       	brge	.+2      	; 0x1c14 <GetDotVolume+0xce>
    1c12:	d4 c0       	rjmp	.+424    	; 0x1dbc <GetDotVolume+0x276>
    1c14:	c8 01       	movw	r24, r16
    1c16:	b7 01       	movw	r22, r14
    1c18:	20 e0       	ldi	r18, 0x00	; 0
    1c1a:	30 e0       	ldi	r19, 0x00	; 0
    1c1c:	48 e4       	ldi	r20, 0x48	; 72
    1c1e:	52 e4       	ldi	r21, 0x42	; 66
    1c20:	0e 94 11 1a 	call	0x3422	; 0x3422 <__addsf3>
    1c24:	9b 01       	movw	r18, r22
    1c26:	ac 01       	movw	r20, r24
    1c28:	69 81       	ldd	r22, Y+1	; 0x01
    1c2a:	7a 81       	ldd	r23, Y+2	; 0x02
    1c2c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c2e:	9c 81       	ldd	r25, Y+4	; 0x04
    1c30:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__cmpsf2>
    1c34:	18 16       	cp	r1, r24
    1c36:	0c f4       	brge	.+2      	; 0x1c3a <GetDotVolume+0xf4>
    1c38:	c1 c0       	rjmp	.+386    	; 0x1dbc <GetDotVolume+0x276>
    1c3a:	c4 01       	movw	r24, r8
    1c3c:	0e 94 ca 0c 	call	0x1994	; 0x1994 <get_double_P>
    1c40:	9b 01       	movw	r18, r22
    1c42:	ac 01       	movw	r20, r24
		if(x < get_low_frequency(dotIndex))
    1c44:	69 81       	ldd	r22, Y+1	; 0x01
    1c46:	7a 81       	ldd	r23, Y+2	; 0x02
    1c48:	8b 81       	ldd	r24, Y+3	; 0x03
    1c4a:	9c 81       	ldd	r25, Y+4	; 0x04
    1c4c:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__cmpsf2>
    1c50:	88 23       	and	r24, r24
    1c52:	3c f4       	brge	.+14     	; 0x1c62 <GetDotVolume+0x11c>
    1c54:	c4 01       	movw	r24, r8
    1c56:	0e 94 ca 0c 	call	0x1994	; 0x1994 <get_double_P>
    1c5a:	69 83       	std	Y+1, r22	; 0x01
    1c5c:	7a 83       	std	Y+2, r23	; 0x02
    1c5e:	8b 83       	std	Y+3, r24	; 0x03
    1c60:	9c 83       	std	Y+4, r25	; 0x04
			x = get_low_frequency(dotIndex);
	
		if(x > get_high_frequency(dotIndex))
    1c62:	c5 01       	movw	r24, r10
    1c64:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <get_high_frequency>
    1c68:	9b 01       	movw	r18, r22
    1c6a:	ac 01       	movw	r20, r24
    1c6c:	69 81       	ldd	r22, Y+1	; 0x01
    1c6e:	7a 81       	ldd	r23, Y+2	; 0x02
    1c70:	8b 81       	ldd	r24, Y+3	; 0x03
    1c72:	9c 81       	ldd	r25, Y+4	; 0x04
    1c74:	0e 94 bf 1b 	call	0x377e	; 0x377e <__gesf2>
    1c78:	18 16       	cp	r1, r24
    1c7a:	3c f4       	brge	.+14     	; 0x1c8a <GetDotVolume+0x144>
			x = get_high_frequency(dotIndex);
    1c7c:	c5 01       	movw	r24, r10
    1c7e:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <get_high_frequency>
    1c82:	69 83       	std	Y+1, r22	; 0x01
    1c84:	7a 83       	std	Y+2, r23	; 0x02
    1c86:	8b 83       	std	Y+3, r24	; 0x03
    1c88:	9c 83       	std	Y+4, r25	; 0x04
	else
	{
		return 0;
	}
																									    	
	i = Reverse2(dotParam->N) - 2;
    1c8a:	f6 01       	movw	r30, r12
    1c8c:	ec 5a       	subi	r30, 0xAC	; 172
    1c8e:	ff 4f       	sbci	r31, 0xFF	; 255
    1c90:	80 81       	ld	r24, Z
    1c92:	91 81       	ldd	r25, Z+1	; 0x01
    1c94:	0e 94 f4 0f 	call	0x1fe8	; 0x1fe8 <Reverse2>
    1c98:	08 2f       	mov	r16, r24
    1c9a:	02 50       	subi	r16, 0x02	; 2
	while((x < get_double_P(&(ProgramDotTable[dotIndex].Ftable[i]))) && i > 0) i--; // Ќаходим после какой точки в таблице находитс€ потдерживаемое значение ј÷ѕ
    1c9c:	8c e3       	ldi	r24, 0x3C	; 60
    1c9e:	90 e0       	ldi	r25, 0x00	; 0
    1ca0:	a8 9e       	mul	r10, r24
    1ca2:	60 01       	movw	r12, r0
    1ca4:	a9 9e       	mul	r10, r25
    1ca6:	d0 0c       	add	r13, r0
    1ca8:	b8 9e       	mul	r11, r24
    1caa:	d0 0c       	add	r13, r0
    1cac:	11 24       	eor	r1, r1
    1cae:	01 c0       	rjmp	.+2      	; 0x1cb2 <GetDotVolume+0x16c>
    1cb0:	01 50       	subi	r16, 0x01	; 1
    1cb2:	e0 2e       	mov	r14, r16
    1cb4:	ff 24       	eor	r15, r15
    1cb6:	c7 01       	movw	r24, r14
    1cb8:	8c 0d       	add	r24, r12
    1cba:	9d 1d       	adc	r25, r13
    1cbc:	88 0f       	add	r24, r24
    1cbe:	99 1f       	adc	r25, r25
    1cc0:	88 0f       	add	r24, r24
    1cc2:	99 1f       	adc	r25, r25
    1cc4:	80 50       	subi	r24, 0x00	; 0
    1cc6:	95 4c       	sbci	r25, 0xC5	; 197
    1cc8:	0e 94 ca 0c 	call	0x1994	; 0x1994 <get_double_P>
    1ccc:	9b 01       	movw	r18, r22
    1cce:	ac 01       	movw	r20, r24
    1cd0:	69 81       	ldd	r22, Y+1	; 0x01
    1cd2:	7a 81       	ldd	r23, Y+2	; 0x02
    1cd4:	8b 81       	ldd	r24, Y+3	; 0x03
    1cd6:	9c 81       	ldd	r25, Y+4	; 0x04
    1cd8:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__cmpsf2>
    1cdc:	88 23       	and	r24, r24
    1cde:	14 f4       	brge	.+4      	; 0x1ce4 <GetDotVolume+0x19e>
    1ce0:	00 23       	and	r16, r16
    1ce2:	31 f7       	brne	.-52     	; 0x1cb0 <GetDotVolume+0x16a>
	// ƒалее вычисл€ем по уравнению кривой промежуточное знаение между двум€ табличными
	// “акой подход дает вычисление конкретного значени€ ј÷ѕ приконкретном уровне топлива. “ем самым мы получаем не дискретную систему а непрерывную.
	// “аким образом мы избегаем колебаниие стрелки между двум€ табличными значени€ми
	
    x1 = (get_double_P(&(ProgramDotTable[dotIndex].Ftable[i]))); 
    1ce4:	8c e3       	ldi	r24, 0x3C	; 60
    1ce6:	90 e0       	ldi	r25, 0x00	; 0
    1ce8:	a8 9e       	mul	r10, r24
    1cea:	60 01       	movw	r12, r0
    1cec:	a9 9e       	mul	r10, r25
    1cee:	d0 0c       	add	r13, r0
    1cf0:	b8 9e       	mul	r11, r24
    1cf2:	d0 0c       	add	r13, r0
    1cf4:	11 24       	eor	r1, r1
    1cf6:	ec 0c       	add	r14, r12
    1cf8:	fd 1c       	adc	r15, r13
    1cfa:	ee 0c       	add	r14, r14
    1cfc:	ff 1c       	adc	r15, r15
    1cfe:	ee 0c       	add	r14, r14
    1d00:	ff 1c       	adc	r15, r15
    1d02:	c7 01       	movw	r24, r14
    1d04:	80 50       	subi	r24, 0x00	; 0
    1d06:	95 4c       	sbci	r25, 0xC5	; 197
    1d08:	0e 94 ca 0c 	call	0x1994	; 0x1994 <get_double_P>
    1d0c:	3b 01       	movw	r6, r22
    1d0e:	4c 01       	movw	r8, r24
	x2 = (get_double_P(&(ProgramDotTable[dotIndex].Ftable[i+1])));
    1d10:	10 e0       	ldi	r17, 0x00	; 0
    1d12:	0f 5f       	subi	r16, 0xFF	; 255
    1d14:	1f 4f       	sbci	r17, 0xFF	; 255
    1d16:	0c 0d       	add	r16, r12
    1d18:	1d 1d       	adc	r17, r13
    1d1a:	00 0f       	add	r16, r16
    1d1c:	11 1f       	adc	r17, r17
    1d1e:	00 0f       	add	r16, r16
    1d20:	11 1f       	adc	r17, r17
    1d22:	c8 01       	movw	r24, r16
    1d24:	80 50       	subi	r24, 0x00	; 0
    1d26:	95 4c       	sbci	r25, 0xC5	; 197
    1d28:	0e 94 ca 0c 	call	0x1994	; 0x1994 <get_double_P>
    1d2c:	1b 01       	movw	r2, r22
    1d2e:	2c 01       	movw	r4, r24
	
    y1 = (get_double_P(&(ProgramDotTable[dotIndex].Vtable[i])));
    1d30:	c7 01       	movw	r24, r14
    1d32:	88 58       	subi	r24, 0x88	; 136
    1d34:	94 4c       	sbci	r25, 0xC4	; 196
    1d36:	0e 94 ca 0c 	call	0x1994	; 0x1994 <get_double_P>
    1d3a:	5b 01       	movw	r10, r22
    1d3c:	6c 01       	movw	r12, r24
	y2 = (get_double_P(&(ProgramDotTable[dotIndex].Vtable[i+1])));
    1d3e:	c8 01       	movw	r24, r16
    1d40:	88 58       	subi	r24, 0x88	; 136
    1d42:	94 4c       	sbci	r25, 0xC4	; 196
    1d44:	0e 94 ca 0c 	call	0x1994	; 0x1994 <get_double_P>
	
    temp  = (y2 - y1) * (x - x1);
    1d48:	a6 01       	movw	r20, r12
    1d4a:	95 01       	movw	r18, r10
    1d4c:	0e 94 10 1a 	call	0x3420	; 0x3420 <__subsf3>
    1d50:	7b 01       	movw	r14, r22
    1d52:	8c 01       	movw	r16, r24
    1d54:	69 81       	ldd	r22, Y+1	; 0x01
    1d56:	7a 81       	ldd	r23, Y+2	; 0x02
    1d58:	8b 81       	ldd	r24, Y+3	; 0x03
    1d5a:	9c 81       	ldd	r25, Y+4	; 0x04
    1d5c:	a4 01       	movw	r20, r8
    1d5e:	93 01       	movw	r18, r6
    1d60:	0e 94 10 1a 	call	0x3420	; 0x3420 <__subsf3>
    1d64:	9b 01       	movw	r18, r22
    1d66:	ac 01       	movw	r20, r24
    1d68:	c8 01       	movw	r24, r16
    1d6a:	b7 01       	movw	r22, r14
    1d6c:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__mulsf3>
    1d70:	7b 01       	movw	r14, r22
    1d72:	8c 01       	movw	r16, r24
	temp /= (x2 - x1);
    1d74:	c2 01       	movw	r24, r4
    1d76:	b1 01       	movw	r22, r2
    1d78:	a4 01       	movw	r20, r8
    1d7a:	93 01       	movw	r18, r6
    1d7c:	0e 94 10 1a 	call	0x3420	; 0x3420 <__subsf3>
    1d80:	9b 01       	movw	r18, r22
    1d82:	ac 01       	movw	r20, r24
    1d84:	c8 01       	movw	r24, r16
    1d86:	b7 01       	movw	r22, r14
    1d88:	0e 94 79 1a 	call	0x34f2	; 0x34f2 <__divsf3>
	temp += (y1);
    1d8c:	a6 01       	movw	r20, r12
    1d8e:	95 01       	movw	r18, r10
    1d90:	0e 94 11 1a 	call	0x3422	; 0x3422 <__addsf3>
    1d94:	7b 01       	movw	r14, r22
    1d96:	8c 01       	movw	r16, r24
		
	if(temp > -1.0 && temp < 100000)
    1d98:	20 e0       	ldi	r18, 0x00	; 0
    1d9a:	30 e0       	ldi	r19, 0x00	; 0
    1d9c:	40 e8       	ldi	r20, 0x80	; 128
    1d9e:	5f eb       	ldi	r21, 0xBF	; 191
    1da0:	0e 94 bf 1b 	call	0x377e	; 0x377e <__gesf2>
    1da4:	18 16       	cp	r1, r24
    1da6:	54 f4       	brge	.+20     	; 0x1dbc <GetDotVolume+0x276>
    1da8:	c8 01       	movw	r24, r16
    1daa:	b7 01       	movw	r22, r14
    1dac:	20 e0       	ldi	r18, 0x00	; 0
    1dae:	30 e5       	ldi	r19, 0x50	; 80
    1db0:	43 ec       	ldi	r20, 0xC3	; 195
    1db2:	57 e4       	ldi	r21, 0x47	; 71
    1db4:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__cmpsf2>
    1db8:	88 23       	and	r24, r24
    1dba:	54 f0       	brlt	.+20     	; 0x1dd0 <GetDotVolume+0x28a>
    1dbc:	0f 2e       	mov	r0, r31
    1dbe:	f0 e0       	ldi	r31, 0x00	; 0
    1dc0:	ef 2e       	mov	r14, r31
    1dc2:	f0 e0       	ldi	r31, 0x00	; 0
    1dc4:	ff 2e       	mov	r15, r31
    1dc6:	f0 e0       	ldi	r31, 0x00	; 0
    1dc8:	0f 2f       	mov	r16, r31
    1dca:	f0 e0       	ldi	r31, 0x00	; 0
    1dcc:	1f 2f       	mov	r17, r31
    1dce:	f0 2d       	mov	r31, r0
		return temp;
	return 0;
}
    1dd0:	b7 01       	movw	r22, r14
    1dd2:	c8 01       	movw	r24, r16
    1dd4:	0f 90       	pop	r0
    1dd6:	0f 90       	pop	r0
    1dd8:	0f 90       	pop	r0
    1dda:	0f 90       	pop	r0
    1ddc:	cf 91       	pop	r28
    1dde:	df 91       	pop	r29
    1de0:	1f 91       	pop	r17
    1de2:	0f 91       	pop	r16
    1de4:	ff 90       	pop	r15
    1de6:	ef 90       	pop	r14
    1de8:	df 90       	pop	r13
    1dea:	cf 90       	pop	r12
    1dec:	bf 90       	pop	r11
    1dee:	af 90       	pop	r10
    1df0:	9f 90       	pop	r9
    1df2:	8f 90       	pop	r8
    1df4:	7f 90       	pop	r7
    1df6:	6f 90       	pop	r6
    1df8:	5f 90       	pop	r5
    1dfa:	4f 90       	pop	r4
    1dfc:	3f 90       	pop	r3
    1dfe:	2f 90       	pop	r2
    1e00:	08 95       	ret

00001e02 <GetAllDotsVolume>:

double GetAllDotsVolume()
{
    1e02:	df 92       	push	r13
    1e04:	ef 92       	push	r14
    1e06:	ff 92       	push	r15
    1e08:	0f 93       	push	r16
    1e0a:	1f 93       	push	r17
    1e0c:	dd 24       	eor	r13, r13
    1e0e:	0f 2e       	mov	r0, r31
    1e10:	f0 e0       	ldi	r31, 0x00	; 0
    1e12:	ef 2e       	mov	r14, r31
    1e14:	f0 e0       	ldi	r31, 0x00	; 0
    1e16:	ff 2e       	mov	r15, r31
    1e18:	f0 e0       	ldi	r31, 0x00	; 0
    1e1a:	0f 2f       	mov	r16, r31
    1e1c:	f0 e0       	ldi	r31, 0x00	; 0
    1e1e:	1f 2f       	mov	r17, r31
    1e20:	f0 2d       	mov	r31, r0
    1e22:	0d c0       	rjmp	.+26     	; 0x1e3e <GetAllDotsVolume+0x3c>
    byte i;
    double sum = 0;
    for (i = 0; i < Reverse2(RegFile.mb_struct.dot_info.N); i++)
    {
        sum += GetDotVolume(i);
    1e24:	8d 2d       	mov	r24, r13
    1e26:	90 e0       	ldi	r25, 0x00	; 0
    1e28:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <GetDotVolume>
    1e2c:	9b 01       	movw	r18, r22
    1e2e:	ac 01       	movw	r20, r24
    1e30:	c8 01       	movw	r24, r16
    1e32:	b7 01       	movw	r22, r14
    1e34:	0e 94 11 1a 	call	0x3422	; 0x3422 <__addsf3>
    1e38:	7b 01       	movw	r14, r22
    1e3a:	8c 01       	movw	r16, r24

double GetAllDotsVolume()
{
    byte i;
    double sum = 0;
    for (i = 0; i < Reverse2(RegFile.mb_struct.dot_info.N); i++)
    1e3c:	d3 94       	inc	r13
    1e3e:	80 91 89 02 	lds	r24, 0x0289
    1e42:	90 91 8a 02 	lds	r25, 0x028A
    1e46:	0e 94 f4 0f 	call	0x1fe8	; 0x1fe8 <Reverse2>
    1e4a:	2d 2d       	mov	r18, r13
    1e4c:	30 e0       	ldi	r19, 0x00	; 0
    1e4e:	28 17       	cp	r18, r24
    1e50:	39 07       	cpc	r19, r25
    1e52:	40 f3       	brcs	.-48     	; 0x1e24 <GetAllDotsVolume+0x22>
    {
        sum += GetDotVolume(i);
    }
    
    return sum;
}
    1e54:	b7 01       	movw	r22, r14
    1e56:	c8 01       	movw	r24, r16
    1e58:	1f 91       	pop	r17
    1e5a:	0f 91       	pop	r16
    1e5c:	ff 90       	pop	r15
    1e5e:	ef 90       	pop	r14
    1e60:	df 90       	pop	r13
    1e62:	08 95       	ret

00001e64 <GetFuelPercent>:
    
    return sum;
}

inline double GetFuelPercent(void)
{
    1e64:	ef 92       	push	r14
    1e66:	ff 92       	push	r15
    1e68:	0f 93       	push	r16
    1e6a:	1f 93       	push	r17
	double temp = GetAllDotsVolume() / GetFullTanksVolume() ;
    1e6c:	0e 94 01 0f 	call	0x1e02	; 0x1e02 <GetAllDotsVolume>
    1e70:	7b 01       	movw	r14, r22
    1e72:	8c 01       	movw	r16, r24
    1e74:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <GetFullTanksVolume>
    1e78:	9b 01       	movw	r18, r22
    1e7a:	ac 01       	movw	r20, r24
    1e7c:	c8 01       	movw	r24, r16
    1e7e:	b7 01       	movw	r22, r14
    1e80:	0e 94 79 1a 	call	0x34f2	; 0x34f2 <__divsf3>
    1e84:	7b 01       	movw	r14, r22
    1e86:	8c 01       	movw	r16, r24
	if(temp > -1.0 && temp < 2)
    1e88:	20 e0       	ldi	r18, 0x00	; 0
    1e8a:	30 e0       	ldi	r19, 0x00	; 0
    1e8c:	40 e8       	ldi	r20, 0x80	; 128
    1e8e:	5f eb       	ldi	r21, 0xBF	; 191
    1e90:	0e 94 bf 1b 	call	0x377e	; 0x377e <__gesf2>
    1e94:	18 16       	cp	r1, r24
    1e96:	54 f4       	brge	.+20     	; 0x1eac <GetFuelPercent+0x48>
    1e98:	c8 01       	movw	r24, r16
    1e9a:	b7 01       	movw	r22, r14
    1e9c:	20 e0       	ldi	r18, 0x00	; 0
    1e9e:	30 e0       	ldi	r19, 0x00	; 0
    1ea0:	40 e0       	ldi	r20, 0x00	; 0
    1ea2:	50 e4       	ldi	r21, 0x40	; 64
    1ea4:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__cmpsf2>
    1ea8:	87 fd       	sbrc	r24, 7
    1eaa:	0a c0       	rjmp	.+20     	; 0x1ec0 <GetFuelPercent+0x5c>
    1eac:	0f 2e       	mov	r0, r31
    1eae:	f0 e0       	ldi	r31, 0x00	; 0
    1eb0:	ef 2e       	mov	r14, r31
    1eb2:	f0 e0       	ldi	r31, 0x00	; 0
    1eb4:	ff 2e       	mov	r15, r31
    1eb6:	f0 e0       	ldi	r31, 0x00	; 0
    1eb8:	0f 2f       	mov	r16, r31
    1eba:	f0 e0       	ldi	r31, 0x00	; 0
    1ebc:	1f 2f       	mov	r17, r31
    1ebe:	f0 2d       	mov	r31, r0
		return temp;
	return 0;

}
    1ec0:	b7 01       	movw	r22, r14
    1ec2:	c8 01       	movw	r24, r16
    1ec4:	1f 91       	pop	r17
    1ec6:	0f 91       	pop	r16
    1ec8:	ff 90       	pop	r15
    1eca:	ef 90       	pop	r14
    1ecc:	08 95       	ret

00001ece <DotsProcess>:
static unsigned char dotState[MAX_DOT_COUNT];

void set_Freq(double freq);

inline unsigned char  DotsProcess()
{
    1ece:	bf 92       	push	r11
    1ed0:	cf 92       	push	r12
    1ed2:	df 92       	push	r13
    1ed4:	ef 92       	push	r14
    1ed6:	ff 92       	push	r15
    1ed8:	0f 93       	push	r16
    1eda:	1f 93       	push	r17
    1edc:	cf 93       	push	r28
    1ede:	df 93       	push	r29
   	
	unsigned short dotIndex;
	unsigned short dotCount = Reverse2(RegFile.mb_struct.dot_info.N);
    1ee0:	80 91 89 02 	lds	r24, 0x0289
    1ee4:	90 91 8a 02 	lds	r25, 0x028A
    1ee8:	0e 94 f4 0f 	call	0x1fe8	; 0x1fe8 <Reverse2>
    1eec:	6c 01       	movw	r12, r24
	double generatorFrequency;

#ifdef FREQUENCY_INPUT		
	FrequancyMeasure();
    1eee:	0e 94 f3 06 	call	0xde6	; 0xde6 <FrequancyMeasure>
    1ef2:	cc e3       	ldi	r28, 0x3C	; 60
    1ef4:	d1 e0       	ldi	r29, 0x01	; 1
    1ef6:	0d e8       	ldi	r16, 0x8D	; 141
    1ef8:	12 e0       	ldi	r17, 0x02	; 2

#ifdef ANALOG_INPUT
	AnalogDotMeasure();
#endif

    for (dotIndex = 0; dotIndex < dotCount; dotIndex ++)
    1efa:	7e 01       	movw	r14, r28
    1efc:	ec 0c       	add	r14, r12
    1efe:	fd 1c       	adc	r15, r13
    {
		dotState[dotIndex] = ERROR_OK;
		generatorFrequency = Reverse4(RegFile.mb_struct.dot_info.DOT[dotIndex].frequency);
#ifdef FREQUENCY_INPUT
		if(generatorFrequency < 1)
			dotState[dotIndex] = RS_DOT_STATE_TIMEOUT;
    1f00:	a3 e0       	ldi	r26, 0x03	; 3
    1f02:	ba 2e       	mov	r11, r26
    1f04:	14 c0       	rjmp	.+40     	; 0x1f2e <DotsProcess+0x60>
	AnalogDotMeasure();
#endif

    for (dotIndex = 0; dotIndex < dotCount; dotIndex ++)
    {
		dotState[dotIndex] = ERROR_OK;
    1f06:	18 82       	st	Y, r1
		generatorFrequency = Reverse4(RegFile.mb_struct.dot_info.DOT[dotIndex].frequency);
    1f08:	f8 01       	movw	r30, r16
    1f0a:	60 81       	ld	r22, Z
    1f0c:	71 81       	ldd	r23, Z+1	; 0x01
    1f0e:	82 81       	ldd	r24, Z+2	; 0x02
    1f10:	93 81       	ldd	r25, Z+3	; 0x03
    1f12:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <Reverse4>
#ifdef FREQUENCY_INPUT
		if(generatorFrequency < 1)
    1f16:	20 e0       	ldi	r18, 0x00	; 0
    1f18:	30 e0       	ldi	r19, 0x00	; 0
    1f1a:	40 e8       	ldi	r20, 0x80	; 128
    1f1c:	5f e3       	ldi	r21, 0x3F	; 63
    1f1e:	0e 94 75 1a 	call	0x34ea	; 0x34ea <__cmpsf2>
    1f22:	88 23       	and	r24, r24
    1f24:	0c f4       	brge	.+2      	; 0x1f28 <DotsProcess+0x5a>
			dotState[dotIndex] = RS_DOT_STATE_TIMEOUT;
    1f26:	b8 82       	st	Y, r11
    1f28:	21 96       	adiw	r28, 0x01	; 1
    1f2a:	0a 5a       	subi	r16, 0xAA	; 170
    1f2c:	1f 4f       	sbci	r17, 0xFF	; 255

#ifdef ANALOG_INPUT
	AnalogDotMeasure();
#endif

    for (dotIndex = 0; dotIndex < dotCount; dotIndex ++)
    1f2e:	ce 15       	cp	r28, r14
    1f30:	df 05       	cpc	r29, r15
    1f32:	49 f7       	brne	.-46     	; 0x1f06 <DotsProcess+0x38>
		if(generatorFrequency < 1)
			dotState[dotIndex] = RS_DOT_STATE_TIMEOUT;
#endif				
    }

	VolumePercent = GetFuelPercent();
    1f34:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <GetFuelPercent>
    1f38:	60 93 38 01 	sts	0x0138, r22
    1f3c:	70 93 39 01 	sts	0x0139, r23
    1f40:	80 93 3a 01 	sts	0x013A, r24
    1f44:	90 93 3b 01 	sts	0x013B, r25
	RegFile.mb_struct.VolumePercent = Reverse4(VolumePercent);
    1f48:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <Reverse4>
    1f4c:	60 93 7d 02 	sts	0x027D, r22
    1f50:	70 93 7e 02 	sts	0x027E, r23
    1f54:	80 93 7f 02 	sts	0x027F, r24
    1f58:	90 93 80 02 	sts	0x0280, r25
    1f5c:	20 e0       	ldi	r18, 0x00	; 0
    1f5e:	30 e0       	ldi	r19, 0x00	; 0
    1f60:	0b c0       	rjmp	.+22     	; 0x1f78 <DotsProcess+0xaa>

	for (dotIndex = 0; dotIndex < dotCount; dotIndex ++)
	{
		if (dotState[dotIndex] == RS_DOT_STATE_TIMEOUT)
    1f62:	f9 01       	movw	r30, r18
    1f64:	e4 5c       	subi	r30, 0xC4	; 196
    1f66:	fe 4f       	sbci	r31, 0xFE	; 254
    1f68:	80 81       	ld	r24, Z
    1f6a:	83 30       	cpi	r24, 0x03	; 3
    1f6c:	19 f4       	brne	.+6      	; 0x1f74 <DotsProcess+0xa6>
					return ERROR_DOT + dotIndex;
    1f6e:	82 2f       	mov	r24, r18
    1f70:	8e 5f       	subi	r24, 0xFE	; 254
    1f72:	06 c0       	rjmp	.+12     	; 0x1f80 <DotsProcess+0xb2>
    }

	VolumePercent = GetFuelPercent();
	RegFile.mb_struct.VolumePercent = Reverse4(VolumePercent);

	for (dotIndex = 0; dotIndex < dotCount; dotIndex ++)
    1f74:	2f 5f       	subi	r18, 0xFF	; 255
    1f76:	3f 4f       	sbci	r19, 0xFF	; 255
    1f78:	2c 15       	cp	r18, r12
    1f7a:	3d 05       	cpc	r19, r13
    1f7c:	90 f3       	brcs	.-28     	; 0x1f62 <DotsProcess+0x94>
    1f7e:	80 e0       	ldi	r24, 0x00	; 0
		if (dotState[dotIndex] == RS_DOT_STATE_TIMEOUT)
					return ERROR_DOT + dotIndex;
	}
		
	return ERROR_OK;
}
    1f80:	df 91       	pop	r29
    1f82:	cf 91       	pop	r28
    1f84:	1f 91       	pop	r17
    1f86:	0f 91       	pop	r16
    1f88:	ff 90       	pop	r15
    1f8a:	ef 90       	pop	r14
    1f8c:	df 90       	pop	r13
    1f8e:	cf 90       	pop	r12
    1f90:	bf 90       	pop	r11
    1f92:	08 95       	ret

00001f94 <mem_reverce>:

void mem_reverce(void *data, unsigned char count)
{
	unsigned char i;
	byte temp;
	for(i = 0; i < count/2; i++)
    1f94:	36 2f       	mov	r19, r22
    1f96:	36 95       	lsr	r19
    1f98:	dc 01       	movw	r26, r24
    1f9a:	e6 2f       	mov	r30, r22
    1f9c:	f0 e0       	ldi	r31, 0x00	; 0
    1f9e:	31 97       	sbiw	r30, 0x01	; 1
    1fa0:	e8 0f       	add	r30, r24
    1fa2:	f9 1f       	adc	r31, r25
    1fa4:	20 e0       	ldi	r18, 0x00	; 0
    1fa6:	06 c0       	rjmp	.+12     	; 0x1fb4 <mem_reverce+0x20>
	{
		temp = ((unsigned char *)data)[ i ];
    1fa8:	9c 91       	ld	r25, X
		((unsigned char *)data)[ i ] = ((unsigned char *)data)[ count - i - 1 ];
    1faa:	80 81       	ld	r24, Z
    1fac:	8d 93       	st	X+, r24
		((unsigned char *)data)[ count - i -1 ] = temp;
    1fae:	90 83       	st	Z, r25

void mem_reverce(void *data, unsigned char count)
{
	unsigned char i;
	byte temp;
	for(i = 0; i < count/2; i++)
    1fb0:	2f 5f       	subi	r18, 0xFF	; 255
    1fb2:	31 97       	sbiw	r30, 0x01	; 1
    1fb4:	23 17       	cp	r18, r19
    1fb6:	c0 f3       	brcs	.-16     	; 0x1fa8 <mem_reverce+0x14>
	{
		temp = ((unsigned char *)data)[ i ];
		((unsigned char *)data)[ i ] = ((unsigned char *)data)[ count - i - 1 ];
		((unsigned char *)data)[ count - i -1 ] = temp;
	}
}
    1fb8:	08 95       	ret

00001fba <Reverse4>:

inline double Reverse4(double in)
{
    1fba:	df 93       	push	r29
    1fbc:	cf 93       	push	r28
    1fbe:	00 d0       	rcall	.+0      	; 0x1fc0 <Reverse4+0x6>
    1fc0:	00 d0       	rcall	.+0      	; 0x1fc2 <Reverse4+0x8>
    1fc2:	cd b7       	in	r28, 0x3d	; 61
    1fc4:	de b7       	in	r29, 0x3e	; 62
    1fc6:	69 83       	std	Y+1, r22	; 0x01
    1fc8:	7a 83       	std	Y+2, r23	; 0x02
    1fca:	8b 83       	std	Y+3, r24	; 0x03
    1fcc:	9c 83       	std	Y+4, r25	; 0x04
    
    tmp = *p;       *p = *(p + 3);       *(p + 3) = tmp;
    tmp = *(p + 1); *(p + 1) = *(p + 2); *(p + 2) = tmp;

    return in;
}
    1fce:	2c 81       	ldd	r18, Y+4	; 0x04
    1fd0:	3b 81       	ldd	r19, Y+3	; 0x03
    1fd2:	4a 81       	ldd	r20, Y+2	; 0x02
    1fd4:	59 81       	ldd	r21, Y+1	; 0x01
    1fd6:	b9 01       	movw	r22, r18
    1fd8:	ca 01       	movw	r24, r20
    1fda:	0f 90       	pop	r0
    1fdc:	0f 90       	pop	r0
    1fde:	0f 90       	pop	r0
    1fe0:	0f 90       	pop	r0
    1fe2:	cf 91       	pop	r28
    1fe4:	df 91       	pop	r29
    1fe6:	08 95       	ret

00001fe8 <Reverse2>:

inline unsigned short Reverse2(unsigned short in)
{
    1fe8:	df 93       	push	r29
    1fea:	cf 93       	push	r28
    1fec:	00 d0       	rcall	.+0      	; 0x1fee <Reverse2+0x6>
    1fee:	cd b7       	in	r28, 0x3d	; 61
    1ff0:	de b7       	in	r29, 0x3e	; 62
    1ff2:	9a 83       	std	Y+2, r25	; 0x02
    1ff4:	89 83       	std	Y+1, r24	; 0x01
    byte tmp;
    byte * p = (byte *)(&in);
    
    tmp = *p;   *p = *(p + 1);  *(p + 1) = tmp;
    1ff6:	98 2f       	mov	r25, r24

    return in;
}
    1ff8:	8a 81       	ldd	r24, Y+2	; 0x02
    1ffa:	0f 90       	pop	r0
    1ffc:	0f 90       	pop	r0
    1ffe:	cf 91       	pop	r28
    2000:	df 91       	pop	r29
    2002:	08 95       	ret

00002004 <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    2004:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    2006:	f9 99       	sbic	0x1f, 1	; 31
    2008:	fe cf       	rjmp	.-4      	; 0x2006 <eeprom_write_byte+0x2>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    200a:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    200c:	32 bd       	out	0x22, r19	; 34
    200e:	21 bd       	out	0x21, r18	; 33
#endif
    EEDR = __value;
    2010:	60 bd       	out	0x20, r22	; 32

    __asm__ __volatile__ (
    2012:	0f b6       	in	r0, 0x3f	; 63
    2014:	f8 94       	cli
    2016:	fa 9a       	sbi	0x1f, 2	; 31
    2018:	f9 9a       	sbi	0x1f, 1	; 31
    201a:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
    201c:	08 95       	ret

0000201e <SettingsReset>:
#include "reset_fuse.h"

volatile unsigned short ResetTimerCounter = 0;

inline void SettingsReset()
{
    201e:	df 93       	push	r29
    2020:	cf 93       	push	r28
    2022:	00 d0       	rcall	.+0      	; 0x2024 <SettingsReset+0x6>
    2024:	00 d0       	rcall	.+0      	; 0x2026 <SettingsReset+0x8>
    2026:	cd b7       	in	r28, 0x3d	; 61
    2028:	de b7       	in	r29, 0x3e	; 62
    RegFile.mb_struct.Configured = 0;
    202a:	10 92 7c 02 	sts	0x027C, r1
    202e:	10 92 7b 02 	sts	0x027B, r1
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    2032:	80 e0       	ldi	r24, 0x00	; 0
    2034:	90 e0       	ldi	r25, 0x00	; 0
    2036:	65 e7       	ldi	r22, 0x75	; 117
    2038:	72 e0       	ldi	r23, 0x02	; 2
    203a:	48 eb       	ldi	r20, 0xB8	; 184
    203c:	51 e0       	ldi	r21, 0x01	; 1
    203e:	22 e0       	ldi	r18, 0x02	; 2
    2040:	30 e1       	ldi	r19, 0x10	; 16
    2042:	0e 94 b9 19 	call	0x3372	; 0x3372 <__eewr_block>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2046:	f9 99       	sbic	0x1f, 1	; 31
    2048:	fe cf       	rjmp	.-4      	; 0x2046 <SettingsReset+0x28>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    204a:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    204c:	88 eb       	ldi	r24, 0xB8	; 184
    204e:	91 e0       	ldi	r25, 0x01	; 1
    2050:	92 bd       	out	0x22, r25	; 34
    2052:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    2054:	83 e6       	ldi	r24, 0x63	; 99
    2056:	80 bd       	out	0x20, r24	; 32

    __asm__ __volatile__ (
    2058:	0f b6       	in	r0, 0x3f	; 63
    205a:	f8 94       	cli
    205c:	fa 9a       	sbi	0x1f, 2	; 31
    205e:	f9 9a       	sbi	0x1f, 1	; 31
    2060:	0f be       	out	0x3f, r0	; 63
    eeprom_write_block(&RegFile, &EepromRegFile, sizeof(REGISTER_FILE));
    
    unsigned long baud = DEFAULT_BAUDRATE;
    2062:	80 e0       	ldi	r24, 0x00	; 0
    2064:	9b e4       	ldi	r25, 0x4B	; 75
    2066:	a0 e0       	ldi	r26, 0x00	; 0
    2068:	b0 e0       	ldi	r27, 0x00	; 0
    206a:	89 83       	std	Y+1, r24	; 0x01
    206c:	9a 83       	std	Y+2, r25	; 0x02
    206e:	ab 83       	std	Y+3, r26	; 0x03
    2070:	bc 83       	std	Y+4, r27	; 0x04
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    2072:	89 eb       	ldi	r24, 0xB9	; 185
    2074:	91 e0       	ldi	r25, 0x01	; 1
    2076:	be 01       	movw	r22, r28
    2078:	6f 5f       	subi	r22, 0xFF	; 255
    207a:	7f 4f       	sbci	r23, 0xFF	; 255
    207c:	44 e0       	ldi	r20, 0x04	; 4
    207e:	50 e0       	ldi	r21, 0x00	; 0
    2080:	22 e0       	ldi	r18, 0x02	; 2
    2082:	30 e1       	ldi	r19, 0x10	; 16
    2084:	0e 94 b9 19 	call	0x3372	; 0x3372 <__eewr_block>

    eeprom_write_byte(&EEP_ID0, 99);
    eeprom_write_block(&baud, &EEP_Boudrate0, sizeof(baud));
    
    InitUART();
    2088:	0e 94 a9 0b 	call	0x1752	; 0x1752 <InitUART>
}
    208c:	0f 90       	pop	r0
    208e:	0f 90       	pop	r0
    2090:	0f 90       	pop	r0
    2092:	0f 90       	pop	r0
    2094:	cf 91       	pop	r28
    2096:	df 91       	pop	r29
    2098:	08 95       	ret

0000209a <ResetFuseProcess>:

inline void ResetFuseProcess()
{
    static unsigned char  ResetFuseProcessing = 0;

    if (RESET_SHORTED && ResetTimerCounter > RESET_TIMER_COUNTER_DELAY && !ResetFuseProcessing )
    209a:	32 99       	sbic	0x06, 2	; 6
    209c:	0e c0       	rjmp	.+28     	; 0x20ba <ResetFuseProcess+0x20>
    209e:	80 91 40 01 	lds	r24, 0x0140
    20a2:	90 91 41 01 	lds	r25, 0x0141
    20a6:	83 53       	subi	r24, 0x33	; 51
    20a8:	92 40       	sbci	r25, 0x02	; 2
    20aa:	38 f0       	brcs	.+14     	; 0x20ba <ResetFuseProcess+0x20>
    20ac:	80 91 42 01 	lds	r24, 0x0142
    20b0:	88 23       	and	r24, r24
    20b2:	19 f4       	brne	.+6      	; 0x20ba <ResetFuseProcess+0x20>
    {
		ResetFuseProcessing = 1; 
    20b4:	81 e0       	ldi	r24, 0x01	; 1
    20b6:	80 93 42 01 	sts	0x0142, r24
    }
    
    if (!RESET_SHORTED)
    20ba:	32 9b       	sbis	0x06, 2	; 6
    20bc:	1e c0       	rjmp	.+60     	; 0x20fa <ResetFuseProcess+0x60>
    {
        ResetTimerCounter = 0;
    20be:	10 92 41 01 	sts	0x0141, r1
    20c2:	10 92 40 01 	sts	0x0140, r1
		
		if ( ResetFuseProcessing )
    20c6:	80 91 42 01 	lds	r24, 0x0142
    20ca:	88 23       	and	r24, r24
    20cc:	b1 f0       	breq	.+44     	; 0x20fa <ResetFuseProcess+0x60>
		{
			ResetFuseProcessing = 0;
    20ce:	10 92 42 01 	sts	0x0142, r1
			cli();
    20d2:	f8 94       	cli
			LED_OFF;
    20d4:	41 9a       	sbi	0x08, 1	; 8
    20d6:	20 e0       	ldi	r18, 0x00	; 0
    20d8:	30 e0       	ldi	r19, 0x00	; 0
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    20da:	40 e0       	ldi	r20, 0x00	; 0
    20dc:	50 e9       	ldi	r21, 0x90	; 144
    20de:	ca 01       	movw	r24, r20
    20e0:	01 97       	sbiw	r24, 0x01	; 1
    20e2:	f1 f7       	brne	.-4      	; 0x20e0 <ResetFuseProcess+0x46>
        	unsigned short i;
			for (i = 0; i < 300; i++)
			{
				_delay_ms(10);
				wdt_reset();
    20e4:	a8 95       	wdr
		{
			ResetFuseProcessing = 0;
			cli();
			LED_OFF;
        	unsigned short i;
			for (i = 0; i < 300; i++)
    20e6:	2f 5f       	subi	r18, 0xFF	; 255
    20e8:	3f 4f       	sbci	r19, 0xFF	; 255
    20ea:	81 e0       	ldi	r24, 0x01	; 1
    20ec:	2c 32       	cpi	r18, 0x2C	; 44
    20ee:	38 07       	cpc	r19, r24
    20f0:	b1 f7       	brne	.-20     	; 0x20de <ResetFuseProcess+0x44>
			{
				_delay_ms(10);
				wdt_reset();
			}

        	SettingsReset();
    20f2:	0e 94 0f 10 	call	0x201e	; 0x201e <SettingsReset>
        	LED_ON;            
    20f6:	41 98       	cbi	0x08, 1	; 8
			sei();
    20f8:	78 94       	sei
    20fa:	08 95       	ret

000020fc <OmniComm_Check_old_frame>:
	return(OMNICOMM_FRAME_ERROR);
}

unsigned char OmniComm_Check_old_frame (void)	//функци€ провер€ет пакет и возвращает
{				
	if(DataBuffer0[0]==OMNICOMM_OLD_PREFIX)
    20fc:	80 91 77 01 	lds	r24, 0x0177
    2100:	84 34       	cpi	r24, 0x44	; 68
    2102:	89 f4       	brne	.+34     	; 0x2126 <OmniComm_Check_old_frame+0x2a>
	{
		if(DataBuffer0[1] == 0x4F)
    2104:	80 91 78 01 	lds	r24, 0x0178
    2108:	8f 34       	cpi	r24, 0x4F	; 79
    210a:	11 f4       	brne	.+4      	; 0x2110 <OmniComm_Check_old_frame+0x14>
		{
			omnicomm_cmd = DATA_READ_OLD;
    210c:	88 e7       	ldi	r24, 0x78	; 120
    210e:	03 c0       	rjmp	.+6      	; 0x2116 <OmniComm_Check_old_frame+0x1a>
	 		omnicomm_addr = MBClientGetHostID0();
			return(OMNICOMM_FRAME_OK);	
		}
		if(DataBuffer0[1] == 0x50)
    2110:	80 35       	cpi	r24, 0x50	; 80
    2112:	49 f4       	brne	.+18     	; 0x2126 <OmniComm_Check_old_frame+0x2a>
		{
			omnicomm_cmd = DATA_CONTIN_OLD;
    2114:	89 e7       	ldi	r24, 0x79	; 121
    2116:	80 93 34 04 	sts	0x0434, r24
			omnicomm_addr = MBClientGetHostID0();
    211a:	80 91 00 01 	lds	r24, 0x0100
    211e:	80 93 35 04 	sts	0x0435, r24
    2122:	84 e0       	ldi	r24, 0x04	; 4
    2124:	08 95       	ret
			return(OMNICOMM_FRAME_OK);
    2126:	83 e0       	ldi	r24, 0x03	; 3
		}	
	}
	return(OMNICOMM_FRAME_ERROR);
}
    2128:	08 95       	ret

0000212a <OmniComm_Send_frame_old_data>:
}

void OmniComm_Send_frame_old_data (void)	//перед вызовом этой функции в omnicomm_frame_size нужно записать размер пакета (количество байт в пакете,
{								//учитыва€ префикс и crc)
	
	omnicomm_status = OMNICOMM_BUSY;//"зан€ли" протокол
    212a:	10 92 32 04 	sts	0x0432, r1
	SET_DE485_0();//включили режим передачи
    212e:	0e 94 9b 0b 	call	0x1736	; 0x1736 <SET_DE485_0>

	pBuf0 = DataBuffer0;
    2132:	87 e7       	ldi	r24, 0x77	; 119
    2134:	91 e0       	ldi	r25, 0x01	; 1
    2136:	90 93 72 02 	sts	0x0272, r25
    213a:	80 93 71 02 	sts	0x0271, r24
	BufferSize0 = omnicomm_frame_size;
    213e:	80 91 33 04 	lds	r24, 0x0433
    2142:	80 93 34 01 	sts	0x0134, r24
	UCSR0B |= (1 << UDRIE0);		//—“ј–“ передачи. ƒальнейша€ передача будет
    2146:	80 91 c1 00 	lds	r24, 0x00C1
    214a:	80 62       	ori	r24, 0x20	; 32
    214c:	80 93 c1 00 	sts	0x00C1, r24
								//происходить по прерыванию USART_RX_vect
	while (!(UCSR0B & (1 << RXEN0)));			//пока не очиститс€ буфер.
    2150:	80 91 c1 00 	lds	r24, 0x00C1
    2154:	84 ff       	sbrs	r24, 4
    2156:	fc cf       	rjmp	.-8      	; 0x2150 <OmniComm_Send_frame_old_data+0x26>
}
    2158:	08 95       	ret

0000215a <OmniComm_Do_crc>:
	}
}


unsigned char OmniComm_Do_crc (unsigned char frame_size)
{
    215a:	1f 93       	push	r17
    215c:	cf 93       	push	r28
    215e:	df 93       	push	r29
    2160:	10 e0       	ldi	r17, 0x00	; 0
    2162:	60 e0       	ldi	r22, 0x00	; 0
	unsigned char i;
	unsigned char omnicomm_crc = 0;

	for(i = 0; i < frame_size - 1; i++)
    2164:	c8 2f       	mov	r28, r24
    2166:	d0 e0       	ldi	r29, 0x00	; 0
    2168:	21 97       	sbiw	r28, 0x01	; 1
    216a:	07 c0       	rjmp	.+14     	; 0x217a <OmniComm_Do_crc+0x20>
	{
		omnicomm_crc = crc8(DataBuffer0[i], omnicomm_crc);
    216c:	e9 58       	subi	r30, 0x89	; 137
    216e:	fe 4f       	sbci	r31, 0xFE	; 254
    2170:	80 81       	ld	r24, Z
    2172:	0e 94 05 17 	call	0x2e0a	; 0x2e0a <crc8>
    2176:	68 2f       	mov	r22, r24
unsigned char OmniComm_Do_crc (unsigned char frame_size)
{
	unsigned char i;
	unsigned char omnicomm_crc = 0;

	for(i = 0; i < frame_size - 1; i++)
    2178:	1f 5f       	subi	r17, 0xFF	; 255
    217a:	e1 2f       	mov	r30, r17
    217c:	f0 e0       	ldi	r31, 0x00	; 0
    217e:	ec 17       	cp	r30, r28
    2180:	fd 07       	cpc	r31, r29
    2182:	a4 f3       	brlt	.-24     	; 0x216c <OmniComm_Do_crc+0x12>
	{
		omnicomm_crc = crc8(DataBuffer0[i], omnicomm_crc);
	}
	return(omnicomm_crc);
}
    2184:	86 2f       	mov	r24, r22
    2186:	df 91       	pop	r29
    2188:	cf 91       	pop	r28
    218a:	1f 91       	pop	r17
    218c:	08 95       	ret

0000218e <OmniComm_Check_frame>:
	OmniComm_Send_frame();
}

unsigned char OmniComm_Check_frame (void)	//функци€ провер€ет пакет и возвращает
{											//признак наличи€ или отсутстви€ ошибки
	omnicomm_frame_size = BufferSize0;
    218e:	80 91 34 01 	lds	r24, 0x0134
    2192:	80 93 33 04 	sts	0x0433, r24
	if (DataBuffer0[ 0 ] == OMNICOMM_MASTER_PREFIX && BufferSize0 > 3)	//если пришЄл префикс мастера
    2196:	80 91 77 01 	lds	r24, 0x0177
    219a:	81 33       	cpi	r24, 0x31	; 49
    219c:	21 f5       	brne	.+72     	; 0x21e6 <OmniComm_Check_frame+0x58>
    219e:	80 91 34 01 	lds	r24, 0x0134
    21a2:	84 30       	cpi	r24, 0x04	; 4
    21a4:	00 f1       	brcs	.+64     	; 0x21e6 <OmniComm_Check_frame+0x58>
	{
		if (OmniComm_Do_crc(BufferSize0) == DataBuffer0[BufferSize0 - 1])
    21a6:	80 91 34 01 	lds	r24, 0x0134
    21aa:	0e 94 ad 10 	call	0x215a	; 0x215a <OmniComm_Do_crc>
    21ae:	e0 91 34 01 	lds	r30, 0x0134
    21b2:	f0 e0       	ldi	r31, 0x00	; 0
    21b4:	ea 58       	subi	r30, 0x8A	; 138
    21b6:	fe 4f       	sbci	r31, 0xFE	; 254
    21b8:	90 81       	ld	r25, Z
    21ba:	89 17       	cp	r24, r25
    21bc:	51 f4       	brne	.+20     	; 0x21d2 <OmniComm_Check_frame+0x44>
		{
			omnicomm_addr = DataBuffer0[ 1 ];
    21be:	80 91 78 01 	lds	r24, 0x0178
    21c2:	80 93 35 04 	sts	0x0435, r24
			omnicomm_cmd = DataBuffer0[ 2 ];
    21c6:	80 91 79 01 	lds	r24, 0x0179
    21ca:	80 93 34 04 	sts	0x0434, r24
    21ce:	84 e0       	ldi	r24, 0x04	; 4
    21d0:	08 95       	ret
			return(OMNICOMM_FRAME_OK);
		}
		else
		{
			omnicomm_addr = DataBuffer0[ 1 ];
    21d2:	80 91 78 01 	lds	r24, 0x0178
    21d6:	80 93 35 04 	sts	0x0435, r24
			omnicomm_cmd = DataBuffer0[ 2 ];
    21da:	80 91 79 01 	lds	r24, 0x0179
    21de:	80 93 34 04 	sts	0x0434, r24
    21e2:	83 e0       	ldi	r24, 0x03	; 3
    21e4:	08 95       	ret
			return(OMNICOMM_FRAME_ERROR);
    21e6:	83 e0       	ldi	r24, 0x03	; 3
		}
		
	}
	return(OMNICOMM_FRAME_ERROR);
}
    21e8:	08 95       	ret

000021ea <is_frame_ok>:

unsigned char is_frame_ok(void)
{
	//if(omnicomm_status != OMNICOMM_FRAME_OK) // «десь в отличие от датчика другой механиз низкоуровнего приема
	//	return 0;
	if(BufferSize0 < 3) // «десь в отличие от датчика другой механиз низкоуровнего приема
    21ea:	80 91 34 01 	lds	r24, 0x0134
    21ee:	83 30       	cpi	r24, 0x03	; 3
    21f0:	50 f1       	brcs	.+84     	; 0x2246 <is_frame_ok+0x5c>
	return(OMNICOMM_FRAME_ERROR);
}

unsigned char OmniComm_Check_old_frame (void)	//функци€ провер€ет пакет и возвращает
{				
	if(DataBuffer0[0]==OMNICOMM_OLD_PREFIX)
    21f2:	80 91 77 01 	lds	r24, 0x0177
    21f6:	84 34       	cpi	r24, 0x44	; 68
    21f8:	89 f4       	brne	.+34     	; 0x221c <is_frame_ok+0x32>
	{
		if(DataBuffer0[1] == 0x4F)
    21fa:	80 91 78 01 	lds	r24, 0x0178
    21fe:	8f 34       	cpi	r24, 0x4F	; 79
    2200:	11 f4       	brne	.+4      	; 0x2206 <is_frame_ok+0x1c>
		{
			omnicomm_cmd = DATA_READ_OLD;
    2202:	88 e7       	ldi	r24, 0x78	; 120
    2204:	03 c0       	rjmp	.+6      	; 0x220c <is_frame_ok+0x22>
	 		omnicomm_addr = MBClientGetHostID0();
			return(OMNICOMM_FRAME_OK);	
		}
		if(DataBuffer0[1] == 0x50)
    2206:	80 35       	cpi	r24, 0x50	; 80
    2208:	49 f4       	brne	.+18     	; 0x221c <is_frame_ok+0x32>
		{
			omnicomm_cmd = DATA_CONTIN_OLD;
    220a:	89 e7       	ldi	r24, 0x79	; 121
    220c:	80 93 34 04 	sts	0x0434, r24
			omnicomm_addr = MBClientGetHostID0();
    2210:	80 91 00 01 	lds	r24, 0x0100
    2214:	80 93 35 04 	sts	0x0435, r24
    2218:	81 e0       	ldi	r24, 0x01	; 1
    221a:	08 95       	ret
	//	return 0;
	if(BufferSize0 < 3) // «десь в отличие от датчика другой механиз низкоуровнего приема
		return 0;
    if(OmniComm_Check_old_frame()==OMNICOMM_FRAME_OK)
		return 1;
	if(OmniComm_Check_frame() != OMNICOMM_FRAME_OK)
    221c:	0e 94 c7 10 	call	0x218e	; 0x218e <OmniComm_Check_frame>
    2220:	84 30       	cpi	r24, 0x04	; 4
    2222:	71 f4       	brne	.+28     	; 0x2240 <is_frame_ok+0x56>
	{
		omnicomm_status = OMNICOMM_IDLE;
		return 0;
	}
	if(net_mode == INDEPENDENT_MODE && omnicomm_addr == 0xFF)
    2224:	80 91 53 04 	lds	r24, 0x0453
    2228:	88 23       	and	r24, r24
    222a:	21 f4       	brne	.+8      	; 0x2234 <is_frame_ok+0x4a>
    222c:	80 91 35 04 	lds	r24, 0x0435
    2230:	8f 3f       	cpi	r24, 0xFF	; 255
    2232:	59 f0       	breq	.+22     	; 0x224a <is_frame_ok+0x60>
		return 1;
	if(omnicomm_addr == MBClientGetHostID0())
    2234:	90 91 35 04 	lds	r25, 0x0435
    2238:	80 91 00 01 	lds	r24, 0x0100
    223c:	98 17       	cp	r25, r24
    223e:	29 f0       	breq	.+10     	; 0x224a <is_frame_ok+0x60>
		return 1;
	omnicomm_status = OMNICOMM_IDLE;
    2240:	81 e0       	ldi	r24, 0x01	; 1
    2242:	80 93 32 04 	sts	0x0432, r24
    2246:	80 e0       	ldi	r24, 0x00	; 0
    2248:	08 95       	ret
	return 0;
    224a:	81 e0       	ldi	r24, 0x01	; 1
}
    224c:	08 95       	ret

0000224e <OmniComm_Send_frame>:
	return(omnicomm_crc);
}


void OmniComm_Send_frame (void)	//перед вызовом этой функции в omnicomm_frame_size нужно записать размер пакета (количество байт в пакете,
{								//учитыва€ префикс и crc)
    224e:	1f 93       	push	r17
	
	omnicomm_status = OMNICOMM_BUSY;//"зан€ли" протокол
    2250:	10 92 32 04 	sts	0x0432, r1
	SET_DE485_0();//включили режим передачи
    2254:	0e 94 9b 0b 	call	0x1736	; 0x1736 <SET_DE485_0>
	DataBuffer0[0] = OMNICOMM_SLAVE_PREFIX;
    2258:	8e e3       	ldi	r24, 0x3E	; 62
    225a:	80 93 77 01 	sts	0x0177, r24
	DataBuffer0[1] = omnicomm_addr;
    225e:	80 91 35 04 	lds	r24, 0x0435
    2262:	80 93 78 01 	sts	0x0178, r24
	DataBuffer0[2] = omnicomm_cmd;
    2266:	80 91 34 04 	lds	r24, 0x0434
    226a:	80 93 79 01 	sts	0x0179, r24
	DataBuffer0[omnicomm_frame_size - 1] = OmniComm_Do_crc(omnicomm_frame_size);
    226e:	10 91 33 04 	lds	r17, 0x0433
    2272:	80 91 33 04 	lds	r24, 0x0433
    2276:	0e 94 ad 10 	call	0x215a	; 0x215a <OmniComm_Do_crc>
    227a:	e1 2f       	mov	r30, r17
    227c:	f0 e0       	ldi	r31, 0x00	; 0
    227e:	ea 58       	subi	r30, 0x8A	; 138
    2280:	fe 4f       	sbci	r31, 0xFE	; 254
    2282:	80 83       	st	Z, r24
	pBuf0 = DataBuffer0;
    2284:	87 e7       	ldi	r24, 0x77	; 119
    2286:	91 e0       	ldi	r25, 0x01	; 1
    2288:	90 93 72 02 	sts	0x0272, r25
    228c:	80 93 71 02 	sts	0x0271, r24
	BufferSize0 = omnicomm_frame_size;
    2290:	80 91 33 04 	lds	r24, 0x0433
    2294:	80 93 34 01 	sts	0x0134, r24
	UCSR0B |= (1 << UDRIE0);		//—“ј–“ передачи. ƒальнейша€ передача будет
    2298:	80 91 c1 00 	lds	r24, 0x00C1
    229c:	80 62       	ori	r24, 0x20	; 32
    229e:	80 93 c1 00 	sts	0x00C1, r24
								//происходить по прерыванию USART_RX_vect
	while (!(UCSR0B & (1 << RXEN0)));			//пока не очиститс€ буфер.
    22a2:	80 91 c1 00 	lds	r24, 0x00C1
    22a6:	84 ff       	sbrs	r24, 4
    22a8:	fc cf       	rjmp	.-8      	; 0x22a2 <OmniComm_Send_frame+0x54>
}
    22aa:	1f 91       	pop	r17
    22ac:	08 95       	ret

000022ae <OmniComm_Reply_ok>:
}


void OmniComm_Reply_ok (void)//функци€ ответа мастеру об отсутствии ошибок
{
	DataBuffer0[3] = OMNICOMM_NO_ERRORS;
    22ae:	10 92 7a 01 	sts	0x017A, r1
	omnicomm_frame_size = 5;
    22b2:	85 e0       	ldi	r24, 0x05	; 5
    22b4:	80 93 33 04 	sts	0x0433, r24
	OmniComm_Send_frame();
    22b8:	0e 94 27 11 	call	0x224e	; 0x224e <OmniComm_Send_frame>
}
    22bc:	08 95       	ret

000022be <OmniComm_Reply_error>:
	while (!(UCSR0B & (1 << RXEN0)));			//пока не очиститс€ буфер.
}

void OmniComm_Reply_error (void)//функци€ ответа мастеру об ошибке
{
	DataBuffer0[3] = OMNICOMM_ERROR;
    22be:	81 e0       	ldi	r24, 0x01	; 1
    22c0:	80 93 7a 01 	sts	0x017A, r24
	omnicomm_frame_size = 5;
    22c4:	85 e0       	ldi	r24, 0x05	; 5
    22c6:	80 93 33 04 	sts	0x0433, r24
	OmniComm_Send_frame();
    22ca:	0e 94 27 11 	call	0x224e	; 0x224e <OmniComm_Send_frame>
}
    22ce:	08 95       	ret

000022d0 <do_omnicom>:
	omnicomm_status = OMNICOMM_IDLE;
	return 0;
}

void do_omnicom(void)
{
    22d0:	ef 92       	push	r14
    22d2:	ff 92       	push	r15
    22d4:	0f 93       	push	r16
    22d6:	1f 93       	push	r17
	if(report_on)
    22d8:	80 91 50 04 	lds	r24, 0x0450
    22dc:	88 23       	and	r24, r24
    22de:	91 f1       	breq	.+100    	; 0x2344 <do_omnicom+0x74>
	{
		if(omnicomm_timer > ((unsigned long)(F_CPU/TIMER0_CLOCK/256)) * period_auto)
    22e0:	e0 90 2d 04 	lds	r14, 0x042D
    22e4:	f0 90 2e 04 	lds	r15, 0x042E
    22e8:	00 91 2f 04 	lds	r16, 0x042F
    22ec:	10 91 30 04 	lds	r17, 0x0430
    22f0:	60 91 1f 01 	lds	r22, 0x011F
    22f4:	70 e0       	ldi	r23, 0x00	; 0
    22f6:	80 e0       	ldi	r24, 0x00	; 0
    22f8:	90 e0       	ldi	r25, 0x00	; 0
    22fa:	20 e2       	ldi	r18, 0x20	; 32
    22fc:	3c e1       	ldi	r19, 0x1C	; 28
    22fe:	40 e0       	ldi	r20, 0x00	; 0
    2300:	50 e0       	ldi	r21, 0x00	; 0
    2302:	0e 94 26 1c 	call	0x384c	; 0x384c <__mulsi3>
    2306:	6e 15       	cp	r22, r14
    2308:	7f 05       	cpc	r23, r15
    230a:	80 07       	cpc	r24, r16
    230c:	91 07       	cpc	r25, r17
    230e:	d0 f4       	brcc	.+52     	; 0x2344 <do_omnicom+0x74>
		{
			if(omnicomm_command_type == NEW_COMMAND_TYPE)
    2310:	80 91 31 04 	lds	r24, 0x0431
    2314:	82 30       	cpi	r24, 0x02	; 2
    2316:	51 f4       	brne	.+20     	; 0x232c <do_omnicom+0x5c>
			{
				omnicomm_addr = MBClientGetHostID0();
    2318:	80 91 00 01 	lds	r24, 0x0100
    231c:	80 93 35 04 	sts	0x0435, r24
				omnicomm_cmd = DATA_CONTIN;
    2320:	87 e0       	ldi	r24, 0x07	; 7
    2322:	80 93 34 04 	sts	0x0434, r24
				Data_read(NEW_COMMAND_TYPE);
    2326:	82 e0       	ldi	r24, 0x02	; 2
    2328:	90 e0       	ldi	r25, 0x00	; 0
    232a:	02 c0       	rjmp	.+4      	; 0x2330 <do_omnicom+0x60>
			}
			else
				Data_read(OLD_COMMAND_TYPE);
    232c:	81 e0       	ldi	r24, 0x01	; 1
    232e:	90 e0       	ldi	r25, 0x00	; 0
    2330:	0e 94 ba 14 	call	0x2974	; 0x2974 <Data_read>
			omnicomm_timer = 0;
    2334:	10 92 2d 04 	sts	0x042D, r1
    2338:	10 92 2e 04 	sts	0x042E, r1
    233c:	10 92 2f 04 	sts	0x042F, r1
    2340:	10 92 30 04 	sts	0x0430, r1
		}
	}
	if (is_frame_ok())
    2344:	0e 94 f5 10 	call	0x21ea	; 0x21ea <is_frame_ok>
    2348:	88 23       	and	r24, r24
    234a:	09 f4       	brne	.+2      	; 0x234e <do_omnicom+0x7e>
    234c:	aa c0       	rjmp	.+340    	; 0x24a2 <do_omnicom+0x1d2>
	{
		report_on = 0;
    234e:	10 92 50 04 	sts	0x0450, r1
		switch (omnicomm_cmd)
    2352:	80 91 34 04 	lds	r24, 0x0434
    2356:	8c 30       	cpi	r24, 0x0C	; 12
    2358:	09 f4       	brne	.+2      	; 0x235c <do_omnicom+0x8c>
    235a:	84 c0       	rjmp	.+264    	; 0x2464 <do_omnicom+0x194>
    235c:	8d 30       	cpi	r24, 0x0D	; 13
    235e:	58 f5       	brcc	.+86     	; 0x23b6 <do_omnicom+0xe6>
    2360:	86 30       	cpi	r24, 0x06	; 6
    2362:	09 f4       	brne	.+2      	; 0x2366 <do_omnicom+0x96>
    2364:	61 c0       	rjmp	.+194    	; 0x2428 <do_omnicom+0x158>
    2366:	87 30       	cpi	r24, 0x07	; 7
    2368:	98 f4       	brcc	.+38     	; 0x2390 <do_omnicom+0xc0>
    236a:	83 30       	cpi	r24, 0x03	; 3
    236c:	09 f4       	brne	.+2      	; 0x2370 <do_omnicom+0xa0>
    236e:	53 c0       	rjmp	.+166    	; 0x2416 <do_omnicom+0x146>
    2370:	84 30       	cpi	r24, 0x04	; 4
    2372:	38 f4       	brcc	.+14     	; 0x2382 <do_omnicom+0xb2>
    2374:	81 30       	cpi	r24, 0x01	; 1
    2376:	09 f4       	brne	.+2      	; 0x237a <do_omnicom+0xaa>
    2378:	48 c0       	rjmp	.+144    	; 0x240a <do_omnicom+0x13a>
    237a:	82 30       	cpi	r24, 0x02	; 2
    237c:	09 f0       	breq	.+2      	; 0x2380 <do_omnicom+0xb0>
    237e:	8f c0       	rjmp	.+286    	; 0x249e <do_omnicom+0x1ce>
    2380:	47 c0       	rjmp	.+142    	; 0x2410 <do_omnicom+0x140>
    2382:	84 30       	cpi	r24, 0x04	; 4
    2384:	09 f4       	brne	.+2      	; 0x2388 <do_omnicom+0xb8>
    2386:	4a c0       	rjmp	.+148    	; 0x241c <do_omnicom+0x14c>
    2388:	85 30       	cpi	r24, 0x05	; 5
    238a:	09 f0       	breq	.+2      	; 0x238e <do_omnicom+0xbe>
    238c:	88 c0       	rjmp	.+272    	; 0x249e <do_omnicom+0x1ce>
    238e:	49 c0       	rjmp	.+146    	; 0x2422 <do_omnicom+0x152>
    2390:	89 30       	cpi	r24, 0x09	; 9
    2392:	09 f4       	brne	.+2      	; 0x2396 <do_omnicom+0xc6>
    2394:	5e c0       	rjmp	.+188    	; 0x2452 <do_omnicom+0x182>
    2396:	8a 30       	cpi	r24, 0x0A	; 10
    2398:	38 f4       	brcc	.+14     	; 0x23a8 <do_omnicom+0xd8>
    239a:	87 30       	cpi	r24, 0x07	; 7
    239c:	09 f4       	brne	.+2      	; 0x23a0 <do_omnicom+0xd0>
    239e:	4e c0       	rjmp	.+156    	; 0x243c <do_omnicom+0x16c>
    23a0:	88 30       	cpi	r24, 0x08	; 8
    23a2:	09 f0       	breq	.+2      	; 0x23a6 <do_omnicom+0xd6>
    23a4:	7c c0       	rjmp	.+248    	; 0x249e <do_omnicom+0x1ce>
    23a6:	52 c0       	rjmp	.+164    	; 0x244c <do_omnicom+0x17c>
    23a8:	8a 30       	cpi	r24, 0x0A	; 10
    23aa:	09 f4       	brne	.+2      	; 0x23ae <do_omnicom+0xde>
    23ac:	55 c0       	rjmp	.+170    	; 0x2458 <do_omnicom+0x188>
    23ae:	8b 30       	cpi	r24, 0x0B	; 11
    23b0:	09 f0       	breq	.+2      	; 0x23b4 <do_omnicom+0xe4>
    23b2:	75 c0       	rjmp	.+234    	; 0x249e <do_omnicom+0x1ce>
    23b4:	54 c0       	rjmp	.+168    	; 0x245e <do_omnicom+0x18e>
    23b6:	83 31       	cpi	r24, 0x13	; 19
    23b8:	09 f4       	brne	.+2      	; 0x23bc <do_omnicom+0xec>
    23ba:	63 c0       	rjmp	.+198    	; 0x2482 <do_omnicom+0x1b2>
    23bc:	84 31       	cpi	r24, 0x14	; 20
    23be:	98 f4       	brcc	.+38     	; 0x23e6 <do_omnicom+0x116>
    23c0:	8f 30       	cpi	r24, 0x0F	; 15
    23c2:	09 f4       	brne	.+2      	; 0x23c6 <do_omnicom+0xf6>
    23c4:	58 c0       	rjmp	.+176    	; 0x2476 <do_omnicom+0x1a6>
    23c6:	80 31       	cpi	r24, 0x10	; 16
    23c8:	38 f4       	brcc	.+14     	; 0x23d8 <do_omnicom+0x108>
    23ca:	8d 30       	cpi	r24, 0x0D	; 13
    23cc:	09 f4       	brne	.+2      	; 0x23d0 <do_omnicom+0x100>
    23ce:	4d c0       	rjmp	.+154    	; 0x246a <do_omnicom+0x19a>
    23d0:	8e 30       	cpi	r24, 0x0E	; 14
    23d2:	09 f0       	breq	.+2      	; 0x23d6 <do_omnicom+0x106>
    23d4:	64 c0       	rjmp	.+200    	; 0x249e <do_omnicom+0x1ce>
    23d6:	4c c0       	rjmp	.+152    	; 0x2470 <do_omnicom+0x1a0>
    23d8:	81 31       	cpi	r24, 0x11	; 17
    23da:	09 f4       	brne	.+2      	; 0x23de <do_omnicom+0x10e>
    23dc:	4c c0       	rjmp	.+152    	; 0x2476 <do_omnicom+0x1a6>
    23de:	82 31       	cpi	r24, 0x12	; 18
    23e0:	09 f0       	breq	.+2      	; 0x23e4 <do_omnicom+0x114>
    23e2:	5d c0       	rjmp	.+186    	; 0x249e <do_omnicom+0x1ce>
    23e4:	4b c0       	rjmp	.+150    	; 0x247c <do_omnicom+0x1ac>
    23e6:	87 31       	cpi	r24, 0x17	; 23
    23e8:	09 f4       	brne	.+2      	; 0x23ec <do_omnicom+0x11c>
    23ea:	54 c0       	rjmp	.+168    	; 0x2494 <do_omnicom+0x1c4>
    23ec:	88 31       	cpi	r24, 0x18	; 24
    23ee:	38 f4       	brcc	.+14     	; 0x23fe <do_omnicom+0x12e>
    23f0:	84 31       	cpi	r24, 0x14	; 20
    23f2:	09 f4       	brne	.+2      	; 0x23f6 <do_omnicom+0x126>
    23f4:	49 c0       	rjmp	.+146    	; 0x2488 <do_omnicom+0x1b8>
    23f6:	85 31       	cpi	r24, 0x15	; 21
    23f8:	09 f0       	breq	.+2      	; 0x23fc <do_omnicom+0x12c>
    23fa:	51 c0       	rjmp	.+162    	; 0x249e <do_omnicom+0x1ce>
    23fc:	48 c0       	rjmp	.+144    	; 0x248e <do_omnicom+0x1be>
    23fe:	88 37       	cpi	r24, 0x78	; 120
    2400:	b1 f0       	breq	.+44     	; 0x242e <do_omnicom+0x15e>
    2402:	89 37       	cpi	r24, 0x79	; 121
    2404:	09 f0       	breq	.+2      	; 0x2408 <do_omnicom+0x138>
    2406:	4b c0       	rjmp	.+150    	; 0x249e <do_omnicom+0x1ce>
    2408:	1c c0       	rjmp	.+56     	; 0x2442 <do_omnicom+0x172>
		{
			case SET_ID:		{Set_id(); break;}
    240a:	0e 94 fe 15 	call	0x2bfc	; 0x2bfc <Set_id>
    240e:	49 c0       	rjmp	.+146    	; 0x24a2 <do_omnicom+0x1d2>
			case ID_READ:		{Id_read(); break;}
    2410:	0e 94 52 14 	call	0x28a4	; 0x28a4 <Id_read>
    2414:	46 c0       	rjmp	.+140    	; 0x24a2 <do_omnicom+0x1d2>
			case SET_ADDR:		{Set_addr(); break;}
    2416:	0e 94 c1 13 	call	0x2782	; 0x2782 <Set_addr>
    241a:	43 c0       	rjmp	.+134    	; 0x24a2 <do_omnicom+0x1d2>
			case SET_NET_MODE:	{Set_net_mode(); break;}
    241c:	0e 94 ab 13 	call	0x2756	; 0x2756 <Set_net_mode>
    2420:	40 c0       	rjmp	.+128    	; 0x24a2 <do_omnicom+0x1d2>
			case CONFIG_READ:	{Config_read(); break;}
    2422:	0e 94 f9 13 	call	0x27f2	; 0x27f2 <Config_read>
    2426:	3d c0       	rjmp	.+122    	; 0x24a2 <do_omnicom+0x1d2>
			case DATA_READ:		{
									Data_read(NEW_COMMAND_TYPE); 
    2428:	82 e0       	ldi	r24, 0x02	; 2
    242a:	90 e0       	ldi	r25, 0x00	; 0
    242c:	04 c0       	rjmp	.+8      	; 0x2436 <do_omnicom+0x166>
									break;
								}
			case DATA_READ_OLD:	{
									Disable_auto_old_mode();
    242e:	0e 94 b1 12 	call	0x2562	; 0x2562 <Disable_auto_old_mode>
									Data_read(OLD_COMMAND_TYPE);
    2432:	81 e0       	ldi	r24, 0x01	; 1
    2434:	90 e0       	ldi	r25, 0x00	; 0
    2436:	0e 94 ba 14 	call	0x2974	; 0x2974 <Data_read>
    243a:	33 c0       	rjmp	.+102    	; 0x24a2 <do_omnicom+0x1d2>
									break;
								}
			case DATA_CONTIN:	{
									Data_contin(NEW_COMMAND_TYPE);
    243c:	82 e0       	ldi	r24, 0x02	; 2
    243e:	90 e0       	ldi	r25, 0x00	; 0
    2440:	02 c0       	rjmp	.+4      	; 0x2446 <do_omnicom+0x176>
									break;
								}//не описывал, т.к. мало информации по режиму. ƒолжна поддерживатьс€ стара€ команда 0x44 0xFF - нет информации, как примен€ть в контексте протокола
			case DATA_CONTIN_OLD:{
									Data_contin(OLD_COMMAND_TYPE);
    2442:	81 e0       	ldi	r24, 0x01	; 1
    2444:	90 e0       	ldi	r25, 0x00	; 0
    2446:	0e 94 75 13 	call	0x26ea	; 0x26ea <Data_contin>
    244a:	2b c0       	rjmp	.+86     	; 0x24a2 <do_omnicom+0x1d2>
								 	break;
								}
			case FCURR_FMIN:	{Fcurr_fmin(); break;}
    244c:	0e 94 73 14 	call	0x28e6	; 0x28e6 <Fcurr_fmin>
    2450:	28 c0       	rjmp	.+80     	; 0x24a2 <do_omnicom+0x1d2>
			case FCURR_FMAX:	{Fcurr_fmax(); break;}
    2452:	0e 94 46 13 	call	0x268c	; 0x268c <Fcurr_fmax>
    2456:	25 c0       	rjmp	.+74     	; 0x24a2 <do_omnicom+0x1d2>
			case TSLOPE_T0:		{Tslope_t0(); break;}
    2458:	0e 94 43 13 	call	0x2686	; 0x2686 <Tslope_t0>
    245c:	22 c0       	rjmp	.+68     	; 0x24a2 <do_omnicom+0x1d2>
			case SET_FMIN:		{Set_fmin(); break;}
    245e:	0e 94 40 13 	call	0x2680	; 0x2680 <Set_fmin>
    2462:	1f c0       	rjmp	.+62     	; 0x24a2 <do_omnicom+0x1d2>
			case SET_FMAX:		{Set_fmax(); break;}
    2464:	0e 94 3d 13 	call	0x267a	; 0x267a <Set_fmax>
    2468:	1c c0       	rjmp	.+56     	; 0x24a2 <do_omnicom+0x1d2>
			case SET_PWM_MAX:	{Set_pwm_max(); break;}
    246a:	0e 94 3a 13 	call	0x2674	; 0x2674 <Set_pwm_max>
    246e:	19 c0       	rjmp	.+50     	; 0x24a2 <do_omnicom+0x1d2>
			case SET_PWM_MOD:	{Set_pwm_mod(); break;}
    2470:	0e 94 37 13 	call	0x266e	; 0x266e <Set_pwm_mod>
    2474:	16 c0       	rjmp	.+44     	; 0x24a2 <do_omnicom+0x1d2>
			case SET_TRL:		{Set_filt_length(); /*Set_trl();*/ break;}
			case SET_FILT_LENG:	{Set_filt_length(); break;}
    2476:	0e 94 31 13 	call	0x2662	; 0x2662 <Set_filt_length>
    247a:	13 c0       	rjmp	.+38     	; 0x24a2 <do_omnicom+0x1d2>
			case SET_PASSW:		{Set_passw(); break;}
    247c:	0e 94 2e 13 	call	0x265c	; 0x265c <Set_passw>
    2480:	10 c0       	rjmp	.+32     	; 0x24a2 <do_omnicom+0x1d2>
			case SET_PERIOD:	{Set_period(); break;}
    2482:	0e 94 11 13 	call	0x2622	; 0x2622 <Set_period>
    2486:	0d c0       	rjmp	.+26     	; 0x24a2 <do_omnicom+0x1d2>
			case FILT_LENG_READ:{Filt_leng_read(); break;}
    2488:	0e 94 e7 13 	call	0x27ce	; 0x27ce <Filt_leng_read>
    248c:	0a c0       	rjmp	.+20     	; 0x24a2 <do_omnicom+0x1d2>
			case PASSW_READ:	{Passw_read(); break;}
    248e:	0e 94 d7 13 	call	0x27ae	; 0x27ae <Passw_read>
    2492:	07 c0       	rjmp	.+14     	; 0x24a2 <do_omnicom+0x1d2>
			case SET_AUTO_MODE:	{Set_auto_mode(DataBuffer0[3]); break;}//команда св€зана с командой DATA_CONTIN, устанавливает режим вывода данных после старта контроллера, т.е. контроллер сразу после запуска должен "тупо" кидать данные по RS485
    2494:	80 91 7a 01 	lds	r24, 0x017A
    2498:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <Set_auto_mode>
    249c:	02 c0       	rjmp	.+4      	; 0x24a2 <do_omnicom+0x1d2>
			default: OmniComm_Reply_ok();
    249e:	0e 94 57 11 	call	0x22ae	; 0x22ae <OmniComm_Reply_ok>
		}
	}
}
    24a2:	1f 91       	pop	r17
    24a4:	0f 91       	pop	r16
    24a6:	ff 90       	pop	r15
    24a8:	ef 90       	pop	r14
    24aa:	08 95       	ret

000024ac <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    24ac:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    24ae:	f9 99       	sbic	0x1f, 1	; 31
    24b0:	fe cf       	rjmp	.-4      	; 0x24ae <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    24b2:	32 bd       	out	0x22, r19	; 34
    24b4:	21 bd       	out	0x21, r18	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    24b6:	f8 9a       	sbi	0x1f, 0	; 31
    24b8:	80 b5       	in	r24, 0x20	; 32
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
    24ba:	08 95       	ret

000024bc <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    24bc:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    24be:	f9 99       	sbic	0x1f, 1	; 31
    24c0:	fe cf       	rjmp	.-4      	; 0x24be <eeprom_write_byte+0x2>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    24c2:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    24c4:	32 bd       	out	0x22, r19	; 34
    24c6:	21 bd       	out	0x21, r18	; 33
#endif
    EEDR = __value;
    24c8:	60 bd       	out	0x20, r22	; 32

    __asm__ __volatile__ (
    24ca:	0f b6       	in	r0, 0x3f	; 63
    24cc:	f8 94       	cli
    24ce:	fa 9a       	sbi	0x1f, 2	; 31
    24d0:	f9 9a       	sbi	0x1f, 1	; 31
    24d2:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
    24d4:	08 95       	ret

000024d6 <update_data>:

void update_data(void);


void update_data(void)
{
    24d6:	ef 92       	push	r14
    24d8:	ff 92       	push	r15
    24da:	0f 93       	push	r16
    24dc:	1f 93       	push	r17
	f_curr = (unsigned short)(1000.0 * VolumePercent);
    24de:	e0 90 38 01 	lds	r14, 0x0138
    24e2:	f0 90 39 01 	lds	r15, 0x0139
    24e6:	00 91 3a 01 	lds	r16, 0x013A
    24ea:	10 91 3b 01 	lds	r17, 0x013B
    24ee:	c8 01       	movw	r24, r16
    24f0:	b7 01       	movw	r22, r14
    24f2:	20 e0       	ldi	r18, 0x00	; 0
    24f4:	30 e0       	ldi	r19, 0x00	; 0
    24f6:	4a e7       	ldi	r20, 0x7A	; 122
    24f8:	54 e4       	ldi	r21, 0x44	; 68
    24fa:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__mulsf3>
    24fe:	0e 94 e1 1a 	call	0x35c2	; 0x35c2 <__fixunssfsi>
    2502:	70 93 40 04 	sts	0x0440, r23
    2506:	60 93 3f 04 	sts	0x043F, r22
	n = 1023.0 * VolumePercent;
    250a:	c8 01       	movw	r24, r16
    250c:	b7 01       	movw	r22, r14
    250e:	20 e0       	ldi	r18, 0x00	; 0
    2510:	30 ec       	ldi	r19, 0xC0	; 192
    2512:	4f e7       	ldi	r20, 0x7F	; 127
    2514:	54 e4       	ldi	r21, 0x44	; 68
    2516:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__mulsf3>
    251a:	0e 94 e1 1a 	call	0x35c2	; 0x35c2 <__fixunssfsi>
    251e:	70 93 3a 04 	sts	0x043A, r23
    2522:	60 93 39 04 	sts	0x0439, r22
}
    2526:	1f 91       	pop	r17
    2528:	0f 91       	pop	r16
    252a:	ff 90       	pop	r15
    252c:	ef 90       	pop	r14
    252e:	08 95       	ret

00002530 <Enable_auto_old_mode>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2530:	f9 99       	sbic	0x1f, 1	; 31
    2532:	fe cf       	rjmp	.-4      	; 0x2530 <Enable_auto_old_mode>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    2534:	2a ee       	ldi	r18, 0xEA	; 234
    2536:	31 e0       	ldi	r19, 0x01	; 1
    2538:	32 bd       	out	0x22, r19	; 34
    253a:	21 bd       	out	0x21, r18	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    253c:	f8 9a       	sbi	0x1f, 0	; 31
    253e:	80 b5       	in	r24, 0x20	; 32
	OmniComm_Reply_ok();
}

void Enable_auto_old_mode (void)
{
	if(!eeprom_read_byte(&old_contin))
    2540:	88 23       	and	r24, r24
    2542:	71 f4       	brne	.+28     	; 0x2560 <Enable_auto_old_mode+0x30>
	{
		eeprom_busy_wait();
    2544:	f9 99       	sbic	0x1f, 1	; 31
    2546:	fe cf       	rjmp	.-4      	; 0x2544 <Enable_auto_old_mode+0x14>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2548:	f9 99       	sbic	0x1f, 1	; 31
    254a:	fe cf       	rjmp	.-4      	; 0x2548 <Enable_auto_old_mode+0x18>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    254c:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    254e:	32 bd       	out	0x22, r19	; 34
    2550:	21 bd       	out	0x21, r18	; 33
#endif
    EEDR = __value;
    2552:	81 e0       	ldi	r24, 0x01	; 1
    2554:	80 bd       	out	0x20, r24	; 32

    __asm__ __volatile__ (
    2556:	0f b6       	in	r0, 0x3f	; 63
    2558:	f8 94       	cli
    255a:	fa 9a       	sbi	0x1f, 2	; 31
    255c:	f9 9a       	sbi	0x1f, 1	; 31
    255e:	0f be       	out	0x3f, r0	; 63
    2560:	08 95       	ret

00002562 <Disable_auto_old_mode>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2562:	f9 99       	sbic	0x1f, 1	; 31
    2564:	fe cf       	rjmp	.-4      	; 0x2562 <Disable_auto_old_mode>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    2566:	2a ee       	ldi	r18, 0xEA	; 234
    2568:	31 e0       	ldi	r19, 0x01	; 1
    256a:	32 bd       	out	0x22, r19	; 34
    256c:	21 bd       	out	0x21, r18	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    256e:	f8 9a       	sbi	0x1f, 0	; 31
    2570:	80 b5       	in	r24, 0x20	; 32
	}	
}

void Disable_auto_old_mode (void)
{
	if(eeprom_read_byte(&old_contin))
    2572:	88 23       	and	r24, r24
    2574:	69 f0       	breq	.+26     	; 0x2590 <Disable_auto_old_mode+0x2e>
	{
		eeprom_busy_wait();
    2576:	f9 99       	sbic	0x1f, 1	; 31
    2578:	fe cf       	rjmp	.-4      	; 0x2576 <Disable_auto_old_mode+0x14>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    257a:	f9 99       	sbic	0x1f, 1	; 31
    257c:	fe cf       	rjmp	.-4      	; 0x257a <Disable_auto_old_mode+0x18>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    257e:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    2580:	32 bd       	out	0x22, r19	; 34
    2582:	21 bd       	out	0x21, r18	; 33
#endif
    EEDR = __value;
    2584:	10 bc       	out	0x20, r1	; 32

    __asm__ __volatile__ (
    2586:	0f b6       	in	r0, 0x3f	; 63
    2588:	f8 94       	cli
    258a:	fa 9a       	sbi	0x1f, 2	; 31
    258c:	f9 9a       	sbi	0x1f, 1	; 31
    258e:	0f be       	out	0x3f, r0	; 63
    2590:	08 95       	ret

00002592 <Get_auto_old_mode>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2592:	f9 99       	sbic	0x1f, 1	; 31
    2594:	fe cf       	rjmp	.-4      	; 0x2592 <Get_auto_old_mode>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    2596:	8a ee       	ldi	r24, 0xEA	; 234
    2598:	91 e0       	ldi	r25, 0x01	; 1
    259a:	92 bd       	out	0x22, r25	; 34
    259c:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    259e:	f8 9a       	sbi	0x1f, 0	; 31
    25a0:	80 b5       	in	r24, 0x20	; 32
}

unsigned char Get_auto_old_mode (void)
{
	return(eeprom_read_byte(&old_contin));
}
    25a2:	08 95       	ret

000025a4 <Set_auto_mode>:
	ћожет быть автоматический режим только дл€ старых или новых команд, одноврменно быть не может.
	ѕри включении автоматического режима дл€ старых команд, автоматический режим дл€ новых команд отключаетс€.
*/

void Set_auto_mode (unsigned char _param)
{
    25a4:	1f 93       	push	r17
    25a6:	18 2f       	mov	r17, r24
	if(_param==0)
    25a8:	88 23       	and	r24, r24
    25aa:	91 f4       	brne	.+36     	; 0x25d0 <Set_auto_mode+0x2c>
	{
		eeprom_busy_wait();
    25ac:	f9 99       	sbic	0x1f, 1	; 31
    25ae:	fe cf       	rjmp	.-4      	; 0x25ac <Set_auto_mode+0x8>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    25b0:	f9 99       	sbic	0x1f, 1	; 31
    25b2:	fe cf       	rjmp	.-4      	; 0x25b0 <Set_auto_mode+0xc>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    25b4:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    25b6:	85 ec       	ldi	r24, 0xC5	; 197
    25b8:	91 e0       	ldi	r25, 0x01	; 1
    25ba:	92 bd       	out	0x22, r25	; 34
    25bc:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    25be:	10 bc       	out	0x20, r1	; 32

    __asm__ __volatile__ (
    25c0:	0f b6       	in	r0, 0x3f	; 63
    25c2:	f8 94       	cli
    25c4:	fa 9a       	sbi	0x1f, 2	; 31
    25c6:	f9 9a       	sbi	0x1f, 1	; 31
    25c8:	0f be       	out	0x3f, r0	; 63
		eeprom_write_byte(&e2_report_on, 0);
		Disable_auto_old_mode();
    25ca:	0e 94 b1 12 	call	0x2562	; 0x2562 <Disable_auto_old_mode>
    25ce:	25 c0       	rjmp	.+74     	; 0x261a <Set_auto_mode+0x76>
	}
	else if(_param==1)
    25d0:	81 30       	cpi	r24, 0x01	; 1
    25d2:	81 f4       	brne	.+32     	; 0x25f4 <Set_auto_mode+0x50>
	{
		Disable_auto_old_mode();
    25d4:	0e 94 b1 12 	call	0x2562	; 0x2562 <Disable_auto_old_mode>
		report_on=1;
    25d8:	10 93 50 04 	sts	0x0450, r17
		eeprom_busy_wait();
    25dc:	f9 99       	sbic	0x1f, 1	; 31
    25de:	fe cf       	rjmp	.-4      	; 0x25dc <Set_auto_mode+0x38>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    25e0:	f9 99       	sbic	0x1f, 1	; 31
    25e2:	fe cf       	rjmp	.-4      	; 0x25e0 <Set_auto_mode+0x3c>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    25e4:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    25e6:	85 ec       	ldi	r24, 0xC5	; 197
    25e8:	91 e0       	ldi	r25, 0x01	; 1
    25ea:	92 bd       	out	0x22, r25	; 34
    25ec:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    25ee:	81 e0       	ldi	r24, 0x01	; 1
    25f0:	80 bd       	out	0x20, r24	; 32
    25f2:	0e c0       	rjmp	.+28     	; 0x2610 <Set_auto_mode+0x6c>
		eeprom_write_byte(&e2_report_on, report_on);		
	}
	else if(_param==2)
    25f4:	82 30       	cpi	r24, 0x02	; 2
    25f6:	89 f4       	brne	.+34     	; 0x261a <Set_auto_mode+0x76>
	{
		Enable_auto_old_mode();
    25f8:	0e 94 98 12 	call	0x2530	; 0x2530 <Enable_auto_old_mode>
		eeprom_busy_wait();
    25fc:	f9 99       	sbic	0x1f, 1	; 31
    25fe:	fe cf       	rjmp	.-4      	; 0x25fc <Set_auto_mode+0x58>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2600:	f9 99       	sbic	0x1f, 1	; 31
    2602:	fe cf       	rjmp	.-4      	; 0x2600 <Set_auto_mode+0x5c>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    2604:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    2606:	85 ec       	ldi	r24, 0xC5	; 197
    2608:	91 e0       	ldi	r25, 0x01	; 1
    260a:	92 bd       	out	0x22, r25	; 34
    260c:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    260e:	10 bc       	out	0x20, r1	; 32

    __asm__ __volatile__ (
    2610:	0f b6       	in	r0, 0x3f	; 63
    2612:	f8 94       	cli
    2614:	fa 9a       	sbi	0x1f, 2	; 31
    2616:	f9 9a       	sbi	0x1f, 1	; 31
    2618:	0f be       	out	0x3f, r0	; 63
		eeprom_write_byte(&e2_report_on, 0);
	}
	OmniComm_Reply_ok();
    261a:	0e 94 57 11 	call	0x22ae	; 0x22ae <OmniComm_Reply_ok>
}
    261e:	1f 91       	pop	r17
    2620:	08 95       	ret

00002622 <Set_period>:
			OmniComm_Reply_ok();
}

void Set_period (void)
{
	period_auto = DataBuffer0[3];
    2622:	80 91 7a 01 	lds	r24, 0x017A
    2626:	80 93 1f 01 	sts	0x011F, r24
	if(period_auto == 0)
    262a:	88 23       	and	r24, r24
    262c:	19 f4       	brne	.+6      	; 0x2634 <Set_period+0x12>
		period_auto = 1;
    262e:	81 e0       	ldi	r24, 0x01	; 1
    2630:	80 93 1f 01 	sts	0x011F, r24
	eeprom_busy_wait();
    2634:	f9 99       	sbic	0x1f, 1	; 31
    2636:	fe cf       	rjmp	.-4      	; 0x2634 <Set_period+0x12>
	eeprom_write_byte(&e2_period_auto, period_auto);
    2638:	20 91 1f 01 	lds	r18, 0x011F
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    263c:	f9 99       	sbic	0x1f, 1	; 31
    263e:	fe cf       	rjmp	.-4      	; 0x263c <Set_period+0x1a>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    2640:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    2642:	83 ec       	ldi	r24, 0xC3	; 195
    2644:	91 e0       	ldi	r25, 0x01	; 1
    2646:	92 bd       	out	0x22, r25	; 34
    2648:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    264a:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    264c:	0f b6       	in	r0, 0x3f	; 63
    264e:	f8 94       	cli
    2650:	fa 9a       	sbi	0x1f, 2	; 31
    2652:	f9 9a       	sbi	0x1f, 1	; 31
    2654:	0f be       	out	0x3f, r0	; 63
	OmniComm_Reply_ok();
    2656:	0e 94 57 11 	call	0x22ae	; 0x22ae <OmniComm_Reply_ok>
}
    265a:	08 95       	ret

0000265c <Set_passw>:
					}
		}
	if(eeprom_read_byte(&passw) != 3)
		OmniComm_Reply_error();
		else*/
			OmniComm_Reply_ok();
    265c:	0e 94 57 11 	call	0x22ae	; 0x22ae <OmniComm_Reply_ok>
}
    2660:	08 95       	ret

00002662 <Set_filt_length>:
	/*		filt_length = DataBuffer0[3];
			eeprom_busy_wait();
			eeprom_write_byte(&e2_filt_length, filt_length);
			eeprom_busy_wait();
			eeprom_write_byte(&filt_length_accessed, 0);*/
			OmniComm_Reply_ok();
    2662:	0e 94 57 11 	call	0x22ae	; 0x22ae <OmniComm_Reply_ok>
		}
}
    2666:	08 95       	ret

00002668 <Set_trl>:
	/*trl = (unsigned int)DataBuffer0[4];
	trl <<= 8;
	trl |= (unsigned int)DataBuffer0[3];
	eeprom_busy_wait();
	eeprom_write_word(&e2_trl, trl);*/
	OmniComm_Reply_ok();
    2668:	0e 94 57 11 	call	0x22ae	; 0x22ae <OmniComm_Reply_ok>
}
    266c:	08 95       	ret

0000266e <Set_pwm_mod>:
void Set_pwm_mod (void)
{
	/*pwm_mode = DataBuffer0[3];
	eeprom_busy_wait();
	eeprom_write_byte(&e2_pwm_mode, pwm_mode);*/
	OmniComm_Reply_ok();
    266e:	0e 94 57 11 	call	0x22ae	; 0x22ae <OmniComm_Reply_ok>
}
    2672:	08 95       	ret

00002674 <Set_pwm_max>:
	/*pwm_max = (unsigned int)DataBuffer0[4];
	pwm_max <<= 8;
	pwm_max |= (unsigned int)DataBuffer0[3];
	eeprom_busy_wait();
	eeprom_write_word(&e2_pwm_max, pwm_max);*/
	OmniComm_Reply_ok();
    2674:	0e 94 57 11 	call	0x22ae	; 0x22ae <OmniComm_Reply_ok>
}
    2678:	08 95       	ret

0000267a <Set_fmax>:
	f_max_t <<= 8;
	f_max_t |= (unsigned int)DataBuffer0[3];
	eeprom_busy_wait();
	eeprom_write_word(&e2_f_max_t, f_max_t);
	f_max_t = eeprom_read_word(&e2_f_max_t);*/
	OmniComm_Reply_ok();
    267a:	0e 94 57 11 	call	0x22ae	; 0x22ae <OmniComm_Reply_ok>
}
    267e:	08 95       	ret

00002680 <Set_fmin>:
	f_min_t <<= 8;
	f_min_t |= (unsigned int)DataBuffer0[3];
	eeprom_busy_wait();
	eeprom_write_word(&e2_f_min_t, f_min_t);
	f_min_t = eeprom_read_word(&e2_f_min_t);*/
	OmniComm_Reply_ok();
    2680:	0e 94 57 11 	call	0x22ae	; 0x22ae <OmniComm_Reply_ok>
}
    2684:	08 95       	ret

00002686 <Tslope_t0>:
	k_t0 = DataBuffer0[3];
	eeprom_busy_wait();
	eeprom_write_word(&e2_k_t, k_t);
	eeprom_busy_wait();
	eeprom_write_byte(&e2_k_t0, k_t0);*/
	OmniComm_Reply_ok();
    2686:	0e 94 57 11 	call	0x22ae	; 0x22ae <OmniComm_Reply_ok>
}
    268a:	08 95       	ret

0000268c <Fcurr_fmax>:
	f_min_t = eeprom_read_word(&e2_f_min_t);
	OmniComm_Reply_ok();
}

void Fcurr_fmax (void)
{
    268c:	ef 92       	push	r14
    268e:	ff 92       	push	r15
    2690:	0f 93       	push	r16
    2692:	1f 93       	push	r17
void update_data(void);


void update_data(void)
{
	f_curr = (unsigned short)(1000.0 * VolumePercent);
    2694:	e0 90 38 01 	lds	r14, 0x0138
    2698:	f0 90 39 01 	lds	r15, 0x0139
    269c:	00 91 3a 01 	lds	r16, 0x013A
    26a0:	10 91 3b 01 	lds	r17, 0x013B
    26a4:	c8 01       	movw	r24, r16
    26a6:	b7 01       	movw	r22, r14
    26a8:	20 e0       	ldi	r18, 0x00	; 0
    26aa:	30 e0       	ldi	r19, 0x00	; 0
    26ac:	4a e7       	ldi	r20, 0x7A	; 122
    26ae:	54 e4       	ldi	r21, 0x44	; 68
    26b0:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__mulsf3>
    26b4:	0e 94 e1 1a 	call	0x35c2	; 0x35c2 <__fixunssfsi>
    26b8:	70 93 40 04 	sts	0x0440, r23
    26bc:	60 93 3f 04 	sts	0x043F, r22
	n = 1023.0 * VolumePercent;
    26c0:	c8 01       	movw	r24, r16
    26c2:	b7 01       	movw	r22, r14
    26c4:	20 e0       	ldi	r18, 0x00	; 0
    26c6:	30 ec       	ldi	r19, 0xC0	; 192
    26c8:	4f e7       	ldi	r20, 0x7F	; 127
    26ca:	54 e4       	ldi	r21, 0x44	; 68
    26cc:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__mulsf3>
    26d0:	0e 94 e1 1a 	call	0x35c2	; 0x35c2 <__fixunssfsi>
    26d4:	70 93 3a 04 	sts	0x043A, r23
    26d8:	60 93 39 04 	sts	0x0439, r22
{
	update_data();
/*	eeprom_busy_wait();
	eeprom_write_word(&e2_f_max_t, f_curr);
	f_max_t = eeprom_read_word(&e2_f_max_t);*/
	OmniComm_Reply_ok();
    26dc:	0e 94 57 11 	call	0x22ae	; 0x22ae <OmniComm_Reply_ok>
}
    26e0:	1f 91       	pop	r17
    26e2:	0f 91       	pop	r16
    26e4:	ff 90       	pop	r15
    26e6:	ef 90       	pop	r14
    26e8:	08 95       	ret

000026ea <Data_contin>:
	}
}

void Data_contin (unsigned int _type)
{
	if(_type == NEW_COMMAND_TYPE)
    26ea:	02 97       	sbiw	r24, 0x02	; 2
    26ec:	79 f4       	brne	.+30     	; 0x270c <Data_contin+0x22>
	{
		OmniComm_Reply_ok();
    26ee:	0e 94 57 11 	call	0x22ae	; 0x22ae <OmniComm_Reply_ok>
		
		omnicomm_command_type = NEW_COMMAND_TYPE;
    26f2:	82 e0       	ldi	r24, 0x02	; 2
    26f4:	80 93 31 04 	sts	0x0431, r24
		//Disable_auto_old_mode();
		report_on = 1;
    26f8:	91 e0       	ldi	r25, 0x01	; 1
    26fa:	90 93 50 04 	sts	0x0450, r25
		if(period_auto == 0)
    26fe:	80 91 1f 01 	lds	r24, 0x011F
    2702:	88 23       	and	r24, r24
    2704:	39 f5       	brne	.+78     	; 0x2754 <Data_contin+0x6a>
			period_auto = 1;		
    2706:	90 93 1f 01 	sts	0x011F, r25
    270a:	08 95       	ret
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    270c:	f9 99       	sbic	0x1f, 1	; 31
    270e:	fe cf       	rjmp	.-4      	; 0x270c <Data_contin+0x22>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    2710:	25 ec       	ldi	r18, 0xC5	; 197
    2712:	31 e0       	ldi	r19, 0x01	; 1
    2714:	32 bd       	out	0x22, r19	; 34
    2716:	21 bd       	out	0x21, r18	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2718:	f8 9a       	sbi	0x1f, 0	; 31
    271a:	80 b5       	in	r24, 0x20	; 32
	}
	else
	{		
		if(eeprom_read_byte(&e2_report_on))
    271c:	88 23       	and	r24, r24
    271e:	69 f0       	breq	.+26     	; 0x273a <Data_contin+0x50>
		{
			eeprom_busy_wait();
    2720:	f9 99       	sbic	0x1f, 1	; 31
    2722:	fe cf       	rjmp	.-4      	; 0x2720 <Data_contin+0x36>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2724:	f9 99       	sbic	0x1f, 1	; 31
    2726:	fe cf       	rjmp	.-4      	; 0x2724 <Data_contin+0x3a>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    2728:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    272a:	32 bd       	out	0x22, r19	; 34
    272c:	21 bd       	out	0x21, r18	; 33
#endif
    EEDR = __value;
    272e:	10 bc       	out	0x20, r1	; 32

    __asm__ __volatile__ (
    2730:	0f b6       	in	r0, 0x3f	; 63
    2732:	f8 94       	cli
    2734:	fa 9a       	sbi	0x1f, 2	; 31
    2736:	f9 9a       	sbi	0x1f, 1	; 31
    2738:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&e2_report_on, 0);
		}	

		Enable_auto_old_mode();
    273a:	0e 94 98 12 	call	0x2530	; 0x2530 <Enable_auto_old_mode>

		omnicomm_command_type = OLD_COMMAND_TYPE;
    273e:	91 e0       	ldi	r25, 0x01	; 1
    2740:	90 93 31 04 	sts	0x0431, r25
		report_on = 1;
    2744:	90 93 50 04 	sts	0x0450, r25
		if(period_auto == 0)
    2748:	80 91 1f 01 	lds	r24, 0x011F
    274c:	88 23       	and	r24, r24
    274e:	11 f4       	brne	.+4      	; 0x2754 <Data_contin+0x6a>
			period_auto = 1;		
    2750:	90 93 1f 01 	sts	0x011F, r25
    2754:	08 95       	ret

00002756 <Set_net_mode>:
	OmniComm_Reply_ok();
}

void Set_net_mode (void)
{
	net_mode = DataBuffer0[3];
    2756:	20 91 7a 01 	lds	r18, 0x017A
    275a:	20 93 53 04 	sts	0x0453, r18
	eeprom_busy_wait();
    275e:	f9 99       	sbic	0x1f, 1	; 31
    2760:	fe cf       	rjmp	.-4      	; 0x275e <Set_net_mode+0x8>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2762:	f9 99       	sbic	0x1f, 1	; 31
    2764:	fe cf       	rjmp	.-4      	; 0x2762 <Set_net_mode+0xc>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    2766:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    2768:	8e eb       	ldi	r24, 0xBE	; 190
    276a:	91 e0       	ldi	r25, 0x01	; 1
    276c:	92 bd       	out	0x22, r25	; 34
    276e:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    2770:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    2772:	0f b6       	in	r0, 0x3f	; 63
    2774:	f8 94       	cli
    2776:	fa 9a       	sbi	0x1f, 2	; 31
    2778:	f9 9a       	sbi	0x1f, 1	; 31
    277a:	0f be       	out	0x3f, r0	; 63
	eeprom_write_byte(&e2_net_mode, net_mode);
	OmniComm_Reply_ok();
    277c:	0e 94 57 11 	call	0x22ae	; 0x22ae <OmniComm_Reply_ok>
}
    2780:	08 95       	ret

00002782 <Set_addr>:
}

void Set_addr (void)
{
	unsigned char net_addr;
	net_addr = DataBuffer0[3];
    2782:	20 91 7a 01 	lds	r18, 0x017A
	eeprom_busy_wait();
    2786:	f9 99       	sbic	0x1f, 1	; 31
    2788:	fe cf       	rjmp	.-4      	; 0x2786 <Set_addr+0x4>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    278a:	f9 99       	sbic	0x1f, 1	; 31
    278c:	fe cf       	rjmp	.-4      	; 0x278a <Set_addr+0x8>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    278e:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    2790:	88 eb       	ldi	r24, 0xB8	; 184
    2792:	91 e0       	ldi	r25, 0x01	; 1
    2794:	92 bd       	out	0x22, r25	; 34
    2796:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    2798:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    279a:	0f b6       	in	r0, 0x3f	; 63
    279c:	f8 94       	cli
    279e:	fa 9a       	sbi	0x1f, 2	; 31
    27a0:	f9 9a       	sbi	0x1f, 1	; 31
    27a2:	0f be       	out	0x3f, r0	; 63

static inline void MBClientSetHostID0(byte host)
{
	//сохранить адрес этого клиента в EEPROM
	//в переменной hostID
	hostID0 = host;
    27a4:	20 93 00 01 	sts	0x0100, r18
	eeprom_write_byte(&EEP_ID0, net_addr);
	MBClientSetHostID0(net_addr);
	OmniComm_Reply_ok();
    27a8:	0e 94 57 11 	call	0x22ae	; 0x22ae <OmniComm_Reply_ok>
}
    27ac:	08 95       	ret

000027ae <Passw_read>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    27ae:	f9 99       	sbic	0x1f, 1	; 31
    27b0:	fe cf       	rjmp	.-4      	; 0x27ae <Passw_read>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    27b2:	84 ec       	ldi	r24, 0xC4	; 196
    27b4:	91 e0       	ldi	r25, 0x01	; 1
    27b6:	92 bd       	out	0x22, r25	; 34
    27b8:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    27ba:	f8 9a       	sbi	0x1f, 0	; 31
    27bc:	80 b5       	in	r24, 0x20	; 32
	OmniComm_Send_frame();
}

void Passw_read (void)
{
	DataBuffer0[3] = eeprom_read_byte(&e2_passw);
    27be:	80 93 7a 01 	sts	0x017A, r24
	omnicomm_frame_size = 5;
    27c2:	85 e0       	ldi	r24, 0x05	; 5
    27c4:	80 93 33 04 	sts	0x0433, r24
	OmniComm_Send_frame();
    27c8:	0e 94 27 11 	call	0x224e	; 0x224e <OmniComm_Send_frame>
}
    27cc:	08 95       	ret

000027ce <Filt_leng_read>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    27ce:	f9 99       	sbic	0x1f, 1	; 31
    27d0:	fe cf       	rjmp	.-4      	; 0x27ce <Filt_leng_read>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    27d2:	82 ec       	ldi	r24, 0xC2	; 194
    27d4:	91 e0       	ldi	r25, 0x01	; 1
    27d6:	92 bd       	out	0x22, r25	; 34
    27d8:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    27da:	f8 9a       	sbi	0x1f, 0	; 31
    27dc:	80 b5       	in	r24, 0x20	; 32
	OmniComm_Reply_ok();
}

void Filt_leng_read (void)
{
	filt_length = eeprom_read_byte(&e2_filt_length);
    27de:	80 93 47 04 	sts	0x0447, r24
	DataBuffer0[3] = filt_length;
    27e2:	80 93 7a 01 	sts	0x017A, r24
	omnicomm_frame_size = 5;
    27e6:	85 e0       	ldi	r24, 0x05	; 5
    27e8:	80 93 33 04 	sts	0x0433, r24
	OmniComm_Send_frame();
    27ec:	0e 94 27 11 	call	0x224e	; 0x224e <OmniComm_Send_frame>
}
    27f0:	08 95       	ret

000027f2 <Config_read>:
	OmniComm_Reply_ok();
}

void Config_read (void)
{
	DataBuffer0[6] = (unsigned char)(id >> 24);
    27f2:	20 91 49 04 	lds	r18, 0x0449
    27f6:	30 91 4a 04 	lds	r19, 0x044A
    27fa:	40 91 4b 04 	lds	r20, 0x044B
    27fe:	50 91 4c 04 	lds	r21, 0x044C
    2802:	85 2f       	mov	r24, r21
    2804:	99 27       	eor	r25, r25
    2806:	aa 27       	eor	r26, r26
    2808:	bb 27       	eor	r27, r27
    280a:	80 93 7d 01 	sts	0x017D, r24
	DataBuffer0[5] = (unsigned char)(id >> 16);
    280e:	ca 01       	movw	r24, r20
    2810:	aa 27       	eor	r26, r26
    2812:	bb 27       	eor	r27, r27
    2814:	80 93 7c 01 	sts	0x017C, r24
	DataBuffer0[4] = (unsigned char)(id >> 8);
    2818:	bb 27       	eor	r27, r27
    281a:	a5 2f       	mov	r26, r21
    281c:	94 2f       	mov	r25, r20
    281e:	83 2f       	mov	r24, r19
    2820:	80 93 7b 01 	sts	0x017B, r24
	DataBuffer0[3] = (unsigned char)id;
    2824:	20 93 7a 01 	sts	0x017A, r18
	DataBuffer0[8] = (unsigned char)(f_max_t >> 8);
    2828:	90 91 54 04 	lds	r25, 0x0454
    282c:	80 91 55 04 	lds	r24, 0x0455
    2830:	80 93 7f 01 	sts	0x017F, r24
	DataBuffer0[7] = (unsigned char)f_max_t;
    2834:	90 93 7e 01 	sts	0x017E, r25
	DataBuffer0[10] = (unsigned char)(f_min_t >> 8);
    2838:	90 91 51 04 	lds	r25, 0x0451
    283c:	80 91 52 04 	lds	r24, 0x0452
    2840:	80 93 81 01 	sts	0x0181, r24
	DataBuffer0[9] = (unsigned char)f_min_t;
    2844:	90 93 80 01 	sts	0x0180, r25
	DataBuffer0[12] = (unsigned char)(k_t >> 8);
    2848:	90 91 4d 04 	lds	r25, 0x044D
    284c:	80 91 4e 04 	lds	r24, 0x044E
    2850:	80 93 83 01 	sts	0x0183, r24
	DataBuffer0[11] = (unsigned char)k_t;
    2854:	90 93 82 01 	sts	0x0182, r25
	DataBuffer0[13] = k_t0;
    2858:	80 91 48 04 	lds	r24, 0x0448
    285c:	80 93 84 01 	sts	0x0184, r24
	DataBuffer0[15] = (unsigned char)(pwm_max >> 8);
    2860:	90 91 37 04 	lds	r25, 0x0437
    2864:	80 91 38 04 	lds	r24, 0x0438
    2868:	80 93 86 01 	sts	0x0186, r24
	DataBuffer0[14] = (unsigned char)pwm_max;
    286c:	90 93 85 01 	sts	0x0185, r25
	DataBuffer0[17] = (unsigned char)(trl >> 8);
    2870:	90 91 41 04 	lds	r25, 0x0441
    2874:	80 91 42 04 	lds	r24, 0x0442
    2878:	80 93 88 01 	sts	0x0188, r24
	DataBuffer0[16] = (unsigned char)trl;
    287c:	90 93 87 01 	sts	0x0187, r25
	DataBuffer0[18] = MBClientGetHostID0();
    2880:	80 91 00 01 	lds	r24, 0x0100
    2884:	80 93 89 01 	sts	0x0189, r24
	DataBuffer0[19] = net_mode;
    2888:	80 91 53 04 	lds	r24, 0x0453
    288c:	80 93 8a 01 	sts	0x018A, r24
	DataBuffer0[20] = pwm_mode;
    2890:	80 91 4f 04 	lds	r24, 0x044F
    2894:	80 93 8b 01 	sts	0x018B, r24
	omnicomm_frame_size = 22;
    2898:	86 e1       	ldi	r24, 0x16	; 22
    289a:	80 93 33 04 	sts	0x0433, r24
	OmniComm_Send_frame();
    289e:	0e 94 27 11 	call	0x224e	; 0x224e <OmniComm_Send_frame>
}
    28a2:	08 95       	ret

000028a4 <Id_read>:
		}
}

void Id_read (void)
{
	DataBuffer0[6] = (unsigned char)(id >> 24);
    28a4:	20 91 49 04 	lds	r18, 0x0449
    28a8:	30 91 4a 04 	lds	r19, 0x044A
    28ac:	40 91 4b 04 	lds	r20, 0x044B
    28b0:	50 91 4c 04 	lds	r21, 0x044C
    28b4:	85 2f       	mov	r24, r21
    28b6:	99 27       	eor	r25, r25
    28b8:	aa 27       	eor	r26, r26
    28ba:	bb 27       	eor	r27, r27
    28bc:	80 93 7d 01 	sts	0x017D, r24
	DataBuffer0[5] = (unsigned char)(id >> 16);
    28c0:	ca 01       	movw	r24, r20
    28c2:	aa 27       	eor	r26, r26
    28c4:	bb 27       	eor	r27, r27
    28c6:	80 93 7c 01 	sts	0x017C, r24
	DataBuffer0[4] = (unsigned char)(id >> 8);
    28ca:	bb 27       	eor	r27, r27
    28cc:	a5 2f       	mov	r26, r21
    28ce:	94 2f       	mov	r25, r20
    28d0:	83 2f       	mov	r24, r19
    28d2:	80 93 7b 01 	sts	0x017B, r24
	DataBuffer0[3] = (unsigned char)id;
    28d6:	20 93 7a 01 	sts	0x017A, r18
	omnicomm_frame_size = 8;
    28da:	88 e0       	ldi	r24, 0x08	; 8
    28dc:	80 93 33 04 	sts	0x0433, r24
	OmniComm_Send_frame();
    28e0:	0e 94 27 11 	call	0x224e	; 0x224e <OmniComm_Send_frame>
}
    28e4:	08 95       	ret

000028e6 <Fcurr_fmin>:
			period_auto = 1;		
	}
}

void Fcurr_fmin (void)
{
    28e6:	ef 92       	push	r14
    28e8:	ff 92       	push	r15
    28ea:	0f 93       	push	r16
    28ec:	1f 93       	push	r17
    28ee:	cf 93       	push	r28
    28f0:	df 93       	push	r29
void update_data(void);


void update_data(void)
{
	f_curr = (unsigned short)(1000.0 * VolumePercent);
    28f2:	e0 90 38 01 	lds	r14, 0x0138
    28f6:	f0 90 39 01 	lds	r15, 0x0139
    28fa:	00 91 3a 01 	lds	r16, 0x013A
    28fe:	10 91 3b 01 	lds	r17, 0x013B
    2902:	c8 01       	movw	r24, r16
    2904:	b7 01       	movw	r22, r14
    2906:	20 e0       	ldi	r18, 0x00	; 0
    2908:	30 e0       	ldi	r19, 0x00	; 0
    290a:	4a e7       	ldi	r20, 0x7A	; 122
    290c:	54 e4       	ldi	r21, 0x44	; 68
    290e:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__mulsf3>
    2912:	0e 94 e1 1a 	call	0x35c2	; 0x35c2 <__fixunssfsi>
    2916:	eb 01       	movw	r28, r22
    2918:	70 93 40 04 	sts	0x0440, r23
    291c:	60 93 3f 04 	sts	0x043F, r22
	n = 1023.0 * VolumePercent;
    2920:	c8 01       	movw	r24, r16
    2922:	b7 01       	movw	r22, r14
    2924:	20 e0       	ldi	r18, 0x00	; 0
    2926:	30 ec       	ldi	r19, 0xC0	; 192
    2928:	4f e7       	ldi	r20, 0x7F	; 127
    292a:	54 e4       	ldi	r21, 0x44	; 68
    292c:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__mulsf3>
    2930:	0e 94 e1 1a 	call	0x35c2	; 0x35c2 <__fixunssfsi>
    2934:	70 93 3a 04 	sts	0x043A, r23
    2938:	60 93 39 04 	sts	0x0439, r22
}

void Fcurr_fmin (void)
{
	update_data();
	eeprom_busy_wait();
    293c:	f9 99       	sbic	0x1f, 1	; 31
    293e:	fe cf       	rjmp	.-4      	; 0x293c <Fcurr_fmin+0x56>
    Write a word \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_word (uint16_t *__p, uint16_t __value)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_word (__p, __value, eeprom_write_byte);
    2940:	84 ed       	ldi	r24, 0xD4	; 212
    2942:	91 e0       	ldi	r25, 0x01	; 1
    2944:	be 01       	movw	r22, r28
    2946:	4e e5       	ldi	r20, 0x5E	; 94
    2948:	52 e1       	ldi	r21, 0x12	; 18
    294a:	0e 94 d5 19 	call	0x33aa	; 0x33aa <__eewr_word>
    Read one 16-bit word (little endian) from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint16_t eeprom_read_word (const uint16_t *__p)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    return __eerd_word (__p, eeprom_read_byte);
    294e:	84 ed       	ldi	r24, 0xD4	; 212
    2950:	91 e0       	ldi	r25, 0x01	; 1
    2952:	66 e5       	ldi	r22, 0x56	; 86
    2954:	72 e1       	ldi	r23, 0x12	; 18
    2956:	0e 94 a3 19 	call	0x3346	; 0x3346 <__eerd_word>
	eeprom_write_word(&e2_f_min_t, f_curr);
	f_min_t = eeprom_read_word(&e2_f_min_t);
    295a:	90 93 52 04 	sts	0x0452, r25
    295e:	80 93 51 04 	sts	0x0451, r24
	OmniComm_Reply_ok();
    2962:	0e 94 57 11 	call	0x22ae	; 0x22ae <OmniComm_Reply_ok>
}
    2966:	df 91       	pop	r29
    2968:	cf 91       	pop	r28
    296a:	1f 91       	pop	r17
    296c:	0f 91       	pop	r16
    296e:	ff 90       	pop	r15
    2970:	ef 90       	pop	r14
    2972:	08 95       	ret

00002974 <Data_read>:
	omnicomm_frame_size = 22;
	OmniComm_Send_frame();
}

void Data_read (unsigned int _type)
{
    2974:	af 92       	push	r10
    2976:	bf 92       	push	r11
    2978:	cf 92       	push	r12
    297a:	df 92       	push	r13
    297c:	ef 92       	push	r14
    297e:	ff 92       	push	r15
    2980:	0f 93       	push	r16
    2982:	1f 93       	push	r17
    2984:	df 93       	push	r29
    2986:	cf 93       	push	r28
    2988:	00 d0       	rcall	.+0      	; 0x298a <Data_read+0x16>
    298a:	00 d0       	rcall	.+0      	; 0x298c <Data_read+0x18>
    298c:	00 d0       	rcall	.+0      	; 0x298e <Data_read+0x1a>
    298e:	cd b7       	in	r28, 0x3d	; 61
    2990:	de b7       	in	r29, 0x3e	; 62
    2992:	a0 90 38 01 	lds	r10, 0x0138
    2996:	b0 90 39 01 	lds	r11, 0x0139
    299a:	c0 90 3a 01 	lds	r12, 0x013A
    299e:	d0 90 3b 01 	lds	r13, 0x013B
	char str[6];
	
	int i,length;
	if(_type == NEW_COMMAND_TYPE)
    29a2:	02 97       	sbiw	r24, 0x02	; 2
    29a4:	81 f5       	brne	.+96     	; 0x2a06 <Data_read+0x92>
void update_data(void);


void update_data(void)
{
	f_curr = (unsigned short)(1000.0 * VolumePercent);
    29a6:	c6 01       	movw	r24, r12
    29a8:	b5 01       	movw	r22, r10
    29aa:	20 e0       	ldi	r18, 0x00	; 0
    29ac:	30 e0       	ldi	r19, 0x00	; 0
    29ae:	4a e7       	ldi	r20, 0x7A	; 122
    29b0:	54 e4       	ldi	r21, 0x44	; 68
    29b2:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__mulsf3>
    29b6:	0e 94 e1 1a 	call	0x35c2	; 0x35c2 <__fixunssfsi>
    29ba:	7b 01       	movw	r14, r22
    29bc:	8c 01       	movw	r16, r24
    29be:	60 93 3f 04 	sts	0x043F, r22
    29c2:	f0 92 40 04 	sts	0x0440, r15
	n = 1023.0 * VolumePercent;
    29c6:	c6 01       	movw	r24, r12
    29c8:	b5 01       	movw	r22, r10
    29ca:	20 e0       	ldi	r18, 0x00	; 0
    29cc:	30 ec       	ldi	r19, 0xC0	; 192
    29ce:	4f e7       	ldi	r20, 0x7F	; 127
    29d0:	54 e4       	ldi	r21, 0x44	; 68
    29d2:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__mulsf3>
    29d6:	0e 94 e1 1a 	call	0x35c2	; 0x35c2 <__fixunssfsi>
    29da:	60 93 39 04 	sts	0x0439, r22
    29de:	70 93 3a 04 	sts	0x043A, r23
	
	int i,length;
	if(_type == NEW_COMMAND_TYPE)
	{
		update_data();
		DataBuffer0[3] = t;
    29e2:	20 91 36 04 	lds	r18, 0x0436
    29e6:	20 93 7a 01 	sts	0x017A, r18
		DataBuffer0[4] = (unsigned char)n;
    29ea:	60 93 7b 01 	sts	0x017B, r22
		DataBuffer0[5] = (unsigned char)(n >> 8);
    29ee:	70 93 7c 01 	sts	0x017C, r23
		DataBuffer0[6] = (unsigned char)f_curr;
    29f2:	e0 92 7d 01 	sts	0x017D, r14
		DataBuffer0[7] = (unsigned char)(f_curr >> 8);
    29f6:	f0 92 7e 01 	sts	0x017E, r15
		omnicomm_frame_size = 9;
    29fa:	89 e0       	ldi	r24, 0x09	; 9
    29fc:	80 93 33 04 	sts	0x0433, r24
		OmniComm_Send_frame();
    2a00:	0e 94 27 11 	call	0x224e	; 0x224e <OmniComm_Send_frame>
    2a04:	ea c0       	rjmp	.+468    	; 0x2bda <Data_read+0x266>
void update_data(void);


void update_data(void)
{
	f_curr = (unsigned short)(1000.0 * VolumePercent);
    2a06:	c6 01       	movw	r24, r12
    2a08:	b5 01       	movw	r22, r10
    2a0a:	20 e0       	ldi	r18, 0x00	; 0
    2a0c:	30 e0       	ldi	r19, 0x00	; 0
    2a0e:	4a e7       	ldi	r20, 0x7A	; 122
    2a10:	54 e4       	ldi	r21, 0x44	; 68
    2a12:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__mulsf3>
    2a16:	0e 94 e1 1a 	call	0x35c2	; 0x35c2 <__fixunssfsi>
    2a1a:	70 93 40 04 	sts	0x0440, r23
    2a1e:	60 93 3f 04 	sts	0x043F, r22
	n = 1023.0 * VolumePercent;
    2a22:	c6 01       	movw	r24, r12
    2a24:	b5 01       	movw	r22, r10
    2a26:	20 e0       	ldi	r18, 0x00	; 0
    2a28:	30 ec       	ldi	r19, 0xC0	; 192
    2a2a:	4f e7       	ldi	r20, 0x7F	; 127
    2a2c:	54 e4       	ldi	r21, 0x44	; 68
    2a2e:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__mulsf3>
    2a32:	0e 94 e1 1a 	call	0x35c2	; 0x35c2 <__fixunssfsi>
    2a36:	70 93 3a 04 	sts	0x043A, r23
    2a3a:	60 93 39 04 	sts	0x0439, r22
	else
	{
		
		//omnicomm_frame_size=0;
		update_data();
		strcpy((char *)DataBuffer0, "");
    2a3e:	87 e7       	ldi	r24, 0x77	; 119
    2a40:	91 e0       	ldi	r25, 0x01	; 1
    2a42:	64 e0       	ldi	r22, 0x04	; 4
    2a44:	71 e0       	ldi	r23, 0x01	; 1
    2a46:	0e 94 80 19 	call	0x3300	; 0x3300 <strcpy>
		
		//frequency
		strcat((char *)DataBuffer0, "F=");
    2a4a:	87 e7       	ldi	r24, 0x77	; 119
    2a4c:	91 e0       	ldi	r25, 0x01	; 1
    2a4e:	65 e0       	ldi	r22, 0x05	; 5
    2a50:	71 e0       	ldi	r23, 0x01	; 1
    2a52:	0e 94 75 19 	call	0x32ea	; 0x32ea <strcat>
		utoa(f_curr, str, 16);
    2a56:	80 91 3f 04 	lds	r24, 0x043F
    2a5a:	90 91 40 04 	lds	r25, 0x0440
    2a5e:	8e 01       	movw	r16, r28
    2a60:	0f 5f       	subi	r16, 0xFF	; 255
    2a62:	1f 4f       	sbci	r17, 0xFF	; 255
    2a64:	b8 01       	movw	r22, r16
    2a66:	40 e1       	ldi	r20, 0x10	; 16
    2a68:	50 e0       	ldi	r21, 0x00	; 0
    2a6a:	0e 94 ea 19 	call	0x33d4	; 0x33d4 <utoa>

		length=strlen(str);
    2a6e:	f8 01       	movw	r30, r16
    2a70:	01 90       	ld	r0, Z+
    2a72:	00 20       	and	r0, r0
    2a74:	e9 f7       	brne	.-6      	; 0x2a70 <Data_read+0xfc>
    2a76:	31 97       	sbiw	r30, 0x01	; 1
    2a78:	e0 1b       	sub	r30, r16
    2a7a:	f1 0b       	sbc	r31, r17
		if(length<4)
    2a7c:	e4 30       	cpi	r30, 0x04	; 4
    2a7e:	f1 05       	cpc	r31, r1
    2a80:	a4 f4       	brge	.+40     	; 0x2aaa <Data_read+0x136>
    2a82:	cc 24       	eor	r12, r12
    2a84:	dd 24       	eor	r13, r13
		{
			for(i=0; i<(4-length);i++)
    2a86:	04 e0       	ldi	r16, 0x04	; 4
    2a88:	10 e0       	ldi	r17, 0x00	; 0
    2a8a:	0e 1b       	sub	r16, r30
    2a8c:	1f 0b       	sbc	r17, r31
    2a8e:	09 c0       	rjmp	.+18     	; 0x2aa2 <Data_read+0x12e>
			{
				strcat((char *)DataBuffer0,"0");
    2a90:	87 e7       	ldi	r24, 0x77	; 119
    2a92:	91 e0       	ldi	r25, 0x01	; 1
    2a94:	68 e0       	ldi	r22, 0x08	; 8
    2a96:	71 e0       	ldi	r23, 0x01	; 1
    2a98:	0e 94 75 19 	call	0x32ea	; 0x32ea <strcat>
		utoa(f_curr, str, 16);

		length=strlen(str);
		if(length<4)
		{
			for(i=0; i<(4-length);i++)
    2a9c:	08 94       	sec
    2a9e:	c1 1c       	adc	r12, r1
    2aa0:	d1 1c       	adc	r13, r1
    2aa2:	c0 16       	cp	r12, r16
    2aa4:	d1 06       	cpc	r13, r17
    2aa6:	a4 f3       	brlt	.-24     	; 0x2a90 <Data_read+0x11c>
    2aa8:	07 c0       	rjmp	.+14     	; 0x2ab8 <Data_read+0x144>
				strcat((char *)DataBuffer0,"0");
			}
		}
		else
		{
			if(length>4)
    2aaa:	34 97       	sbiw	r30, 0x04	; 4
    2aac:	29 f0       	breq	.+10     	; 0x2ab8 <Data_read+0x144>
				strcpy(str,"0000");
    2aae:	c8 01       	movw	r24, r16
    2ab0:	6a e0       	ldi	r22, 0x0A	; 10
    2ab2:	71 e0       	ldi	r23, 0x01	; 1
    2ab4:	0e 94 80 19 	call	0x3300	; 0x3300 <strcpy>
		}
		strcat((char *)DataBuffer0, str);
    2ab8:	87 e7       	ldi	r24, 0x77	; 119
    2aba:	91 e0       	ldi	r25, 0x01	; 1
    2abc:	8e 01       	movw	r16, r28
    2abe:	0f 5f       	subi	r16, 0xFF	; 255
    2ac0:	1f 4f       	sbci	r17, 0xFF	; 255
    2ac2:	b8 01       	movw	r22, r16
    2ac4:	0e 94 75 19 	call	0x32ea	; 0x32ea <strcat>
		
		//temperature
		strcat((char *)DataBuffer0, " t=");
    2ac8:	87 e7       	ldi	r24, 0x77	; 119
    2aca:	91 e0       	ldi	r25, 0x01	; 1
    2acc:	6f e0       	ldi	r22, 0x0F	; 15
    2ace:	71 e0       	ldi	r23, 0x01	; 1
    2ad0:	0e 94 75 19 	call	0x32ea	; 0x32ea <strcat>
		utoa((unsigned int) t, str, 16);
    2ad4:	80 91 36 04 	lds	r24, 0x0436
    2ad8:	90 e0       	ldi	r25, 0x00	; 0
    2ada:	b8 01       	movw	r22, r16
    2adc:	40 e1       	ldi	r20, 0x10	; 16
    2ade:	50 e0       	ldi	r21, 0x00	; 0
    2ae0:	0e 94 ea 19 	call	0x33d4	; 0x33d4 <utoa>

		length=strlen(str);
    2ae4:	f8 01       	movw	r30, r16
    2ae6:	01 90       	ld	r0, Z+
    2ae8:	00 20       	and	r0, r0
    2aea:	e9 f7       	brne	.-6      	; 0x2ae6 <Data_read+0x172>
    2aec:	31 97       	sbiw	r30, 0x01	; 1
    2aee:	e0 1b       	sub	r30, r16
    2af0:	f1 0b       	sbc	r31, r17
		if(length<2)
    2af2:	e2 30       	cpi	r30, 0x02	; 2
    2af4:	f1 05       	cpc	r31, r1
    2af6:	a4 f4       	brge	.+40     	; 0x2b20 <Data_read+0x1ac>
    2af8:	cc 24       	eor	r12, r12
    2afa:	dd 24       	eor	r13, r13
			for(i=0; i<(2-length);i++)
    2afc:	02 e0       	ldi	r16, 0x02	; 2
    2afe:	10 e0       	ldi	r17, 0x00	; 0
    2b00:	0e 1b       	sub	r16, r30
    2b02:	1f 0b       	sbc	r17, r31
    2b04:	09 c0       	rjmp	.+18     	; 0x2b18 <Data_read+0x1a4>
				strcat((char *)DataBuffer0,"0");
    2b06:	87 e7       	ldi	r24, 0x77	; 119
    2b08:	91 e0       	ldi	r25, 0x01	; 1
    2b0a:	68 e0       	ldi	r22, 0x08	; 8
    2b0c:	71 e0       	ldi	r23, 0x01	; 1
    2b0e:	0e 94 75 19 	call	0x32ea	; 0x32ea <strcat>
		strcat((char *)DataBuffer0, " t=");
		utoa((unsigned int) t, str, 16);

		length=strlen(str);
		if(length<2)
			for(i=0; i<(2-length);i++)
    2b12:	08 94       	sec
    2b14:	c1 1c       	adc	r12, r1
    2b16:	d1 1c       	adc	r13, r1
    2b18:	c0 16       	cp	r12, r16
    2b1a:	d1 06       	cpc	r13, r17
    2b1c:	a4 f3       	brlt	.-24     	; 0x2b06 <Data_read+0x192>
    2b1e:	07 c0       	rjmp	.+14     	; 0x2b2e <Data_read+0x1ba>
				strcat((char *)DataBuffer0,"0");
		else if(length>2)		
    2b20:	32 97       	sbiw	r30, 0x02	; 2
    2b22:	29 f0       	breq	.+10     	; 0x2b2e <Data_read+0x1ba>
			strcpy(str,"00");
    2b24:	c8 01       	movw	r24, r16
    2b26:	63 e1       	ldi	r22, 0x13	; 19
    2b28:	71 e0       	ldi	r23, 0x01	; 1
    2b2a:	0e 94 80 19 	call	0x3300	; 0x3300 <strcpy>

		strcat((char *)DataBuffer0, str);
    2b2e:	87 e7       	ldi	r24, 0x77	; 119
    2b30:	91 e0       	ldi	r25, 0x01	; 1
    2b32:	8e 01       	movw	r16, r28
    2b34:	0f 5f       	subi	r16, 0xFF	; 255
    2b36:	1f 4f       	sbci	r17, 0xFF	; 255
    2b38:	b8 01       	movw	r22, r16
    2b3a:	0e 94 75 19 	call	0x32ea	; 0x32ea <strcat>
		
		//level
		strcat((char *)DataBuffer0, " N=");
    2b3e:	87 e7       	ldi	r24, 0x77	; 119
    2b40:	91 e0       	ldi	r25, 0x01	; 1
    2b42:	66 e1       	ldi	r22, 0x16	; 22
    2b44:	71 e0       	ldi	r23, 0x01	; 1
    2b46:	0e 94 75 19 	call	0x32ea	; 0x32ea <strcat>
		utoa(n, str, 16);
    2b4a:	80 91 39 04 	lds	r24, 0x0439
    2b4e:	90 91 3a 04 	lds	r25, 0x043A
    2b52:	b8 01       	movw	r22, r16
    2b54:	40 e1       	ldi	r20, 0x10	; 16
    2b56:	50 e0       	ldi	r21, 0x00	; 0
    2b58:	0e 94 ea 19 	call	0x33d4	; 0x33d4 <utoa>

		length=strlen(str);
    2b5c:	f8 01       	movw	r30, r16
    2b5e:	01 90       	ld	r0, Z+
    2b60:	00 20       	and	r0, r0
    2b62:	e9 f7       	brne	.-6      	; 0x2b5e <Data_read+0x1ea>
    2b64:	31 97       	sbiw	r30, 0x01	; 1
    2b66:	e0 1b       	sub	r30, r16
    2b68:	f1 0b       	sbc	r31, r17
		if(length<4)
    2b6a:	e4 30       	cpi	r30, 0x04	; 4
    2b6c:	f1 05       	cpc	r31, r1
    2b6e:	a4 f4       	brge	.+40     	; 0x2b98 <Data_read+0x224>
    2b70:	cc 24       	eor	r12, r12
    2b72:	dd 24       	eor	r13, r13
			for(i=0; i<(4-length);i++)
    2b74:	04 e0       	ldi	r16, 0x04	; 4
    2b76:	10 e0       	ldi	r17, 0x00	; 0
    2b78:	0e 1b       	sub	r16, r30
    2b7a:	1f 0b       	sbc	r17, r31
    2b7c:	09 c0       	rjmp	.+18     	; 0x2b90 <Data_read+0x21c>
				strcat((char *)DataBuffer0,"0");
    2b7e:	87 e7       	ldi	r24, 0x77	; 119
    2b80:	91 e0       	ldi	r25, 0x01	; 1
    2b82:	68 e0       	ldi	r22, 0x08	; 8
    2b84:	71 e0       	ldi	r23, 0x01	; 1
    2b86:	0e 94 75 19 	call	0x32ea	; 0x32ea <strcat>
		strcat((char *)DataBuffer0, " N=");
		utoa(n, str, 16);

		length=strlen(str);
		if(length<4)
			for(i=0; i<(4-length);i++)
    2b8a:	08 94       	sec
    2b8c:	c1 1c       	adc	r12, r1
    2b8e:	d1 1c       	adc	r13, r1
    2b90:	c0 16       	cp	r12, r16
    2b92:	d1 06       	cpc	r13, r17
    2b94:	a4 f3       	brlt	.-24     	; 0x2b7e <Data_read+0x20a>
    2b96:	07 c0       	rjmp	.+14     	; 0x2ba6 <Data_read+0x232>
				strcat((char *)DataBuffer0,"0");
		else if(length>4)		
    2b98:	34 97       	sbiw	r30, 0x04	; 4
    2b9a:	29 f0       	breq	.+10     	; 0x2ba6 <Data_read+0x232>
			strcpy(str,"0000");
    2b9c:	c8 01       	movw	r24, r16
    2b9e:	6a e0       	ldi	r22, 0x0A	; 10
    2ba0:	71 e0       	ldi	r23, 0x01	; 1
    2ba2:	0e 94 80 19 	call	0x3300	; 0x3300 <strcpy>

		strcat((char *)DataBuffer0, str);/**/
    2ba6:	07 e7       	ldi	r16, 0x77	; 119
    2ba8:	11 e0       	ldi	r17, 0x01	; 1
    2baa:	c8 01       	movw	r24, r16
    2bac:	be 01       	movw	r22, r28
    2bae:	6f 5f       	subi	r22, 0xFF	; 255
    2bb0:	7f 4f       	sbci	r23, 0xFF	; 255
    2bb2:	0e 94 75 19 	call	0x32ea	; 0x32ea <strcat>
		strcat((char *)DataBuffer0, ".0\n\r");
    2bb6:	c8 01       	movw	r24, r16
    2bb8:	6a e1       	ldi	r22, 0x1A	; 26
    2bba:	71 e0       	ldi	r23, 0x01	; 1
    2bbc:	0e 94 75 19 	call	0x32ea	; 0x32ea <strcat>

		omnicomm_frame_size=strlen((char *)DataBuffer0);
    2bc0:	f8 01       	movw	r30, r16
    2bc2:	01 90       	ld	r0, Z+
    2bc4:	00 20       	and	r0, r0
    2bc6:	e9 f7       	brne	.-6      	; 0x2bc2 <Data_read+0x24e>
    2bc8:	8f 01       	movw	r16, r30
    2bca:	01 50       	subi	r16, 0x01	; 1
    2bcc:	10 40       	sbci	r17, 0x00	; 0
    2bce:	07 57       	subi	r16, 0x77	; 119
    2bd0:	11 40       	sbci	r17, 0x01	; 1
    2bd2:	00 93 33 04 	sts	0x0433, r16
		
		OmniComm_Send_frame_old_data();
    2bd6:	0e 94 95 10 	call	0x212a	; 0x212a <OmniComm_Send_frame_old_data>
	}
}
    2bda:	26 96       	adiw	r28, 0x06	; 6
    2bdc:	0f b6       	in	r0, 0x3f	; 63
    2bde:	f8 94       	cli
    2be0:	de bf       	out	0x3e, r29	; 62
    2be2:	0f be       	out	0x3f, r0	; 63
    2be4:	cd bf       	out	0x3d, r28	; 61
    2be6:	cf 91       	pop	r28
    2be8:	df 91       	pop	r29
    2bea:	1f 91       	pop	r17
    2bec:	0f 91       	pop	r16
    2bee:	ff 90       	pop	r15
    2bf0:	ef 90       	pop	r14
    2bf2:	df 90       	pop	r13
    2bf4:	cf 90       	pop	r12
    2bf6:	bf 90       	pop	r11
    2bf8:	af 90       	pop	r10
    2bfa:	08 95       	ret

00002bfc <Set_id>:
		else
			my_addr = net_addr;*/
}

void Set_id (void)
{
    2bfc:	cf 93       	push	r28
    2bfe:	df 93       	push	r29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2c00:	f9 99       	sbic	0x1f, 1	; 31
    2c02:	fe cf       	rjmp	.-4      	; 0x2c00 <Set_id+0x4>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    2c04:	c8 ee       	ldi	r28, 0xE8	; 232
    2c06:	d1 e0       	ldi	r29, 0x01	; 1
    2c08:	d2 bd       	out	0x22, r29	; 34
    2c0a:	c1 bd       	out	0x21, r28	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2c0c:	f8 9a       	sbi	0x1f, 0	; 31
    2c0e:	80 b5       	in	r24, 0x20	; 32
	if (eeprom_read_byte(&id_was_set))//id уже записали?
    2c10:	88 23       	and	r24, r24
    2c12:	09 f0       	breq	.+2      	; 0x2c16 <Set_id+0x1a>
    2c14:	50 c0       	rjmp	.+160    	; 0x2cb6 <Set_id+0xba>
		return;
		else
		{
			id = (unsigned long)DataBuffer0[6];
			id <<= 8;
			id |= (unsigned long)DataBuffer0[5];
    2c16:	80 91 7d 01 	lds	r24, 0x017D
    2c1a:	90 e0       	ldi	r25, 0x00	; 0
    2c1c:	a0 e0       	ldi	r26, 0x00	; 0
    2c1e:	b0 e0       	ldi	r27, 0x00	; 0
    2c20:	ba 2f       	mov	r27, r26
    2c22:	a9 2f       	mov	r26, r25
    2c24:	98 2f       	mov	r25, r24
    2c26:	88 27       	eor	r24, r24
    2c28:	20 91 7c 01 	lds	r18, 0x017C
    2c2c:	30 e0       	ldi	r19, 0x00	; 0
    2c2e:	40 e0       	ldi	r20, 0x00	; 0
    2c30:	50 e0       	ldi	r21, 0x00	; 0
    2c32:	82 2b       	or	r24, r18
    2c34:	93 2b       	or	r25, r19
    2c36:	a4 2b       	or	r26, r20
    2c38:	b5 2b       	or	r27, r21
			id <<= 8;
			id |= (unsigned long)DataBuffer0[4];
    2c3a:	ba 2f       	mov	r27, r26
    2c3c:	a9 2f       	mov	r26, r25
    2c3e:	98 2f       	mov	r25, r24
    2c40:	88 27       	eor	r24, r24
    2c42:	20 91 7b 01 	lds	r18, 0x017B
    2c46:	30 e0       	ldi	r19, 0x00	; 0
    2c48:	40 e0       	ldi	r20, 0x00	; 0
    2c4a:	50 e0       	ldi	r21, 0x00	; 0
    2c4c:	82 2b       	or	r24, r18
    2c4e:	93 2b       	or	r25, r19
    2c50:	a4 2b       	or	r26, r20
    2c52:	b5 2b       	or	r27, r21
			id <<= 8;
			id |= (unsigned long)DataBuffer0[3];
    2c54:	ba 2f       	mov	r27, r26
    2c56:	a9 2f       	mov	r26, r25
    2c58:	98 2f       	mov	r25, r24
    2c5a:	88 27       	eor	r24, r24
    2c5c:	20 91 7a 01 	lds	r18, 0x017A
    2c60:	30 e0       	ldi	r19, 0x00	; 0
    2c62:	40 e0       	ldi	r20, 0x00	; 0
    2c64:	50 e0       	ldi	r21, 0x00	; 0
    2c66:	82 2b       	or	r24, r18
    2c68:	93 2b       	or	r25, r19
    2c6a:	a4 2b       	or	r26, r20
    2c6c:	b5 2b       	or	r27, r21
    2c6e:	80 93 49 04 	sts	0x0449, r24
    2c72:	90 93 4a 04 	sts	0x044A, r25
    2c76:	a0 93 4b 04 	sts	0x044B, r26
    2c7a:	b0 93 4c 04 	sts	0x044C, r27
			eeprom_busy_wait();
    2c7e:	f9 99       	sbic	0x1f, 1	; 31
    2c80:	fe cf       	rjmp	.-4      	; 0x2c7e <Set_id+0x82>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    2c82:	8c ed       	ldi	r24, 0xDC	; 220
    2c84:	91 e0       	ldi	r25, 0x01	; 1
    2c86:	69 e4       	ldi	r22, 0x49	; 73
    2c88:	74 e0       	ldi	r23, 0x04	; 4
    2c8a:	44 e0       	ldi	r20, 0x04	; 4
    2c8c:	50 e0       	ldi	r21, 0x00	; 0
    2c8e:	2e e5       	ldi	r18, 0x5E	; 94
    2c90:	32 e1       	ldi	r19, 0x12	; 18
    2c92:	0e 94 b9 19 	call	0x3372	; 0x3372 <__eewr_block>
			eeprom_write_block(&id, &e2_id, 4);
			eeprom_busy_wait();
    2c96:	f9 99       	sbic	0x1f, 1	; 31
    2c98:	fe cf       	rjmp	.-4      	; 0x2c96 <Set_id+0x9a>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2c9a:	f9 99       	sbic	0x1f, 1	; 31
    2c9c:	fe cf       	rjmp	.-4      	; 0x2c9a <Set_id+0x9e>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    2c9e:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    2ca0:	d2 bd       	out	0x22, r29	; 34
    2ca2:	c1 bd       	out	0x21, r28	; 33
#endif
    EEDR = __value;
    2ca4:	81 e0       	ldi	r24, 0x01	; 1
    2ca6:	80 bd       	out	0x20, r24	; 32

    __asm__ __volatile__ (
    2ca8:	0f b6       	in	r0, 0x3f	; 63
    2caa:	f8 94       	cli
    2cac:	fa 9a       	sbi	0x1f, 2	; 31
    2cae:	f9 9a       	sbi	0x1f, 1	; 31
    2cb0:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&id_was_set, 1);//признак того, что id уже записан
			OmniComm_Reply_ok();
    2cb2:	0e 94 57 11 	call	0x22ae	; 0x22ae <OmniComm_Reply_ok>
		}
}
    2cb6:	df 91       	pop	r29
    2cb8:	cf 91       	pop	r28
    2cba:	08 95       	ret

00002cbc <Read_parameters>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2cbc:	f9 99       	sbic	0x1f, 1	; 31
    2cbe:	fe cf       	rjmp	.-4      	; 0x2cbc <Read_parameters>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    2cc0:	8e eb       	ldi	r24, 0xBE	; 190
    2cc2:	91 e0       	ldi	r25, 0x01	; 1
    2cc4:	92 bd       	out	0x22, r25	; 34
    2cc6:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2cc8:	f8 9a       	sbi	0x1f, 0	; 31
    2cca:	80 b5       	in	r24, 0x20	; 32

void Read_parameters (void)
{
	unsigned char a,b;

	net_mode = eeprom_read_byte(&e2_net_mode);
    2ccc:	80 93 53 04 	sts	0x0453, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2cd0:	f9 99       	sbic	0x1f, 1	; 31
    2cd2:	fe cf       	rjmp	.-4      	; 0x2cd0 <Read_parameters+0x14>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    2cd4:	8f eb       	ldi	r24, 0xBF	; 191
    2cd6:	91 e0       	ldi	r25, 0x01	; 1
    2cd8:	92 bd       	out	0x22, r25	; 34
    2cda:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2cdc:	f8 9a       	sbi	0x1f, 0	; 31
    2cde:	80 b5       	in	r24, 0x20	; 32
	k_t0 = eeprom_read_byte(&e2_k_t0);
    2ce0:	80 93 48 04 	sts	0x0448, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2ce4:	f9 99       	sbic	0x1f, 1	; 31
    2ce6:	fe cf       	rjmp	.-4      	; 0x2ce4 <Read_parameters+0x28>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    2ce8:	81 ec       	ldi	r24, 0xC1	; 193
    2cea:	91 e0       	ldi	r25, 0x01	; 1
    2cec:	92 bd       	out	0x22, r25	; 34
    2cee:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2cf0:	f8 9a       	sbi	0x1f, 0	; 31
    2cf2:	80 b5       	in	r24, 0x20	; 32
	pwm_mode = eeprom_read_byte(&e2_pwm_mode);
    2cf4:	80 93 4f 04 	sts	0x044F, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2cf8:	f9 99       	sbic	0x1f, 1	; 31
    2cfa:	fe cf       	rjmp	.-4      	; 0x2cf8 <Read_parameters+0x3c>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    2cfc:	82 ec       	ldi	r24, 0xC2	; 194
    2cfe:	91 e0       	ldi	r25, 0x01	; 1
    2d00:	92 bd       	out	0x22, r25	; 34
    2d02:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2d04:	f8 9a       	sbi	0x1f, 0	; 31
    2d06:	80 b5       	in	r24, 0x20	; 32
	filt_length = eeprom_read_byte(&e2_filt_length);
    2d08:	80 93 47 04 	sts	0x0447, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2d0c:	f9 99       	sbic	0x1f, 1	; 31
    2d0e:	fe cf       	rjmp	.-4      	; 0x2d0c <Read_parameters+0x50>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    2d10:	83 ec       	ldi	r24, 0xC3	; 195
    2d12:	91 e0       	ldi	r25, 0x01	; 1
    2d14:	92 bd       	out	0x22, r25	; 34
    2d16:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2d18:	f8 9a       	sbi	0x1f, 0	; 31
    2d1a:	80 b5       	in	r24, 0x20	; 32
	period_auto = eeprom_read_byte(&e2_period_auto);
    2d1c:	80 93 1f 01 	sts	0x011F, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2d20:	f9 99       	sbic	0x1f, 1	; 31
    2d22:	fe cf       	rjmp	.-4      	; 0x2d20 <Read_parameters+0x64>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    2d24:	44 ec       	ldi	r20, 0xC4	; 196
    2d26:	51 e0       	ldi	r21, 0x01	; 1
    2d28:	52 bd       	out	0x22, r21	; 34
    2d2a:	41 bd       	out	0x21, r20	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2d2c:	f8 9a       	sbi	0x1f, 0	; 31
    2d2e:	80 b5       	in	r24, 0x20	; 32
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2d30:	f9 99       	sbic	0x1f, 1	; 31
    2d32:	fe cf       	rjmp	.-4      	; 0x2d30 <Read_parameters+0x74>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    2d34:	85 ec       	ldi	r24, 0xC5	; 197
    2d36:	91 e0       	ldi	r25, 0x01	; 1
    2d38:	92 bd       	out	0x22, r25	; 34
    2d3a:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2d3c:	f8 9a       	sbi	0x1f, 0	; 31
    2d3e:	20 b5       	in	r18, 0x20	; 32
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2d40:	f9 99       	sbic	0x1f, 1	; 31
    2d42:	fe cf       	rjmp	.-4      	; 0x2d40 <Read_parameters+0x84>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    2d44:	8a ee       	ldi	r24, 0xEA	; 234
    2d46:	91 e0       	ldi	r25, 0x01	; 1
    2d48:	92 bd       	out	0x22, r25	; 34
    2d4a:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2d4c:	f8 9a       	sbi	0x1f, 0	; 31
    2d4e:	80 b5       	in	r24, 0x20	; 32
	passw = eeprom_read_byte(&e2_passw);

	a=eeprom_read_byte(&e2_report_on);
	b=eeprom_read_byte(&old_contin);

	if(a)
    2d50:	22 23       	and	r18, r18
    2d52:	29 f0       	breq	.+10     	; 0x2d5e <Read_parameters+0xa2>
	{
		report_on = 1;
    2d54:	81 e0       	ldi	r24, 0x01	; 1
    2d56:	80 93 50 04 	sts	0x0450, r24
		omnicomm_command_type = NEW_COMMAND_TYPE;
    2d5a:	82 e0       	ldi	r24, 0x02	; 2
    2d5c:	05 c0       	rjmp	.+10     	; 0x2d68 <Read_parameters+0xac>
	}
	else if(b)
    2d5e:	88 23       	and	r24, r24
    2d60:	31 f0       	breq	.+12     	; 0x2d6e <Read_parameters+0xb2>
	{
		report_on =	1;
    2d62:	81 e0       	ldi	r24, 0x01	; 1
    2d64:	80 93 50 04 	sts	0x0450, r24
		omnicomm_command_type = OLD_COMMAND_TYPE;
    2d68:	80 93 31 04 	sts	0x0431, r24
    2d6c:	02 c0       	rjmp	.+4      	; 0x2d72 <Read_parameters+0xb6>
	}
	else
		report_on = 0;
    2d6e:	10 92 50 04 	sts	0x0450, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2d72:	f9 99       	sbic	0x1f, 1	; 31
    2d74:	fe cf       	rjmp	.-4      	; 0x2d72 <Read_parameters+0xb6>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    2d76:	52 bd       	out	0x22, r21	; 34
    2d78:	41 bd       	out	0x21, r20	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2d7a:	f8 9a       	sbi	0x1f, 0	; 31
    2d7c:	80 b5       	in	r24, 0x20	; 32

	passw = eeprom_read_byte(&e2_passw);
    2d7e:	80 93 bd 01 	sts	0x01BD, r24
    Read one 16-bit word (little endian) from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint16_t eeprom_read_word (const uint16_t *__p)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    return __eerd_word (__p, eeprom_read_byte);
    2d82:	82 ed       	ldi	r24, 0xD2	; 210
    2d84:	91 e0       	ldi	r25, 0x01	; 1
    2d86:	66 e5       	ldi	r22, 0x56	; 86
    2d88:	72 e1       	ldi	r23, 0x12	; 18
    2d8a:	0e 94 a3 19 	call	0x3346	; 0x3346 <__eerd_word>

	k_t = eeprom_read_word(&e2_k_t);
    2d8e:	90 93 4e 04 	sts	0x044E, r25
    2d92:	80 93 4d 04 	sts	0x044D, r24
    2d96:	84 ed       	ldi	r24, 0xD4	; 212
    2d98:	91 e0       	ldi	r25, 0x01	; 1
    2d9a:	66 e5       	ldi	r22, 0x56	; 86
    2d9c:	72 e1       	ldi	r23, 0x12	; 18
    2d9e:	0e 94 a3 19 	call	0x3346	; 0x3346 <__eerd_word>
	f_min_t = eeprom_read_word(&e2_f_min_t);
    2da2:	90 93 52 04 	sts	0x0452, r25
    2da6:	80 93 51 04 	sts	0x0451, r24
    2daa:	86 ed       	ldi	r24, 0xD6	; 214
    2dac:	91 e0       	ldi	r25, 0x01	; 1
    2dae:	66 e5       	ldi	r22, 0x56	; 86
    2db0:	72 e1       	ldi	r23, 0x12	; 18
    2db2:	0e 94 a3 19 	call	0x3346	; 0x3346 <__eerd_word>
	f_max_t = eeprom_read_word(&e2_f_max_t);
    2db6:	90 93 55 04 	sts	0x0455, r25
    2dba:	80 93 54 04 	sts	0x0454, r24
    2dbe:	88 ed       	ldi	r24, 0xD8	; 216
    2dc0:	91 e0       	ldi	r25, 0x01	; 1
    2dc2:	66 e5       	ldi	r22, 0x56	; 86
    2dc4:	72 e1       	ldi	r23, 0x12	; 18
    2dc6:	0e 94 a3 19 	call	0x3346	; 0x3346 <__eerd_word>
	pwm_max = eeprom_read_word(&e2_pwm_max);
    2dca:	90 93 38 04 	sts	0x0438, r25
    2dce:	80 93 37 04 	sts	0x0437, r24
    2dd2:	8a ed       	ldi	r24, 0xDA	; 218
    2dd4:	91 e0       	ldi	r25, 0x01	; 1
    2dd6:	66 e5       	ldi	r22, 0x56	; 86
    2dd8:	72 e1       	ldi	r23, 0x12	; 18
    2dda:	0e 94 a3 19 	call	0x3346	; 0x3346 <__eerd_word>
	trl = eeprom_read_word(&e2_trl);
    2dde:	90 93 42 04 	sts	0x0442, r25
    2de2:	80 93 41 04 	sts	0x0441, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    2de6:	89 e4       	ldi	r24, 0x49	; 73
    2de8:	94 e0       	ldi	r25, 0x04	; 4
    2dea:	6c ed       	ldi	r22, 0xDC	; 220
    2dec:	71 e0       	ldi	r23, 0x01	; 1
    2dee:	44 e0       	ldi	r20, 0x04	; 4
    2df0:	50 e0       	ldi	r21, 0x00	; 0
    2df2:	26 e5       	ldi	r18, 0x56	; 86
    2df4:	32 e1       	ldi	r19, 0x12	; 18
    2df6:	0e 94 87 19 	call	0x330e	; 0x330e <__eerd_block>

	eeprom_read_block(&id, &e2_id, 4);

	if(period_auto == 0)
    2dfa:	80 91 1f 01 	lds	r24, 0x011F
    2dfe:	88 23       	and	r24, r24
    2e00:	19 f4       	brne	.+6      	; 0x2e08 <Read_parameters+0x14c>
		period_auto = 1;
    2e02:	81 e0       	ldi	r24, 0x01	; 1
    2e04:	80 93 1f 01 	sts	0x011F, r24
    2e08:	08 95       	ret

00002e0a <crc8>:
#include "crc8.h"

unsigned char crc8 (unsigned char byte, unsigned char crc)
{
    2e0a:	28 2f       	mov	r18, r24
    2e0c:	98 e0       	ldi	r25, 0x08	; 8
	unsigned char i = 8;

	do
	{
		if ((byte ^ crc) & 0x01)
			crc = ((crc ^ 0x18) >>1) | 0x80;
    2e0e:	38 e1       	ldi	r19, 0x18	; 24
{
	unsigned char i = 8;

	do
	{
		if ((byte ^ crc) & 0x01)
    2e10:	86 2f       	mov	r24, r22
    2e12:	82 27       	eor	r24, r18
    2e14:	80 ff       	sbrs	r24, 0
    2e16:	04 c0       	rjmp	.+8      	; 0x2e20 <crc8+0x16>
			crc = ((crc ^ 0x18) >>1) | 0x80;
    2e18:	63 27       	eor	r22, r19
    2e1a:	66 95       	lsr	r22
    2e1c:	60 68       	ori	r22, 0x80	; 128
    2e1e:	01 c0       	rjmp	.+2      	; 0x2e22 <crc8+0x18>
			else
				crc >>= 1;
    2e20:	66 95       	lsr	r22
		byte >>= 1;
	} while (--i);
    2e22:	91 50       	subi	r25, 0x01	; 1
    2e24:	11 f0       	breq	.+4      	; 0x2e2a <crc8+0x20>
	{
		if ((byte ^ crc) & 0x01)
			crc = ((crc ^ 0x18) >>1) | 0x80;
			else
				crc >>= 1;
		byte >>= 1;
    2e26:	26 95       	lsr	r18
    2e28:	f3 cf       	rjmp	.-26     	; 0x2e10 <crc8+0x6>
	} while (--i);
	return(crc);
}
    2e2a:	86 2f       	mov	r24, r22
    2e2c:	08 95       	ret

00002e2e <ADCSetChannel>:
volatile double ADCRef = 0;

inline void ADCSetChannel(unsigned char channel)
{
    channel &= 0x0F;
    channel |= (ADMUX & 0xF0);
    2e2e:	ec e7       	ldi	r30, 0x7C	; 124
    2e30:	f0 e0       	ldi	r31, 0x00	; 0
    2e32:	90 81       	ld	r25, Z
    2e34:	8f 70       	andi	r24, 0x0F	; 15
    2e36:	90 7f       	andi	r25, 0xF0	; 240
    2e38:	89 2b       	or	r24, r25
    ADMUX = channel;
    2e3a:	80 83       	st	Z, r24
}
    2e3c:	08 95       	ret

00002e3e <ADCInit>:

inline void ADCInit(void)
{
    DIDR0 |= (1<<DIDR_AIN_U) | (1<<DIDR_AIN_I);
    2e3e:	ee e7       	ldi	r30, 0x7E	; 126
    2e40:	f0 e0       	ldi	r31, 0x00	; 0
    2e42:	80 81       	ld	r24, Z
    2e44:	80 63       	ori	r24, 0x30	; 48
    2e46:	80 83       	st	Z, r24
    
    cbi(PRR,  PRADC);   //On ADC
    2e48:	e4 e6       	ldi	r30, 0x64	; 100
    2e4a:	f0 e0       	ldi	r31, 0x00	; 0
    2e4c:	80 81       	ld	r24, Z
    2e4e:	8e 7f       	andi	r24, 0xFE	; 254
    2e50:	80 83       	st	Z, r24

    ADC_SET_REF_VCC;
    2e52:	ec e7       	ldi	r30, 0x7C	; 124
    2e54:	f0 e0       	ldi	r31, 0x00	; 0
    2e56:	80 81       	ld	r24, Z
    2e58:	8f 77       	andi	r24, 0x7F	; 127
    2e5a:	80 83       	st	Z, r24
    2e5c:	80 81       	ld	r24, Z
    2e5e:	80 64       	ori	r24, 0x40	; 64
    2e60:	80 83       	st	Z, r24
    2e62:	80 e0       	ldi	r24, 0x00	; 0
    2e64:	90 e0       	ldi	r25, 0x00	; 0
    2e66:	a0 ea       	ldi	r26, 0xA0	; 160
    2e68:	b0 e4       	ldi	r27, 0x40	; 64
    2e6a:	80 93 43 01 	sts	0x0143, r24
    2e6e:	90 93 44 01 	sts	0x0144, r25
    2e72:	a0 93 45 01 	sts	0x0145, r26
    2e76:	b0 93 46 01 	sts	0x0146, r27
volatile double ADCRef = 0;

inline void ADCSetChannel(unsigned char channel)
{
    channel &= 0x0F;
    channel |= (ADMUX & 0xF0);
    2e7a:	80 81       	ld	r24, Z
    2e7c:	80 7f       	andi	r24, 0xF0	; 240
    2e7e:	86 60       	ori	r24, 0x06	; 6
    ADMUX = channel;
    2e80:	80 83       	st	Z, r24

    ADC_SET_REF_VCC;
    ADCSetChannel(AIN_U_CHANNEL);

	//Clock Speed
	ADCSRA |= ADC_CLOCK_DIVIDER; 
    2e82:	ea e7       	ldi	r30, 0x7A	; 122
    2e84:	f0 e0       	ldi	r31, 0x00	; 0
    2e86:	80 81       	ld	r24, Z
    2e88:	86 60       	ori	r24, 0x06	; 6
    2e8a:	80 83       	st	Z, r24
    sbi(ADCSRA, ADEN);    // On ADC
    2e8c:	80 81       	ld	r24, Z
    2e8e:	80 68       	ori	r24, 0x80	; 128
    2e90:	80 83       	st	Z, r24

}
    2e92:	08 95       	ret

00002e94 <ADCRead>:

inline unsigned short ADCRead()
{
    sbi(ADCSRA, ADSC);           //Start conversion
    2e94:	80 91 7a 00 	lds	r24, 0x007A
    2e98:	80 64       	ori	r24, 0x40	; 64
    2e9a:	80 93 7a 00 	sts	0x007A, r24
     
    while (!(ADCSRA & (1<<ADIF)));    //wait for conversion complete
    2e9e:	80 91 7a 00 	lds	r24, 0x007A
    2ea2:	84 ff       	sbrs	r24, 4
    2ea4:	fc cf       	rjmp	.-8      	; 0x2e9e <ADCRead+0xa>
    
    ADCSRA |= (1<<ADIF);        //Clear flag;
    2ea6:	80 91 7a 00 	lds	r24, 0x007A
    2eaa:	80 61       	ori	r24, 0x10	; 16
    2eac:	80 93 7a 00 	sts	0x007A, r24

    return ADC;
    2eb0:	20 91 78 00 	lds	r18, 0x0078
    2eb4:	30 91 79 00 	lds	r19, 0x0079
}
    2eb8:	c9 01       	movw	r24, r18
    2eba:	08 95       	ret

00002ebc <ADCGetRoundedValue>:

double refValue = 0;
inline double ADCGetRoundedValue(unsigned char channel)
{
    2ebc:	6f 92       	push	r6
    2ebe:	7f 92       	push	r7
    2ec0:	8f 92       	push	r8
    2ec2:	9f 92       	push	r9
    2ec4:	af 92       	push	r10
    2ec6:	bf 92       	push	r11
    2ec8:	cf 92       	push	r12
    2eca:	df 92       	push	r13
    2ecc:	ef 92       	push	r14
    2ece:	ff 92       	push	r15
    2ed0:	0f 93       	push	r16
    2ed2:	1f 93       	push	r17
volatile double ADCRef = 0;

inline void ADCSetChannel(unsigned char channel)
{
    channel &= 0x0F;
    channel |= (ADMUX & 0xF0);
    2ed4:	90 91 7c 00 	lds	r25, 0x007C
    2ed8:	8f 70       	andi	r24, 0x0F	; 15
    2eda:	90 7f       	andi	r25, 0xF0	; 240
    2edc:	89 2b       	or	r24, r25
    ADMUX = channel;
    2ede:	80 93 7c 00 	sts	0x007C, r24

double refValue = 0;
inline double ADCGetRoundedValue(unsigned char channel)
{
    ADCSetChannel(channel);
	ADC_SET_REF_1_1;
    2ee2:	80 91 7c 00 	lds	r24, 0x007C
    2ee6:	80 68       	ori	r24, 0x80	; 128
    2ee8:	80 93 7c 00 	sts	0x007C, r24
    2eec:	80 91 7c 00 	lds	r24, 0x007C
    2ef0:	80 64       	ori	r24, 0x40	; 64
    2ef2:	80 93 7c 00 	sts	0x007C, r24
    2ef6:	8d ec       	ldi	r24, 0xCD	; 205
    2ef8:	9c ec       	ldi	r25, 0xCC	; 204
    2efa:	ac e8       	ldi	r26, 0x8C	; 140
    2efc:	bf e3       	ldi	r27, 0x3F	; 63
    2efe:	80 93 43 01 	sts	0x0143, r24
    2f02:	90 93 44 01 	sts	0x0144, r25
    2f06:	a0 93 45 01 	sts	0x0145, r26
    2f0a:	b0 93 46 01 	sts	0x0146, r27

}

inline unsigned short ADCRead()
{
    sbi(ADCSRA, ADSC);           //Start conversion
    2f0e:	80 91 7a 00 	lds	r24, 0x007A
    2f12:	80 64       	ori	r24, 0x40	; 64
    2f14:	80 93 7a 00 	sts	0x007A, r24
     
    while (!(ADCSRA & (1<<ADIF)));    //wait for conversion complete
    2f18:	80 91 7a 00 	lds	r24, 0x007A
    2f1c:	84 ff       	sbrs	r24, 4
    2f1e:	fc cf       	rjmp	.-8      	; 0x2f18 <ADCGetRoundedValue+0x5c>
    
    ADCSRA |= (1<<ADIF);        //Clear flag;
    2f20:	80 91 7a 00 	lds	r24, 0x007A
    2f24:	80 61       	ori	r24, 0x10	; 16
    2f26:	80 93 7a 00 	sts	0x007A, r24

    return ADC;
    2f2a:	80 91 78 00 	lds	r24, 0x0078
    2f2e:	90 91 79 00 	lds	r25, 0x0079
    2f32:	0f 2e       	mov	r0, r31
    2f34:	f0 e0       	ldi	r31, 0x00	; 0
    2f36:	6f 2e       	mov	r6, r31
    2f38:	f0 e0       	ldi	r31, 0x00	; 0
    2f3a:	7f 2e       	mov	r7, r31
    2f3c:	f0 e0       	ldi	r31, 0x00	; 0
    2f3e:	8f 2e       	mov	r8, r31
    2f40:	f0 e0       	ldi	r31, 0x00	; 0
    2f42:	9f 2e       	mov	r9, r31
    2f44:	f0 2d       	mov	r31, r0
    2f46:	dd 24       	eor	r13, r13

}

inline unsigned short ADCRead()
{
    sbi(ADCSRA, ADSC);           //Start conversion
    2f48:	80 91 7a 00 	lds	r24, 0x007A
    2f4c:	80 64       	ori	r24, 0x40	; 64
    2f4e:	80 93 7a 00 	sts	0x007A, r24
     
    while (!(ADCSRA & (1<<ADIF)));    //wait for conversion complete
    2f52:	80 91 7a 00 	lds	r24, 0x007A
    2f56:	84 ff       	sbrs	r24, 4
    2f58:	fc cf       	rjmp	.-8      	; 0x2f52 <ADCGetRoundedValue+0x96>
    
    ADCSRA |= (1<<ADIF);        //Clear flag;
    2f5a:	80 91 7a 00 	lds	r24, 0x007A
    2f5e:	80 61       	ori	r24, 0x10	; 16
    2f60:	80 93 7a 00 	sts	0x007A, r24

    return ADC;
    2f64:	60 91 78 00 	lds	r22, 0x0078
    2f68:	70 91 79 00 	lds	r23, 0x0079
	unsigned char below1_1 = 1;
	unsigned char i;
	
	for (i = 0; i < ADC_ROUND_COUNT; i++)
	{
		nextValue = ADCRead();
    2f6c:	80 e0       	ldi	r24, 0x00	; 0
    2f6e:	90 e0       	ldi	r25, 0x00	; 0
    2f70:	0e 94 0d 1b 	call	0x361a	; 0x361a <__floatunsisf>
    2f74:	7b 01       	movw	r14, r22
    2f76:	8c 01       	movw	r16, r24
		if (nextValue > 1000)
    2f78:	20 e0       	ldi	r18, 0x00	; 0
    2f7a:	30 e0       	ldi	r19, 0x00	; 0
    2f7c:	4a e7       	ldi	r20, 0x7A	; 122
    2f7e:	54 e4       	ldi	r21, 0x44	; 68
    2f80:	0e 94 bf 1b 	call	0x377e	; 0x377e <__gesf2>
    2f84:	18 16       	cp	r1, r24
    2f86:	14 f4       	brge	.+4      	; 0x2f8c <ADCGetRoundedValue+0xd0>
    2f88:	20 e0       	ldi	r18, 0x00	; 0
    2f8a:	0d c0       	rjmp	.+26     	; 0x2fa6 <ADCGetRoundedValue+0xea>
		{
			 below1_1 = 0;
			 break;
		}
		value += nextValue;
    2f8c:	c4 01       	movw	r24, r8
    2f8e:	b3 01       	movw	r22, r6
    2f90:	a8 01       	movw	r20, r16
    2f92:	97 01       	movw	r18, r14
    2f94:	0e 94 11 1a 	call	0x3422	; 0x3422 <__addsf3>
    2f98:	3b 01       	movw	r6, r22
    2f9a:	4c 01       	movw	r8, r24
	

	unsigned char below1_1 = 1;
	unsigned char i;
	
	for (i = 0; i < ADC_ROUND_COUNT; i++)
    2f9c:	d3 94       	inc	r13
    2f9e:	80 e1       	ldi	r24, 0x10	; 16
    2fa0:	d8 16       	cp	r13, r24
    2fa2:	91 f6       	brne	.-92     	; 0x2f48 <ADCGetRoundedValue+0x8c>
    2fa4:	21 e0       	ldi	r18, 0x01	; 1
		}
		value += nextValue;
	}
	

	ADC_SET_REF_VCC;
    2fa6:	80 91 7c 00 	lds	r24, 0x007C
    2faa:	8f 77       	andi	r24, 0x7F	; 127
    2fac:	80 93 7c 00 	sts	0x007C, r24
    2fb0:	80 91 7c 00 	lds	r24, 0x007C
    2fb4:	80 64       	ori	r24, 0x40	; 64
    2fb6:	80 93 7c 00 	sts	0x007C, r24
    2fba:	80 e0       	ldi	r24, 0x00	; 0
    2fbc:	90 e0       	ldi	r25, 0x00	; 0
    2fbe:	a0 ea       	ldi	r26, 0xA0	; 160
    2fc0:	b0 e4       	ldi	r27, 0x40	; 64
    2fc2:	80 93 43 01 	sts	0x0143, r24
    2fc6:	90 93 44 01 	sts	0x0144, r25
    2fca:	a0 93 45 01 	sts	0x0145, r26
    2fce:	b0 93 46 01 	sts	0x0146, r27

}

inline unsigned short ADCRead()
{
    sbi(ADCSRA, ADSC);           //Start conversion
    2fd2:	80 91 7a 00 	lds	r24, 0x007A
    2fd6:	80 64       	ori	r24, 0x40	; 64
    2fd8:	80 93 7a 00 	sts	0x007A, r24
     
    while (!(ADCSRA & (1<<ADIF)));    //wait for conversion complete
    2fdc:	80 91 7a 00 	lds	r24, 0x007A
    2fe0:	84 ff       	sbrs	r24, 4
    2fe2:	fc cf       	rjmp	.-8      	; 0x2fdc <ADCGetRoundedValue+0x120>
    
    ADCSRA |= (1<<ADIF);        //Clear flag;
    2fe4:	80 91 7a 00 	lds	r24, 0x007A
    2fe8:	80 61       	ori	r24, 0x10	; 16
    2fea:	80 93 7a 00 	sts	0x007A, r24

    return ADC;
    2fee:	80 91 78 00 	lds	r24, 0x0078
    2ff2:	90 91 79 00 	lds	r25, 0x0079
	

	ADC_SET_REF_VCC;
	ADCRead();  // dummy

	if (! below1_1)
    2ff6:	22 23       	and	r18, r18
    2ff8:	69 f5       	brne	.+90     	; 0x3054 <ADCGetRoundedValue+0x198>
    2ffa:	0f 2e       	mov	r0, r31
    2ffc:	f0 e0       	ldi	r31, 0x00	; 0
    2ffe:	6f 2e       	mov	r6, r31
    3000:	f0 e0       	ldi	r31, 0x00	; 0
    3002:	7f 2e       	mov	r7, r31
    3004:	f0 e0       	ldi	r31, 0x00	; 0
    3006:	8f 2e       	mov	r8, r31
    3008:	f0 e0       	ldi	r31, 0x00	; 0
    300a:	9f 2e       	mov	r9, r31
    300c:	f0 2d       	mov	r31, r0
    300e:	10 e0       	ldi	r17, 0x00	; 0

}

inline unsigned short ADCRead()
{
    sbi(ADCSRA, ADSC);           //Start conversion
    3010:	80 91 7a 00 	lds	r24, 0x007A
    3014:	80 64       	ori	r24, 0x40	; 64
    3016:	80 93 7a 00 	sts	0x007A, r24
     
    while (!(ADCSRA & (1<<ADIF)));    //wait for conversion complete
    301a:	80 91 7a 00 	lds	r24, 0x007A
    301e:	84 ff       	sbrs	r24, 4
    3020:	fc cf       	rjmp	.-8      	; 0x301a <ADCGetRoundedValue+0x15e>
    
    ADCSRA |= (1<<ADIF);        //Clear flag;
    3022:	80 91 7a 00 	lds	r24, 0x007A
    3026:	80 61       	ori	r24, 0x10	; 16
    3028:	80 93 7a 00 	sts	0x007A, r24

    return ADC;
    302c:	60 91 78 00 	lds	r22, 0x0078
    3030:	70 91 79 00 	lds	r23, 0x0079
	if (! below1_1)
	{
		value = 0;

		for (i = 0; i < ADC_ROUND_COUNT; i++)
			value += ADCRead();
    3034:	80 e0       	ldi	r24, 0x00	; 0
    3036:	90 e0       	ldi	r25, 0x00	; 0
    3038:	0e 94 0d 1b 	call	0x361a	; 0x361a <__floatunsisf>
    303c:	9b 01       	movw	r18, r22
    303e:	ac 01       	movw	r20, r24
    3040:	c4 01       	movw	r24, r8
    3042:	b3 01       	movw	r22, r6
    3044:	0e 94 11 1a 	call	0x3422	; 0x3422 <__addsf3>
    3048:	3b 01       	movw	r6, r22
    304a:	4c 01       	movw	r8, r24

	if (! below1_1)
	{
		value = 0;

		for (i = 0; i < ADC_ROUND_COUNT; i++)
    304c:	1f 5f       	subi	r17, 0xFF	; 255
    304e:	10 31       	cpi	r17, 0x10	; 16
    3050:	f9 f6       	brne	.-66     	; 0x3010 <ADCGetRoundedValue+0x154>
    3052:	84 c0       	rjmp	.+264    	; 0x315c <ADCGetRoundedValue+0x2a0>
volatile double ADCRef = 0;

inline void ADCSetChannel(unsigned char channel)
{
    channel &= 0x0F;
    channel |= (ADMUX & 0xF0);
    3054:	80 91 7c 00 	lds	r24, 0x007C
    3058:	80 7f       	andi	r24, 0xF0	; 240
    305a:	8e 60       	ori	r24, 0x0E	; 14
    ADMUX = channel;
    305c:	80 93 7c 00 	sts	0x007C, r24

}

inline unsigned short ADCRead()
{
    sbi(ADCSRA, ADSC);           //Start conversion
    3060:	80 91 7a 00 	lds	r24, 0x007A
    3064:	80 64       	ori	r24, 0x40	; 64
    3066:	80 93 7a 00 	sts	0x007A, r24
     
    while (!(ADCSRA & (1<<ADIF)));    //wait for conversion complete
    306a:	80 91 7a 00 	lds	r24, 0x007A
    306e:	84 ff       	sbrs	r24, 4
    3070:	fc cf       	rjmp	.-8      	; 0x306a <ADCGetRoundedValue+0x1ae>
    
    ADCSRA |= (1<<ADIF);        //Clear flag;
    3072:	80 91 7a 00 	lds	r24, 0x007A
    3076:	80 61       	ori	r24, 0x10	; 16
    3078:	80 93 7a 00 	sts	0x007A, r24

    return ADC;
    307c:	80 91 78 00 	lds	r24, 0x0078
    3080:	90 91 79 00 	lds	r25, 0x0079
    3084:	0f 2e       	mov	r0, r31
    3086:	f0 e0       	ldi	r31, 0x00	; 0
    3088:	af 2e       	mov	r10, r31
    308a:	f0 e0       	ldi	r31, 0x00	; 0
    308c:	bf 2e       	mov	r11, r31
    308e:	f0 e0       	ldi	r31, 0x00	; 0
    3090:	cf 2e       	mov	r12, r31
    3092:	f0 e0       	ldi	r31, 0x00	; 0
    3094:	df 2e       	mov	r13, r31
    3096:	f0 2d       	mov	r31, r0
    3098:	10 e0       	ldi	r17, 0x00	; 0

}

inline unsigned short ADCRead()
{
    sbi(ADCSRA, ADSC);           //Start conversion
    309a:	80 91 7a 00 	lds	r24, 0x007A
    309e:	80 64       	ori	r24, 0x40	; 64
    30a0:	80 93 7a 00 	sts	0x007A, r24
     
    while (!(ADCSRA & (1<<ADIF)));    //wait for conversion complete
    30a4:	80 91 7a 00 	lds	r24, 0x007A
    30a8:	84 ff       	sbrs	r24, 4
    30aa:	fc cf       	rjmp	.-8      	; 0x30a4 <ADCGetRoundedValue+0x1e8>
    
    ADCSRA |= (1<<ADIF);        //Clear flag;
    30ac:	80 91 7a 00 	lds	r24, 0x007A
    30b0:	80 61       	ori	r24, 0x10	; 16
    30b2:	80 93 7a 00 	sts	0x007A, r24

    return ADC;
    30b6:	60 91 78 00 	lds	r22, 0x0078
    30ba:	70 91 79 00 	lds	r23, 0x0079
		
		ADCRead();  // dummy
		
		nextValue = 0;
		for (i = 0; i < ADC_ROUND_COUNT; i++)
			nextValue += ADCRead();
    30be:	80 e0       	ldi	r24, 0x00	; 0
    30c0:	90 e0       	ldi	r25, 0x00	; 0
    30c2:	0e 94 0d 1b 	call	0x361a	; 0x361a <__floatunsisf>
    30c6:	9b 01       	movw	r18, r22
    30c8:	ac 01       	movw	r20, r24
    30ca:	c6 01       	movw	r24, r12
    30cc:	b5 01       	movw	r22, r10
    30ce:	0e 94 11 1a 	call	0x3422	; 0x3422 <__addsf3>
    30d2:	5b 01       	movw	r10, r22
    30d4:	6c 01       	movw	r12, r24
		ADCSetChannel(REF_1_1_CHANNEL);
		
		ADCRead();  // dummy
		
		nextValue = 0;
		for (i = 0; i < ADC_ROUND_COUNT; i++)
    30d6:	1f 5f       	subi	r17, 0xFF	; 255
    30d8:	10 31       	cpi	r17, 0x10	; 16
    30da:	f9 f6       	brne	.-66     	; 0x309a <ADCGetRoundedValue+0x1de>
			nextValue += ADCRead();
		
		nextValue /= ADC_ROUND_COUNT;
		nextValue = nextValue * ADCRef / 1024;
    30dc:	e0 90 43 01 	lds	r14, 0x0143
    30e0:	f0 90 44 01 	lds	r15, 0x0144
    30e4:	00 91 45 01 	lds	r16, 0x0145
    30e8:	10 91 46 01 	lds	r17, 0x0146
    30ec:	20 e0       	ldi	r18, 0x00	; 0
    30ee:	30 e0       	ldi	r19, 0x00	; 0
    30f0:	40 e8       	ldi	r20, 0x80	; 128
    30f2:	5d e3       	ldi	r21, 0x3D	; 61
    30f4:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__mulsf3>
    30f8:	a8 01       	movw	r20, r16
    30fa:	97 01       	movw	r18, r14
    30fc:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__mulsf3>
		
		refValue = refValue + 0.1 * (nextValue - refValue);
    3100:	e0 90 47 01 	lds	r14, 0x0147
    3104:	f0 90 48 01 	lds	r15, 0x0148
    3108:	00 91 49 01 	lds	r16, 0x0149
    310c:	10 91 4a 01 	lds	r17, 0x014A
    3110:	20 e0       	ldi	r18, 0x00	; 0
    3112:	30 e0       	ldi	r19, 0x00	; 0
    3114:	40 e8       	ldi	r20, 0x80	; 128
    3116:	5a e3       	ldi	r21, 0x3A	; 58
    3118:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__mulsf3>
    311c:	a8 01       	movw	r20, r16
    311e:	97 01       	movw	r18, r14
    3120:	0e 94 10 1a 	call	0x3420	; 0x3420 <__subsf3>
    3124:	2d ec       	ldi	r18, 0xCD	; 205
    3126:	3c ec       	ldi	r19, 0xCC	; 204
    3128:	4c ec       	ldi	r20, 0xCC	; 204
    312a:	5d e3       	ldi	r21, 0x3D	; 61
    312c:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__mulsf3>
    3130:	9b 01       	movw	r18, r22
    3132:	ac 01       	movw	r20, r24
    3134:	c8 01       	movw	r24, r16
    3136:	b7 01       	movw	r22, r14
    3138:	0e 94 11 1a 	call	0x3422	; 0x3422 <__addsf3>
    313c:	60 93 47 01 	sts	0x0147, r22
    3140:	70 93 48 01 	sts	0x0148, r23
    3144:	80 93 49 01 	sts	0x0149, r24
    3148:	90 93 4a 01 	sts	0x014A, r25
		ADCRef = refValue;
    314c:	60 93 43 01 	sts	0x0143, r22
    3150:	70 93 44 01 	sts	0x0144, r23
    3154:	80 93 45 01 	sts	0x0145, r24
    3158:	90 93 46 01 	sts	0x0146, r25
	}

	value /= ADC_ROUND_COUNT;
   
	value = value * ADCRef / 1024;
    315c:	e0 90 43 01 	lds	r14, 0x0143
    3160:	f0 90 44 01 	lds	r15, 0x0144
    3164:	00 91 45 01 	lds	r16, 0x0145
    3168:	10 91 46 01 	lds	r17, 0x0146
    316c:	c4 01       	movw	r24, r8
    316e:	b3 01       	movw	r22, r6
    3170:	20 e0       	ldi	r18, 0x00	; 0
    3172:	30 e0       	ldi	r19, 0x00	; 0
    3174:	40 e8       	ldi	r20, 0x80	; 128
    3176:	5d e3       	ldi	r21, 0x3D	; 61
    3178:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__mulsf3>
    317c:	a8 01       	movw	r20, r16
    317e:	97 01       	movw	r18, r14
    3180:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__mulsf3>
    3184:	20 e0       	ldi	r18, 0x00	; 0
    3186:	30 e0       	ldi	r19, 0x00	; 0
    3188:	40 e8       	ldi	r20, 0x80	; 128
    318a:	5a e3       	ldi	r21, 0x3A	; 58
    318c:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__mulsf3>

	return value;
}
    3190:	1f 91       	pop	r17
    3192:	0f 91       	pop	r16
    3194:	ff 90       	pop	r15
    3196:	ef 90       	pop	r14
    3198:	df 90       	pop	r13
    319a:	cf 90       	pop	r12
    319c:	bf 90       	pop	r11
    319e:	af 90       	pop	r10
    31a0:	9f 90       	pop	r9
    31a2:	8f 90       	pop	r8
    31a4:	7f 90       	pop	r7
    31a6:	6f 90       	pop	r6
    31a8:	08 95       	ret

000031aa <FOutInit>:
volatile	unsigned char hvost;				// последн€€ задержка
volatile	unsigned char hvost_tmp;			// последн€€ задержка

void FOutInit(void)
{
	cbi(PRR,  PRTIM2);      //On TIMER0
    31aa:	e4 e6       	ldi	r30, 0x64	; 100
    31ac:	f0 e0       	ldi	r31, 0x00	; 0
    31ae:	80 81       	ld	r24, Z
    31b0:	8f 7b       	andi	r24, 0xBF	; 191
    31b2:	80 83       	st	Z, r24
	sbi(TCCR2A, WGM21);
    31b4:	e0 eb       	ldi	r30, 0xB0	; 176
    31b6:	f0 e0       	ldi	r31, 0x00	; 0
    31b8:	80 81       	ld	r24, Z
    31ba:	82 60       	ori	r24, 0x02	; 2
    31bc:	80 83       	st	Z, r24
	OCR2A=00;
    31be:	10 92 b3 00 	sts	0x00B3, r1
	TCCR2B = FOUT_TIMER_CLOCK_DIVIRDER;
    31c2:	82 e0       	ldi	r24, 0x02	; 2
    31c4:	80 93 b1 00 	sts	0x00B1, r24
	TIMSK2|=(1<<OCIE2A); // дл€ частотного выхода
    31c8:	e0 e7       	ldi	r30, 0x70	; 112
    31ca:	f0 e0       	ldi	r31, 0x00	; 0
    31cc:	80 81       	ld	r24, Z
    31ce:	82 60       	ori	r24, 0x02	; 2
    31d0:	80 83       	st	Z, r24
}
    31d2:	08 95       	ret

000031d4 <set_Freq>:

// расчЄт задержек
void set_Freq(double freq){
    31d4:	0f 93       	push	r16
    31d6:	1f 93       	push	r17
    31d8:	9b 01       	movw	r18, r22
    31da:	ac 01       	movw	r20, r24
	unsigned short tmp_hvost;
	unsigned short counts;
	unsigned char tmp_count_big;
	unsigned char tmp_big;

	counts = ((OUT_FRTBL_TO_FR/freq) - 1.0);
    31dc:	60 e0       	ldi	r22, 0x00	; 0
    31de:	70 e0       	ldi	r23, 0x00	; 0
    31e0:	81 e6       	ldi	r24, 0x61	; 97
    31e2:	99 e4       	ldi	r25, 0x49	; 73
    31e4:	0e 94 79 1a 	call	0x34f2	; 0x34f2 <__divsf3>
    31e8:	20 e0       	ldi	r18, 0x00	; 0
    31ea:	30 e0       	ldi	r19, 0x00	; 0
    31ec:	40 e8       	ldi	r20, 0x80	; 128
    31ee:	5f e3       	ldi	r21, 0x3F	; 63
    31f0:	0e 94 10 1a 	call	0x3420	; 0x3420 <__subsf3>
    31f4:	0e 94 e1 1a 	call	0x35c2	; 0x35c2 <__fixunssfsi>
    31f8:	8b 01       	movw	r16, r22
    31fa:	9c 01       	movw	r18, r24
    31fc:	fb 01       	movw	r30, r22

	tmp_count_big = (counts/255)+1;	
    31fe:	cb 01       	movw	r24, r22
    3200:	6f ef       	ldi	r22, 0xFF	; 255
    3202:	70 e0       	ldi	r23, 0x00	; 0
    3204:	0e 94 45 1c 	call	0x388a	; 0x388a <__udivmodhi4>
    3208:	46 2f       	mov	r20, r22
	
	tmp_big=counts/tmp_count_big;
    320a:	6f 5f       	subi	r22, 0xFF	; 255
    320c:	c8 01       	movw	r24, r16
    320e:	70 e0       	ldi	r23, 0x00	; 0
    3210:	0e 94 45 1c 	call	0x388a	; 0x388a <__udivmodhi4>

	tmp_count_big--;

	tmp_hvost=counts-(unsigned short)(tmp_big*(unsigned short)tmp_count_big);
    3214:	24 2f       	mov	r18, r20
    3216:	30 e0       	ldi	r19, 0x00	; 0
    3218:	86 2f       	mov	r24, r22
    321a:	90 e0       	ldi	r25, 0x00	; 0
    321c:	dc 01       	movw	r26, r24
    321e:	a2 9f       	mul	r26, r18
    3220:	c0 01       	movw	r24, r0
    3222:	a3 9f       	mul	r26, r19
    3224:	90 0d       	add	r25, r0
    3226:	b2 9f       	mul	r27, r18
    3228:	90 0d       	add	r25, r0
    322a:	11 24       	eor	r1, r1
    322c:	e8 1b       	sub	r30, r24
    322e:	f9 0b       	sbc	r31, r25

	while (tmp_hvost > 0xFF){
    3230:	88 27       	eor	r24, r24
    3232:	99 27       	eor	r25, r25
    3234:	82 1b       	sub	r24, r18
    3236:	93 0b       	sbc	r25, r19
    3238:	03 c0       	rjmp	.+6      	; 0x3240 <set_Freq+0x6c>
    323a:	e8 0f       	add	r30, r24
    323c:	f9 1f       	adc	r31, r25
		tmp_hvost-=tmp_count_big;
		tmp_big++;
    323e:	6f 5f       	subi	r22, 0xFF	; 255

	tmp_count_big--;

	tmp_hvost=counts-(unsigned short)(tmp_big*(unsigned short)tmp_count_big);

	while (tmp_hvost > 0xFF){
    3240:	ef 3f       	cpi	r30, 0xFF	; 255
    3242:	f1 05       	cpc	r31, r1
    3244:	09 f0       	breq	.+2      	; 0x3248 <set_Freq+0x74>
    3246:	c8 f7       	brcc	.-14     	; 0x323a <set_Freq+0x66>
		tmp_hvost-=tmp_count_big;
		tmp_big++;
	}

	tmp_big--;
    3248:	61 50       	subi	r22, 0x01	; 1

	cli();
    324a:	f8 94       	cli
	big = tmp_big;
    324c:	60 93 4b 01 	sts	0x014B, r22
	count_big = tmp_count_big;	
    3250:	40 93 4d 01 	sts	0x014D, r20
	hvost=tmp_hvost;
    3254:	e0 93 56 04 	sts	0x0456, r30
	sei();
    3258:	78 94       	sei
}
    325a:	1f 91       	pop	r17
    325c:	0f 91       	pop	r16
    325e:	08 95       	ret

00003260 <__vector_7>:


ISR(TIMER2_COMPA_vect){
    3260:	1f 92       	push	r1
    3262:	0f 92       	push	r0
    3264:	0f b6       	in	r0, 0x3f	; 63
    3266:	0f 92       	push	r0
    3268:	11 24       	eor	r1, r1
    326a:	8f 93       	push	r24
    326c:	9f 93       	push	r25

	if 	(count_big_tmp){
    326e:	80 91 4e 01 	lds	r24, 0x014E
    3272:	88 23       	and	r24, r24
    3274:	51 f0       	breq	.+20     	; 0x328a <__vector_7+0x2a>
		OCR2A=big_tmp;
    3276:	80 91 4c 01 	lds	r24, 0x014C
    327a:	80 93 b3 00 	sts	0x00B3, r24
		count_big_tmp--;
    327e:	80 91 4e 01 	lds	r24, 0x014E
    3282:	81 50       	subi	r24, 0x01	; 1
    3284:	80 93 4e 01 	sts	0x014E, r24
    3288:	14 c0       	rjmp	.+40     	; 0x32b2 <__vector_7+0x52>
	}
	else 
	{
		FREQ_OUT_PORT^=(1<<FREQ_OUT_PIN);	// инверси€ ноги
    328a:	8b b1       	in	r24, 0x0b	; 11
    328c:	98 e0       	ldi	r25, 0x08	; 8
    328e:	89 27       	eor	r24, r25
    3290:	8b b9       	out	0x0b, r24	; 11
		OCR2A=hvost_tmp;
    3292:	80 91 57 04 	lds	r24, 0x0457
    3296:	80 93 b3 00 	sts	0x00B3, r24

		count_big_tmp=count_big;
    329a:	80 91 4d 01 	lds	r24, 0x014D
    329e:	80 93 4e 01 	sts	0x014E, r24
		big_tmp=big;
    32a2:	80 91 4b 01 	lds	r24, 0x014B
    32a6:	80 93 4c 01 	sts	0x014C, r24
		hvost_tmp=hvost;
    32aa:	80 91 56 04 	lds	r24, 0x0456
    32ae:	80 93 57 04 	sts	0x0457, r24
	}
}
    32b2:	9f 91       	pop	r25
    32b4:	8f 91       	pop	r24
    32b6:	0f 90       	pop	r0
    32b8:	0f be       	out	0x3f, r0	; 63
    32ba:	0f 90       	pop	r0
    32bc:	1f 90       	pop	r1
    32be:	18 95       	reti

000032c0 <exit>:
    32c0:	f8 94       	cli
    32c2:	0c 94 90 1c 	jmp	0x3920	; 0x3920 <_exit>

000032c6 <memcpy_P>:
    32c6:	fb 01       	movw	r30, r22
    32c8:	dc 01       	movw	r26, r24
    32ca:	02 c0       	rjmp	.+4      	; 0x32d0 <memcpy_P+0xa>
    32cc:	05 90       	lpm	r0, Z+
    32ce:	0d 92       	st	X+, r0
    32d0:	41 50       	subi	r20, 0x01	; 1
    32d2:	50 40       	sbci	r21, 0x00	; 0
    32d4:	d8 f7       	brcc	.-10     	; 0x32cc <memcpy_P+0x6>
    32d6:	08 95       	ret

000032d8 <memcpy>:
    32d8:	fb 01       	movw	r30, r22
    32da:	dc 01       	movw	r26, r24
    32dc:	02 c0       	rjmp	.+4      	; 0x32e2 <memcpy+0xa>
    32de:	01 90       	ld	r0, Z+
    32e0:	0d 92       	st	X+, r0
    32e2:	41 50       	subi	r20, 0x01	; 1
    32e4:	50 40       	sbci	r21, 0x00	; 0
    32e6:	d8 f7       	brcc	.-10     	; 0x32de <memcpy+0x6>
    32e8:	08 95       	ret

000032ea <strcat>:
    32ea:	fb 01       	movw	r30, r22
    32ec:	dc 01       	movw	r26, r24
    32ee:	0d 90       	ld	r0, X+
    32f0:	00 20       	and	r0, r0
    32f2:	e9 f7       	brne	.-6      	; 0x32ee <strcat+0x4>
    32f4:	11 97       	sbiw	r26, 0x01	; 1
    32f6:	01 90       	ld	r0, Z+
    32f8:	0d 92       	st	X+, r0
    32fa:	00 20       	and	r0, r0
    32fc:	e1 f7       	brne	.-8      	; 0x32f6 <strcat+0xc>
    32fe:	08 95       	ret

00003300 <strcpy>:
    3300:	fb 01       	movw	r30, r22
    3302:	dc 01       	movw	r26, r24
    3304:	01 90       	ld	r0, Z+
    3306:	0d 92       	st	X+, r0
    3308:	00 20       	and	r0, r0
    330a:	e1 f7       	brne	.-8      	; 0x3304 <strcpy+0x4>
    330c:	08 95       	ret

0000330e <__eerd_block>:
    330e:	a0 e0       	ldi	r26, 0x00	; 0
    3310:	b0 e0       	ldi	r27, 0x00	; 0
    3312:	ed e8       	ldi	r30, 0x8D	; 141
    3314:	f9 e1       	ldi	r31, 0x19	; 25
    3316:	0c 94 63 1c 	jmp	0x38c6	; 0x38c6 <__prologue_saves__+0x14>
    331a:	7c 01       	movw	r14, r24
    331c:	eb 01       	movw	r28, r22
    331e:	8a 01       	movw	r16, r20
    3320:	69 01       	movw	r12, r18
    3322:	09 c0       	rjmp	.+18     	; 0x3336 <__eerd_block+0x28>
    3324:	ce 01       	movw	r24, r28
    3326:	21 96       	adiw	r28, 0x01	; 1
    3328:	f6 01       	movw	r30, r12
    332a:	09 95       	icall
    332c:	f7 01       	movw	r30, r14
    332e:	81 93       	st	Z+, r24
    3330:	7f 01       	movw	r14, r30
    3332:	01 50       	subi	r16, 0x01	; 1
    3334:	10 40       	sbci	r17, 0x00	; 0
    3336:	01 15       	cp	r16, r1
    3338:	11 05       	cpc	r17, r1
    333a:	a1 f7       	brne	.-24     	; 0x3324 <__eerd_block+0x16>
    333c:	cd b7       	in	r28, 0x3d	; 61
    333e:	de b7       	in	r29, 0x3e	; 62
    3340:	e8 e0       	ldi	r30, 0x08	; 8
    3342:	0c 94 7f 1c 	jmp	0x38fe	; 0x38fe <__epilogue_restores__+0x14>

00003346 <__eerd_word>:
    3346:	df 92       	push	r13
    3348:	ef 92       	push	r14
    334a:	ff 92       	push	r15
    334c:	0f 93       	push	r16
    334e:	1f 93       	push	r17
    3350:	7b 01       	movw	r14, r22
    3352:	8c 01       	movw	r16, r24
    3354:	fb 01       	movw	r30, r22
    3356:	09 95       	icall
    3358:	d8 2e       	mov	r13, r24
    335a:	c8 01       	movw	r24, r16
    335c:	01 96       	adiw	r24, 0x01	; 1
    335e:	f7 01       	movw	r30, r14
    3360:	09 95       	icall
    3362:	98 2f       	mov	r25, r24
    3364:	8d 2d       	mov	r24, r13
    3366:	1f 91       	pop	r17
    3368:	0f 91       	pop	r16
    336a:	ff 90       	pop	r15
    336c:	ef 90       	pop	r14
    336e:	df 90       	pop	r13
    3370:	08 95       	ret

00003372 <__eewr_block>:
    3372:	a0 e0       	ldi	r26, 0x00	; 0
    3374:	b0 e0       	ldi	r27, 0x00	; 0
    3376:	ef eb       	ldi	r30, 0xBF	; 191
    3378:	f9 e1       	ldi	r31, 0x19	; 25
    337a:	0c 94 63 1c 	jmp	0x38c6	; 0x38c6 <__prologue_saves__+0x14>
    337e:	ec 01       	movw	r28, r24
    3380:	7b 01       	movw	r14, r22
    3382:	8a 01       	movw	r16, r20
    3384:	69 01       	movw	r12, r18
    3386:	09 c0       	rjmp	.+18     	; 0x339a <__eewr_block+0x28>
    3388:	ce 01       	movw	r24, r28
    338a:	21 96       	adiw	r28, 0x01	; 1
    338c:	f7 01       	movw	r30, r14
    338e:	61 91       	ld	r22, Z+
    3390:	7f 01       	movw	r14, r30
    3392:	f6 01       	movw	r30, r12
    3394:	09 95       	icall
    3396:	01 50       	subi	r16, 0x01	; 1
    3398:	10 40       	sbci	r17, 0x00	; 0
    339a:	01 15       	cp	r16, r1
    339c:	11 05       	cpc	r17, r1
    339e:	a1 f7       	brne	.-24     	; 0x3388 <__eewr_block+0x16>
    33a0:	cd b7       	in	r28, 0x3d	; 61
    33a2:	de b7       	in	r29, 0x3e	; 62
    33a4:	e8 e0       	ldi	r30, 0x08	; 8
    33a6:	0c 94 7f 1c 	jmp	0x38fe	; 0x38fe <__epilogue_restores__+0x14>

000033aa <__eewr_word>:
    33aa:	df 92       	push	r13
    33ac:	ef 92       	push	r14
    33ae:	ff 92       	push	r15
    33b0:	0f 93       	push	r16
    33b2:	1f 93       	push	r17
    33b4:	d7 2e       	mov	r13, r23
    33b6:	7a 01       	movw	r14, r20
    33b8:	8c 01       	movw	r16, r24
    33ba:	fa 01       	movw	r30, r20
    33bc:	09 95       	icall
    33be:	c8 01       	movw	r24, r16
    33c0:	01 96       	adiw	r24, 0x01	; 1
    33c2:	6d 2d       	mov	r22, r13
    33c4:	f7 01       	movw	r30, r14
    33c6:	09 95       	icall
    33c8:	1f 91       	pop	r17
    33ca:	0f 91       	pop	r16
    33cc:	ff 90       	pop	r15
    33ce:	ef 90       	pop	r14
    33d0:	df 90       	pop	r13
    33d2:	08 95       	ret

000033d4 <utoa>:
    33d4:	fb 01       	movw	r30, r22
    33d6:	9f 01       	movw	r18, r30
    33d8:	42 30       	cpi	r20, 0x02	; 2
    33da:	74 f0       	brlt	.+28     	; 0x33f8 <utoa+0x24>
    33dc:	45 32       	cpi	r20, 0x25	; 37
    33de:	64 f4       	brge	.+24     	; 0x33f8 <utoa+0x24>
    33e0:	64 2f       	mov	r22, r20
    33e2:	77 27       	eor	r23, r23
    33e4:	0e 94 45 1c 	call	0x388a	; 0x388a <__udivmodhi4>
    33e8:	80 5d       	subi	r24, 0xD0	; 208
    33ea:	8a 33       	cpi	r24, 0x3A	; 58
    33ec:	0c f0       	brlt	.+2      	; 0x33f0 <utoa+0x1c>
    33ee:	89 5d       	subi	r24, 0xD9	; 217
    33f0:	81 93       	st	Z+, r24
    33f2:	cb 01       	movw	r24, r22
    33f4:	00 97       	sbiw	r24, 0x00	; 0
    33f6:	a1 f7       	brne	.-24     	; 0x33e0 <utoa+0xc>
    33f8:	10 82       	st	Z, r1
    33fa:	c9 01       	movw	r24, r18
    33fc:	0c 94 00 1a 	jmp	0x3400	; 0x3400 <strrev>

00003400 <strrev>:
    3400:	dc 01       	movw	r26, r24
    3402:	fc 01       	movw	r30, r24
    3404:	67 2f       	mov	r22, r23
    3406:	71 91       	ld	r23, Z+
    3408:	77 23       	and	r23, r23
    340a:	e1 f7       	brne	.-8      	; 0x3404 <strrev+0x4>
    340c:	32 97       	sbiw	r30, 0x02	; 2
    340e:	04 c0       	rjmp	.+8      	; 0x3418 <strrev+0x18>
    3410:	7c 91       	ld	r23, X
    3412:	6d 93       	st	X+, r22
    3414:	70 83       	st	Z, r23
    3416:	62 91       	ld	r22, -Z
    3418:	ae 17       	cp	r26, r30
    341a:	bf 07       	cpc	r27, r31
    341c:	c8 f3       	brcs	.-14     	; 0x3410 <strrev+0x10>
    341e:	08 95       	ret

00003420 <__subsf3>:
    3420:	50 58       	subi	r21, 0x80	; 128

00003422 <__addsf3>:
    3422:	bb 27       	eor	r27, r27
    3424:	aa 27       	eor	r26, r26
    3426:	0e d0       	rcall	.+28     	; 0x3444 <__addsf3x>
    3428:	70 c1       	rjmp	.+736    	; 0x370a <__fp_round>
    342a:	61 d1       	rcall	.+706    	; 0x36ee <__fp_pscA>
    342c:	30 f0       	brcs	.+12     	; 0x343a <__addsf3+0x18>
    342e:	66 d1       	rcall	.+716    	; 0x36fc <__fp_pscB>
    3430:	20 f0       	brcs	.+8      	; 0x343a <__addsf3+0x18>
    3432:	31 f4       	brne	.+12     	; 0x3440 <__addsf3+0x1e>
    3434:	9f 3f       	cpi	r25, 0xFF	; 255
    3436:	11 f4       	brne	.+4      	; 0x343c <__addsf3+0x1a>
    3438:	1e f4       	brtc	.+6      	; 0x3440 <__addsf3+0x1e>
    343a:	56 c1       	rjmp	.+684    	; 0x36e8 <__fp_nan>
    343c:	0e f4       	brtc	.+2      	; 0x3440 <__addsf3+0x1e>
    343e:	e0 95       	com	r30
    3440:	e7 fb       	bst	r30, 7
    3442:	4c c1       	rjmp	.+664    	; 0x36dc <__fp_inf>

00003444 <__addsf3x>:
    3444:	e9 2f       	mov	r30, r25
    3446:	72 d1       	rcall	.+740    	; 0x372c <__fp_split3>
    3448:	80 f3       	brcs	.-32     	; 0x342a <__addsf3+0x8>
    344a:	ba 17       	cp	r27, r26
    344c:	62 07       	cpc	r22, r18
    344e:	73 07       	cpc	r23, r19
    3450:	84 07       	cpc	r24, r20
    3452:	95 07       	cpc	r25, r21
    3454:	18 f0       	brcs	.+6      	; 0x345c <__addsf3x+0x18>
    3456:	71 f4       	brne	.+28     	; 0x3474 <__addsf3x+0x30>
    3458:	9e f5       	brtc	.+102    	; 0x34c0 <__addsf3x+0x7c>
    345a:	8a c1       	rjmp	.+788    	; 0x3770 <__fp_zero>
    345c:	0e f4       	brtc	.+2      	; 0x3460 <__addsf3x+0x1c>
    345e:	e0 95       	com	r30
    3460:	0b 2e       	mov	r0, r27
    3462:	ba 2f       	mov	r27, r26
    3464:	a0 2d       	mov	r26, r0
    3466:	0b 01       	movw	r0, r22
    3468:	b9 01       	movw	r22, r18
    346a:	90 01       	movw	r18, r0
    346c:	0c 01       	movw	r0, r24
    346e:	ca 01       	movw	r24, r20
    3470:	a0 01       	movw	r20, r0
    3472:	11 24       	eor	r1, r1
    3474:	ff 27       	eor	r31, r31
    3476:	59 1b       	sub	r21, r25
    3478:	99 f0       	breq	.+38     	; 0x34a0 <__addsf3x+0x5c>
    347a:	59 3f       	cpi	r21, 0xF9	; 249
    347c:	50 f4       	brcc	.+20     	; 0x3492 <__addsf3x+0x4e>
    347e:	50 3e       	cpi	r21, 0xE0	; 224
    3480:	68 f1       	brcs	.+90     	; 0x34dc <__addsf3x+0x98>
    3482:	1a 16       	cp	r1, r26
    3484:	f0 40       	sbci	r31, 0x00	; 0
    3486:	a2 2f       	mov	r26, r18
    3488:	23 2f       	mov	r18, r19
    348a:	34 2f       	mov	r19, r20
    348c:	44 27       	eor	r20, r20
    348e:	58 5f       	subi	r21, 0xF8	; 248
    3490:	f3 cf       	rjmp	.-26     	; 0x3478 <__addsf3x+0x34>
    3492:	46 95       	lsr	r20
    3494:	37 95       	ror	r19
    3496:	27 95       	ror	r18
    3498:	a7 95       	ror	r26
    349a:	f0 40       	sbci	r31, 0x00	; 0
    349c:	53 95       	inc	r21
    349e:	c9 f7       	brne	.-14     	; 0x3492 <__addsf3x+0x4e>
    34a0:	7e f4       	brtc	.+30     	; 0x34c0 <__addsf3x+0x7c>
    34a2:	1f 16       	cp	r1, r31
    34a4:	ba 0b       	sbc	r27, r26
    34a6:	62 0b       	sbc	r22, r18
    34a8:	73 0b       	sbc	r23, r19
    34aa:	84 0b       	sbc	r24, r20
    34ac:	ba f0       	brmi	.+46     	; 0x34dc <__addsf3x+0x98>
    34ae:	91 50       	subi	r25, 0x01	; 1
    34b0:	a1 f0       	breq	.+40     	; 0x34da <__addsf3x+0x96>
    34b2:	ff 0f       	add	r31, r31
    34b4:	bb 1f       	adc	r27, r27
    34b6:	66 1f       	adc	r22, r22
    34b8:	77 1f       	adc	r23, r23
    34ba:	88 1f       	adc	r24, r24
    34bc:	c2 f7       	brpl	.-16     	; 0x34ae <__addsf3x+0x6a>
    34be:	0e c0       	rjmp	.+28     	; 0x34dc <__addsf3x+0x98>
    34c0:	ba 0f       	add	r27, r26
    34c2:	62 1f       	adc	r22, r18
    34c4:	73 1f       	adc	r23, r19
    34c6:	84 1f       	adc	r24, r20
    34c8:	48 f4       	brcc	.+18     	; 0x34dc <__addsf3x+0x98>
    34ca:	87 95       	ror	r24
    34cc:	77 95       	ror	r23
    34ce:	67 95       	ror	r22
    34d0:	b7 95       	ror	r27
    34d2:	f7 95       	ror	r31
    34d4:	9e 3f       	cpi	r25, 0xFE	; 254
    34d6:	08 f0       	brcs	.+2      	; 0x34da <__addsf3x+0x96>
    34d8:	b3 cf       	rjmp	.-154    	; 0x3440 <__addsf3+0x1e>
    34da:	93 95       	inc	r25
    34dc:	88 0f       	add	r24, r24
    34de:	08 f0       	brcs	.+2      	; 0x34e2 <__addsf3x+0x9e>
    34e0:	99 27       	eor	r25, r25
    34e2:	ee 0f       	add	r30, r30
    34e4:	97 95       	ror	r25
    34e6:	87 95       	ror	r24
    34e8:	08 95       	ret

000034ea <__cmpsf2>:
    34ea:	d4 d0       	rcall	.+424    	; 0x3694 <__fp_cmp>
    34ec:	08 f4       	brcc	.+2      	; 0x34f0 <__cmpsf2+0x6>
    34ee:	81 e0       	ldi	r24, 0x01	; 1
    34f0:	08 95       	ret

000034f2 <__divsf3>:
    34f2:	0c d0       	rcall	.+24     	; 0x350c <__divsf3x>
    34f4:	0a c1       	rjmp	.+532    	; 0x370a <__fp_round>
    34f6:	02 d1       	rcall	.+516    	; 0x36fc <__fp_pscB>
    34f8:	40 f0       	brcs	.+16     	; 0x350a <__divsf3+0x18>
    34fa:	f9 d0       	rcall	.+498    	; 0x36ee <__fp_pscA>
    34fc:	30 f0       	brcs	.+12     	; 0x350a <__divsf3+0x18>
    34fe:	21 f4       	brne	.+8      	; 0x3508 <__divsf3+0x16>
    3500:	5f 3f       	cpi	r21, 0xFF	; 255
    3502:	19 f0       	breq	.+6      	; 0x350a <__divsf3+0x18>
    3504:	eb c0       	rjmp	.+470    	; 0x36dc <__fp_inf>
    3506:	51 11       	cpse	r21, r1
    3508:	34 c1       	rjmp	.+616    	; 0x3772 <__fp_szero>
    350a:	ee c0       	rjmp	.+476    	; 0x36e8 <__fp_nan>

0000350c <__divsf3x>:
    350c:	0f d1       	rcall	.+542    	; 0x372c <__fp_split3>
    350e:	98 f3       	brcs	.-26     	; 0x34f6 <__divsf3+0x4>

00003510 <__divsf3_pse>:
    3510:	99 23       	and	r25, r25
    3512:	c9 f3       	breq	.-14     	; 0x3506 <__divsf3+0x14>
    3514:	55 23       	and	r21, r21
    3516:	b1 f3       	breq	.-20     	; 0x3504 <__divsf3+0x12>
    3518:	95 1b       	sub	r25, r21
    351a:	55 0b       	sbc	r21, r21
    351c:	bb 27       	eor	r27, r27
    351e:	aa 27       	eor	r26, r26
    3520:	62 17       	cp	r22, r18
    3522:	73 07       	cpc	r23, r19
    3524:	84 07       	cpc	r24, r20
    3526:	38 f0       	brcs	.+14     	; 0x3536 <__divsf3_pse+0x26>
    3528:	9f 5f       	subi	r25, 0xFF	; 255
    352a:	5f 4f       	sbci	r21, 0xFF	; 255
    352c:	22 0f       	add	r18, r18
    352e:	33 1f       	adc	r19, r19
    3530:	44 1f       	adc	r20, r20
    3532:	aa 1f       	adc	r26, r26
    3534:	a9 f3       	breq	.-22     	; 0x3520 <__divsf3_pse+0x10>
    3536:	33 d0       	rcall	.+102    	; 0x359e <__divsf3_pse+0x8e>
    3538:	0e 2e       	mov	r0, r30
    353a:	3a f0       	brmi	.+14     	; 0x354a <__divsf3_pse+0x3a>
    353c:	e0 e8       	ldi	r30, 0x80	; 128
    353e:	30 d0       	rcall	.+96     	; 0x35a0 <__divsf3_pse+0x90>
    3540:	91 50       	subi	r25, 0x01	; 1
    3542:	50 40       	sbci	r21, 0x00	; 0
    3544:	e6 95       	lsr	r30
    3546:	00 1c       	adc	r0, r0
    3548:	ca f7       	brpl	.-14     	; 0x353c <__divsf3_pse+0x2c>
    354a:	29 d0       	rcall	.+82     	; 0x359e <__divsf3_pse+0x8e>
    354c:	fe 2f       	mov	r31, r30
    354e:	27 d0       	rcall	.+78     	; 0x359e <__divsf3_pse+0x8e>
    3550:	66 0f       	add	r22, r22
    3552:	77 1f       	adc	r23, r23
    3554:	88 1f       	adc	r24, r24
    3556:	bb 1f       	adc	r27, r27
    3558:	26 17       	cp	r18, r22
    355a:	37 07       	cpc	r19, r23
    355c:	48 07       	cpc	r20, r24
    355e:	ab 07       	cpc	r26, r27
    3560:	b0 e8       	ldi	r27, 0x80	; 128
    3562:	09 f0       	breq	.+2      	; 0x3566 <__divsf3_pse+0x56>
    3564:	bb 0b       	sbc	r27, r27
    3566:	80 2d       	mov	r24, r0
    3568:	bf 01       	movw	r22, r30
    356a:	ff 27       	eor	r31, r31
    356c:	93 58       	subi	r25, 0x83	; 131
    356e:	5f 4f       	sbci	r21, 0xFF	; 255
    3570:	2a f0       	brmi	.+10     	; 0x357c <__divsf3_pse+0x6c>
    3572:	9e 3f       	cpi	r25, 0xFE	; 254
    3574:	51 05       	cpc	r21, r1
    3576:	68 f0       	brcs	.+26     	; 0x3592 <__divsf3_pse+0x82>
    3578:	b1 c0       	rjmp	.+354    	; 0x36dc <__fp_inf>
    357a:	fb c0       	rjmp	.+502    	; 0x3772 <__fp_szero>
    357c:	5f 3f       	cpi	r21, 0xFF	; 255
    357e:	ec f3       	brlt	.-6      	; 0x357a <__divsf3_pse+0x6a>
    3580:	98 3e       	cpi	r25, 0xE8	; 232
    3582:	dc f3       	brlt	.-10     	; 0x357a <__divsf3_pse+0x6a>
    3584:	86 95       	lsr	r24
    3586:	77 95       	ror	r23
    3588:	67 95       	ror	r22
    358a:	b7 95       	ror	r27
    358c:	f7 95       	ror	r31
    358e:	9f 5f       	subi	r25, 0xFF	; 255
    3590:	c9 f7       	brne	.-14     	; 0x3584 <__divsf3_pse+0x74>
    3592:	88 0f       	add	r24, r24
    3594:	91 1d       	adc	r25, r1
    3596:	96 95       	lsr	r25
    3598:	87 95       	ror	r24
    359a:	97 f9       	bld	r25, 7
    359c:	08 95       	ret
    359e:	e1 e0       	ldi	r30, 0x01	; 1
    35a0:	66 0f       	add	r22, r22
    35a2:	77 1f       	adc	r23, r23
    35a4:	88 1f       	adc	r24, r24
    35a6:	bb 1f       	adc	r27, r27
    35a8:	62 17       	cp	r22, r18
    35aa:	73 07       	cpc	r23, r19
    35ac:	84 07       	cpc	r24, r20
    35ae:	ba 07       	cpc	r27, r26
    35b0:	20 f0       	brcs	.+8      	; 0x35ba <__divsf3_pse+0xaa>
    35b2:	62 1b       	sub	r22, r18
    35b4:	73 0b       	sbc	r23, r19
    35b6:	84 0b       	sbc	r24, r20
    35b8:	ba 0b       	sbc	r27, r26
    35ba:	ee 1f       	adc	r30, r30
    35bc:	88 f7       	brcc	.-30     	; 0x35a0 <__divsf3_pse+0x90>
    35be:	e0 95       	com	r30
    35c0:	08 95       	ret

000035c2 <__fixunssfsi>:
    35c2:	bc d0       	rcall	.+376    	; 0x373c <__fp_splitA>
    35c4:	88 f0       	brcs	.+34     	; 0x35e8 <__fixunssfsi+0x26>
    35c6:	9f 57       	subi	r25, 0x7F	; 127
    35c8:	90 f0       	brcs	.+36     	; 0x35ee <__fixunssfsi+0x2c>
    35ca:	b9 2f       	mov	r27, r25
    35cc:	99 27       	eor	r25, r25
    35ce:	b7 51       	subi	r27, 0x17	; 23
    35d0:	a0 f0       	brcs	.+40     	; 0x35fa <__fixunssfsi+0x38>
    35d2:	d1 f0       	breq	.+52     	; 0x3608 <__fixunssfsi+0x46>
    35d4:	66 0f       	add	r22, r22
    35d6:	77 1f       	adc	r23, r23
    35d8:	88 1f       	adc	r24, r24
    35da:	99 1f       	adc	r25, r25
    35dc:	1a f0       	brmi	.+6      	; 0x35e4 <__fixunssfsi+0x22>
    35de:	ba 95       	dec	r27
    35e0:	c9 f7       	brne	.-14     	; 0x35d4 <__fixunssfsi+0x12>
    35e2:	12 c0       	rjmp	.+36     	; 0x3608 <__fixunssfsi+0x46>
    35e4:	b1 30       	cpi	r27, 0x01	; 1
    35e6:	81 f0       	breq	.+32     	; 0x3608 <__fixunssfsi+0x46>
    35e8:	c3 d0       	rcall	.+390    	; 0x3770 <__fp_zero>
    35ea:	b1 e0       	ldi	r27, 0x01	; 1
    35ec:	08 95       	ret
    35ee:	c0 c0       	rjmp	.+384    	; 0x3770 <__fp_zero>
    35f0:	67 2f       	mov	r22, r23
    35f2:	78 2f       	mov	r23, r24
    35f4:	88 27       	eor	r24, r24
    35f6:	b8 5f       	subi	r27, 0xF8	; 248
    35f8:	39 f0       	breq	.+14     	; 0x3608 <__fixunssfsi+0x46>
    35fa:	b9 3f       	cpi	r27, 0xF9	; 249
    35fc:	cc f3       	brlt	.-14     	; 0x35f0 <__fixunssfsi+0x2e>
    35fe:	86 95       	lsr	r24
    3600:	77 95       	ror	r23
    3602:	67 95       	ror	r22
    3604:	b3 95       	inc	r27
    3606:	d9 f7       	brne	.-10     	; 0x35fe <__fixunssfsi+0x3c>
    3608:	3e f4       	brtc	.+14     	; 0x3618 <__fixunssfsi+0x56>
    360a:	90 95       	com	r25
    360c:	80 95       	com	r24
    360e:	70 95       	com	r23
    3610:	61 95       	neg	r22
    3612:	7f 4f       	sbci	r23, 0xFF	; 255
    3614:	8f 4f       	sbci	r24, 0xFF	; 255
    3616:	9f 4f       	sbci	r25, 0xFF	; 255
    3618:	08 95       	ret

0000361a <__floatunsisf>:
    361a:	e8 94       	clt
    361c:	09 c0       	rjmp	.+18     	; 0x3630 <__floatsisf+0x12>

0000361e <__floatsisf>:
    361e:	97 fb       	bst	r25, 7
    3620:	3e f4       	brtc	.+14     	; 0x3630 <__floatsisf+0x12>
    3622:	90 95       	com	r25
    3624:	80 95       	com	r24
    3626:	70 95       	com	r23
    3628:	61 95       	neg	r22
    362a:	7f 4f       	sbci	r23, 0xFF	; 255
    362c:	8f 4f       	sbci	r24, 0xFF	; 255
    362e:	9f 4f       	sbci	r25, 0xFF	; 255
    3630:	99 23       	and	r25, r25
    3632:	a9 f0       	breq	.+42     	; 0x365e <__floatsisf+0x40>
    3634:	f9 2f       	mov	r31, r25
    3636:	96 e9       	ldi	r25, 0x96	; 150
    3638:	bb 27       	eor	r27, r27
    363a:	93 95       	inc	r25
    363c:	f6 95       	lsr	r31
    363e:	87 95       	ror	r24
    3640:	77 95       	ror	r23
    3642:	67 95       	ror	r22
    3644:	b7 95       	ror	r27
    3646:	f1 11       	cpse	r31, r1
    3648:	f8 cf       	rjmp	.-16     	; 0x363a <__floatsisf+0x1c>
    364a:	fa f4       	brpl	.+62     	; 0x368a <__floatsisf+0x6c>
    364c:	bb 0f       	add	r27, r27
    364e:	11 f4       	brne	.+4      	; 0x3654 <__floatsisf+0x36>
    3650:	60 ff       	sbrs	r22, 0
    3652:	1b c0       	rjmp	.+54     	; 0x368a <__floatsisf+0x6c>
    3654:	6f 5f       	subi	r22, 0xFF	; 255
    3656:	7f 4f       	sbci	r23, 0xFF	; 255
    3658:	8f 4f       	sbci	r24, 0xFF	; 255
    365a:	9f 4f       	sbci	r25, 0xFF	; 255
    365c:	16 c0       	rjmp	.+44     	; 0x368a <__floatsisf+0x6c>
    365e:	88 23       	and	r24, r24
    3660:	11 f0       	breq	.+4      	; 0x3666 <__floatsisf+0x48>
    3662:	96 e9       	ldi	r25, 0x96	; 150
    3664:	11 c0       	rjmp	.+34     	; 0x3688 <__floatsisf+0x6a>
    3666:	77 23       	and	r23, r23
    3668:	21 f0       	breq	.+8      	; 0x3672 <__floatsisf+0x54>
    366a:	9e e8       	ldi	r25, 0x8E	; 142
    366c:	87 2f       	mov	r24, r23
    366e:	76 2f       	mov	r23, r22
    3670:	05 c0       	rjmp	.+10     	; 0x367c <__floatsisf+0x5e>
    3672:	66 23       	and	r22, r22
    3674:	71 f0       	breq	.+28     	; 0x3692 <__floatsisf+0x74>
    3676:	96 e8       	ldi	r25, 0x86	; 134
    3678:	86 2f       	mov	r24, r22
    367a:	70 e0       	ldi	r23, 0x00	; 0
    367c:	60 e0       	ldi	r22, 0x00	; 0
    367e:	2a f0       	brmi	.+10     	; 0x368a <__floatsisf+0x6c>
    3680:	9a 95       	dec	r25
    3682:	66 0f       	add	r22, r22
    3684:	77 1f       	adc	r23, r23
    3686:	88 1f       	adc	r24, r24
    3688:	da f7       	brpl	.-10     	; 0x3680 <__floatsisf+0x62>
    368a:	88 0f       	add	r24, r24
    368c:	96 95       	lsr	r25
    368e:	87 95       	ror	r24
    3690:	97 f9       	bld	r25, 7
    3692:	08 95       	ret

00003694 <__fp_cmp>:
    3694:	99 0f       	add	r25, r25
    3696:	00 08       	sbc	r0, r0
    3698:	55 0f       	add	r21, r21
    369a:	aa 0b       	sbc	r26, r26
    369c:	e0 e8       	ldi	r30, 0x80	; 128
    369e:	fe ef       	ldi	r31, 0xFE	; 254
    36a0:	16 16       	cp	r1, r22
    36a2:	17 06       	cpc	r1, r23
    36a4:	e8 07       	cpc	r30, r24
    36a6:	f9 07       	cpc	r31, r25
    36a8:	c0 f0       	brcs	.+48     	; 0x36da <__fp_cmp+0x46>
    36aa:	12 16       	cp	r1, r18
    36ac:	13 06       	cpc	r1, r19
    36ae:	e4 07       	cpc	r30, r20
    36b0:	f5 07       	cpc	r31, r21
    36b2:	98 f0       	brcs	.+38     	; 0x36da <__fp_cmp+0x46>
    36b4:	62 1b       	sub	r22, r18
    36b6:	73 0b       	sbc	r23, r19
    36b8:	84 0b       	sbc	r24, r20
    36ba:	95 0b       	sbc	r25, r21
    36bc:	39 f4       	brne	.+14     	; 0x36cc <__fp_cmp+0x38>
    36be:	0a 26       	eor	r0, r26
    36c0:	61 f0       	breq	.+24     	; 0x36da <__fp_cmp+0x46>
    36c2:	23 2b       	or	r18, r19
    36c4:	24 2b       	or	r18, r20
    36c6:	25 2b       	or	r18, r21
    36c8:	21 f4       	brne	.+8      	; 0x36d2 <__fp_cmp+0x3e>
    36ca:	08 95       	ret
    36cc:	0a 26       	eor	r0, r26
    36ce:	09 f4       	brne	.+2      	; 0x36d2 <__fp_cmp+0x3e>
    36d0:	a1 40       	sbci	r26, 0x01	; 1
    36d2:	a6 95       	lsr	r26
    36d4:	8f ef       	ldi	r24, 0xFF	; 255
    36d6:	81 1d       	adc	r24, r1
    36d8:	81 1d       	adc	r24, r1
    36da:	08 95       	ret

000036dc <__fp_inf>:
    36dc:	97 f9       	bld	r25, 7
    36de:	9f 67       	ori	r25, 0x7F	; 127
    36e0:	80 e8       	ldi	r24, 0x80	; 128
    36e2:	70 e0       	ldi	r23, 0x00	; 0
    36e4:	60 e0       	ldi	r22, 0x00	; 0
    36e6:	08 95       	ret

000036e8 <__fp_nan>:
    36e8:	9f ef       	ldi	r25, 0xFF	; 255
    36ea:	80 ec       	ldi	r24, 0xC0	; 192
    36ec:	08 95       	ret

000036ee <__fp_pscA>:
    36ee:	00 24       	eor	r0, r0
    36f0:	0a 94       	dec	r0
    36f2:	16 16       	cp	r1, r22
    36f4:	17 06       	cpc	r1, r23
    36f6:	18 06       	cpc	r1, r24
    36f8:	09 06       	cpc	r0, r25
    36fa:	08 95       	ret

000036fc <__fp_pscB>:
    36fc:	00 24       	eor	r0, r0
    36fe:	0a 94       	dec	r0
    3700:	12 16       	cp	r1, r18
    3702:	13 06       	cpc	r1, r19
    3704:	14 06       	cpc	r1, r20
    3706:	05 06       	cpc	r0, r21
    3708:	08 95       	ret

0000370a <__fp_round>:
    370a:	09 2e       	mov	r0, r25
    370c:	03 94       	inc	r0
    370e:	00 0c       	add	r0, r0
    3710:	11 f4       	brne	.+4      	; 0x3716 <__fp_round+0xc>
    3712:	88 23       	and	r24, r24
    3714:	52 f0       	brmi	.+20     	; 0x372a <__fp_round+0x20>
    3716:	bb 0f       	add	r27, r27
    3718:	40 f4       	brcc	.+16     	; 0x372a <__fp_round+0x20>
    371a:	bf 2b       	or	r27, r31
    371c:	11 f4       	brne	.+4      	; 0x3722 <__fp_round+0x18>
    371e:	60 ff       	sbrs	r22, 0
    3720:	04 c0       	rjmp	.+8      	; 0x372a <__fp_round+0x20>
    3722:	6f 5f       	subi	r22, 0xFF	; 255
    3724:	7f 4f       	sbci	r23, 0xFF	; 255
    3726:	8f 4f       	sbci	r24, 0xFF	; 255
    3728:	9f 4f       	sbci	r25, 0xFF	; 255
    372a:	08 95       	ret

0000372c <__fp_split3>:
    372c:	57 fd       	sbrc	r21, 7
    372e:	90 58       	subi	r25, 0x80	; 128
    3730:	44 0f       	add	r20, r20
    3732:	55 1f       	adc	r21, r21
    3734:	59 f0       	breq	.+22     	; 0x374c <__fp_splitA+0x10>
    3736:	5f 3f       	cpi	r21, 0xFF	; 255
    3738:	71 f0       	breq	.+28     	; 0x3756 <__fp_splitA+0x1a>
    373a:	47 95       	ror	r20

0000373c <__fp_splitA>:
    373c:	88 0f       	add	r24, r24
    373e:	97 fb       	bst	r25, 7
    3740:	99 1f       	adc	r25, r25
    3742:	61 f0       	breq	.+24     	; 0x375c <__fp_splitA+0x20>
    3744:	9f 3f       	cpi	r25, 0xFF	; 255
    3746:	79 f0       	breq	.+30     	; 0x3766 <__fp_splitA+0x2a>
    3748:	87 95       	ror	r24
    374a:	08 95       	ret
    374c:	12 16       	cp	r1, r18
    374e:	13 06       	cpc	r1, r19
    3750:	14 06       	cpc	r1, r20
    3752:	55 1f       	adc	r21, r21
    3754:	f2 cf       	rjmp	.-28     	; 0x373a <__fp_split3+0xe>
    3756:	46 95       	lsr	r20
    3758:	f1 df       	rcall	.-30     	; 0x373c <__fp_splitA>
    375a:	08 c0       	rjmp	.+16     	; 0x376c <__fp_splitA+0x30>
    375c:	16 16       	cp	r1, r22
    375e:	17 06       	cpc	r1, r23
    3760:	18 06       	cpc	r1, r24
    3762:	99 1f       	adc	r25, r25
    3764:	f1 cf       	rjmp	.-30     	; 0x3748 <__fp_splitA+0xc>
    3766:	86 95       	lsr	r24
    3768:	71 05       	cpc	r23, r1
    376a:	61 05       	cpc	r22, r1
    376c:	08 94       	sec
    376e:	08 95       	ret

00003770 <__fp_zero>:
    3770:	e8 94       	clt

00003772 <__fp_szero>:
    3772:	bb 27       	eor	r27, r27
    3774:	66 27       	eor	r22, r22
    3776:	77 27       	eor	r23, r23
    3778:	cb 01       	movw	r24, r22
    377a:	97 f9       	bld	r25, 7
    377c:	08 95       	ret

0000377e <__gesf2>:
    377e:	8a df       	rcall	.-236    	; 0x3694 <__fp_cmp>
    3780:	08 f4       	brcc	.+2      	; 0x3784 <__gesf2+0x6>
    3782:	8f ef       	ldi	r24, 0xFF	; 255
    3784:	08 95       	ret

00003786 <__mulsf3>:
    3786:	0b d0       	rcall	.+22     	; 0x379e <__mulsf3x>
    3788:	c0 cf       	rjmp	.-128    	; 0x370a <__fp_round>
    378a:	b1 df       	rcall	.-158    	; 0x36ee <__fp_pscA>
    378c:	28 f0       	brcs	.+10     	; 0x3798 <__mulsf3+0x12>
    378e:	b6 df       	rcall	.-148    	; 0x36fc <__fp_pscB>
    3790:	18 f0       	brcs	.+6      	; 0x3798 <__mulsf3+0x12>
    3792:	95 23       	and	r25, r21
    3794:	09 f0       	breq	.+2      	; 0x3798 <__mulsf3+0x12>
    3796:	a2 cf       	rjmp	.-188    	; 0x36dc <__fp_inf>
    3798:	a7 cf       	rjmp	.-178    	; 0x36e8 <__fp_nan>
    379a:	11 24       	eor	r1, r1
    379c:	ea cf       	rjmp	.-44     	; 0x3772 <__fp_szero>

0000379e <__mulsf3x>:
    379e:	c6 df       	rcall	.-116    	; 0x372c <__fp_split3>
    37a0:	a0 f3       	brcs	.-24     	; 0x378a <__mulsf3+0x4>

000037a2 <__mulsf3_pse>:
    37a2:	95 9f       	mul	r25, r21
    37a4:	d1 f3       	breq	.-12     	; 0x379a <__mulsf3+0x14>
    37a6:	95 0f       	add	r25, r21
    37a8:	50 e0       	ldi	r21, 0x00	; 0
    37aa:	55 1f       	adc	r21, r21
    37ac:	62 9f       	mul	r22, r18
    37ae:	f0 01       	movw	r30, r0
    37b0:	72 9f       	mul	r23, r18
    37b2:	bb 27       	eor	r27, r27
    37b4:	f0 0d       	add	r31, r0
    37b6:	b1 1d       	adc	r27, r1
    37b8:	63 9f       	mul	r22, r19
    37ba:	aa 27       	eor	r26, r26
    37bc:	f0 0d       	add	r31, r0
    37be:	b1 1d       	adc	r27, r1
    37c0:	aa 1f       	adc	r26, r26
    37c2:	64 9f       	mul	r22, r20
    37c4:	66 27       	eor	r22, r22
    37c6:	b0 0d       	add	r27, r0
    37c8:	a1 1d       	adc	r26, r1
    37ca:	66 1f       	adc	r22, r22
    37cc:	82 9f       	mul	r24, r18
    37ce:	22 27       	eor	r18, r18
    37d0:	b0 0d       	add	r27, r0
    37d2:	a1 1d       	adc	r26, r1
    37d4:	62 1f       	adc	r22, r18
    37d6:	73 9f       	mul	r23, r19
    37d8:	b0 0d       	add	r27, r0
    37da:	a1 1d       	adc	r26, r1
    37dc:	62 1f       	adc	r22, r18
    37de:	83 9f       	mul	r24, r19
    37e0:	a0 0d       	add	r26, r0
    37e2:	61 1d       	adc	r22, r1
    37e4:	22 1f       	adc	r18, r18
    37e6:	74 9f       	mul	r23, r20
    37e8:	33 27       	eor	r19, r19
    37ea:	a0 0d       	add	r26, r0
    37ec:	61 1d       	adc	r22, r1
    37ee:	23 1f       	adc	r18, r19
    37f0:	84 9f       	mul	r24, r20
    37f2:	60 0d       	add	r22, r0
    37f4:	21 1d       	adc	r18, r1
    37f6:	82 2f       	mov	r24, r18
    37f8:	76 2f       	mov	r23, r22
    37fa:	6a 2f       	mov	r22, r26
    37fc:	11 24       	eor	r1, r1
    37fe:	9f 57       	subi	r25, 0x7F	; 127
    3800:	50 40       	sbci	r21, 0x00	; 0
    3802:	8a f0       	brmi	.+34     	; 0x3826 <__mulsf3_pse+0x84>
    3804:	e1 f0       	breq	.+56     	; 0x383e <__mulsf3_pse+0x9c>
    3806:	88 23       	and	r24, r24
    3808:	4a f0       	brmi	.+18     	; 0x381c <__mulsf3_pse+0x7a>
    380a:	ee 0f       	add	r30, r30
    380c:	ff 1f       	adc	r31, r31
    380e:	bb 1f       	adc	r27, r27
    3810:	66 1f       	adc	r22, r22
    3812:	77 1f       	adc	r23, r23
    3814:	88 1f       	adc	r24, r24
    3816:	91 50       	subi	r25, 0x01	; 1
    3818:	50 40       	sbci	r21, 0x00	; 0
    381a:	a9 f7       	brne	.-22     	; 0x3806 <__mulsf3_pse+0x64>
    381c:	9e 3f       	cpi	r25, 0xFE	; 254
    381e:	51 05       	cpc	r21, r1
    3820:	70 f0       	brcs	.+28     	; 0x383e <__mulsf3_pse+0x9c>
    3822:	5c cf       	rjmp	.-328    	; 0x36dc <__fp_inf>
    3824:	a6 cf       	rjmp	.-180    	; 0x3772 <__fp_szero>
    3826:	5f 3f       	cpi	r21, 0xFF	; 255
    3828:	ec f3       	brlt	.-6      	; 0x3824 <__mulsf3_pse+0x82>
    382a:	98 3e       	cpi	r25, 0xE8	; 232
    382c:	dc f3       	brlt	.-10     	; 0x3824 <__mulsf3_pse+0x82>
    382e:	86 95       	lsr	r24
    3830:	77 95       	ror	r23
    3832:	67 95       	ror	r22
    3834:	b7 95       	ror	r27
    3836:	f7 95       	ror	r31
    3838:	e7 95       	ror	r30
    383a:	9f 5f       	subi	r25, 0xFF	; 255
    383c:	c1 f7       	brne	.-16     	; 0x382e <__mulsf3_pse+0x8c>
    383e:	fe 2b       	or	r31, r30
    3840:	88 0f       	add	r24, r24
    3842:	91 1d       	adc	r25, r1
    3844:	96 95       	lsr	r25
    3846:	87 95       	ror	r24
    3848:	97 f9       	bld	r25, 7
    384a:	08 95       	ret

0000384c <__mulsi3>:
    384c:	62 9f       	mul	r22, r18
    384e:	d0 01       	movw	r26, r0
    3850:	73 9f       	mul	r23, r19
    3852:	f0 01       	movw	r30, r0
    3854:	82 9f       	mul	r24, r18
    3856:	e0 0d       	add	r30, r0
    3858:	f1 1d       	adc	r31, r1
    385a:	64 9f       	mul	r22, r20
    385c:	e0 0d       	add	r30, r0
    385e:	f1 1d       	adc	r31, r1
    3860:	92 9f       	mul	r25, r18
    3862:	f0 0d       	add	r31, r0
    3864:	83 9f       	mul	r24, r19
    3866:	f0 0d       	add	r31, r0
    3868:	74 9f       	mul	r23, r20
    386a:	f0 0d       	add	r31, r0
    386c:	65 9f       	mul	r22, r21
    386e:	f0 0d       	add	r31, r0
    3870:	99 27       	eor	r25, r25
    3872:	72 9f       	mul	r23, r18
    3874:	b0 0d       	add	r27, r0
    3876:	e1 1d       	adc	r30, r1
    3878:	f9 1f       	adc	r31, r25
    387a:	63 9f       	mul	r22, r19
    387c:	b0 0d       	add	r27, r0
    387e:	e1 1d       	adc	r30, r1
    3880:	f9 1f       	adc	r31, r25
    3882:	bd 01       	movw	r22, r26
    3884:	cf 01       	movw	r24, r30
    3886:	11 24       	eor	r1, r1
    3888:	08 95       	ret

0000388a <__udivmodhi4>:
    388a:	aa 1b       	sub	r26, r26
    388c:	bb 1b       	sub	r27, r27
    388e:	51 e1       	ldi	r21, 0x11	; 17
    3890:	07 c0       	rjmp	.+14     	; 0x38a0 <__udivmodhi4_ep>

00003892 <__udivmodhi4_loop>:
    3892:	aa 1f       	adc	r26, r26
    3894:	bb 1f       	adc	r27, r27
    3896:	a6 17       	cp	r26, r22
    3898:	b7 07       	cpc	r27, r23
    389a:	10 f0       	brcs	.+4      	; 0x38a0 <__udivmodhi4_ep>
    389c:	a6 1b       	sub	r26, r22
    389e:	b7 0b       	sbc	r27, r23

000038a0 <__udivmodhi4_ep>:
    38a0:	88 1f       	adc	r24, r24
    38a2:	99 1f       	adc	r25, r25
    38a4:	5a 95       	dec	r21
    38a6:	a9 f7       	brne	.-22     	; 0x3892 <__udivmodhi4_loop>
    38a8:	80 95       	com	r24
    38aa:	90 95       	com	r25
    38ac:	bc 01       	movw	r22, r24
    38ae:	cd 01       	movw	r24, r26
    38b0:	08 95       	ret

000038b2 <__prologue_saves__>:
    38b2:	2f 92       	push	r2
    38b4:	3f 92       	push	r3
    38b6:	4f 92       	push	r4
    38b8:	5f 92       	push	r5
    38ba:	6f 92       	push	r6
    38bc:	7f 92       	push	r7
    38be:	8f 92       	push	r8
    38c0:	9f 92       	push	r9
    38c2:	af 92       	push	r10
    38c4:	bf 92       	push	r11
    38c6:	cf 92       	push	r12
    38c8:	df 92       	push	r13
    38ca:	ef 92       	push	r14
    38cc:	ff 92       	push	r15
    38ce:	0f 93       	push	r16
    38d0:	1f 93       	push	r17
    38d2:	cf 93       	push	r28
    38d4:	df 93       	push	r29
    38d6:	cd b7       	in	r28, 0x3d	; 61
    38d8:	de b7       	in	r29, 0x3e	; 62
    38da:	ca 1b       	sub	r28, r26
    38dc:	db 0b       	sbc	r29, r27
    38de:	0f b6       	in	r0, 0x3f	; 63
    38e0:	f8 94       	cli
    38e2:	de bf       	out	0x3e, r29	; 62
    38e4:	0f be       	out	0x3f, r0	; 63
    38e6:	cd bf       	out	0x3d, r28	; 61
    38e8:	09 94       	ijmp

000038ea <__epilogue_restores__>:
    38ea:	2a 88       	ldd	r2, Y+18	; 0x12
    38ec:	39 88       	ldd	r3, Y+17	; 0x11
    38ee:	48 88       	ldd	r4, Y+16	; 0x10
    38f0:	5f 84       	ldd	r5, Y+15	; 0x0f
    38f2:	6e 84       	ldd	r6, Y+14	; 0x0e
    38f4:	7d 84       	ldd	r7, Y+13	; 0x0d
    38f6:	8c 84       	ldd	r8, Y+12	; 0x0c
    38f8:	9b 84       	ldd	r9, Y+11	; 0x0b
    38fa:	aa 84       	ldd	r10, Y+10	; 0x0a
    38fc:	b9 84       	ldd	r11, Y+9	; 0x09
    38fe:	c8 84       	ldd	r12, Y+8	; 0x08
    3900:	df 80       	ldd	r13, Y+7	; 0x07
    3902:	ee 80       	ldd	r14, Y+6	; 0x06
    3904:	fd 80       	ldd	r15, Y+5	; 0x05
    3906:	0c 81       	ldd	r16, Y+4	; 0x04
    3908:	1b 81       	ldd	r17, Y+3	; 0x03
    390a:	aa 81       	ldd	r26, Y+2	; 0x02
    390c:	b9 81       	ldd	r27, Y+1	; 0x01
    390e:	ce 0f       	add	r28, r30
    3910:	d1 1d       	adc	r29, r1
    3912:	0f b6       	in	r0, 0x3f	; 63
    3914:	f8 94       	cli
    3916:	de bf       	out	0x3e, r29	; 62
    3918:	0f be       	out	0x3f, r0	; 63
    391a:	cd bf       	out	0x3d, r28	; 61
    391c:	ed 01       	movw	r28, r26
    391e:	08 95       	ret

00003920 <_exit>:
    3920:	f8 94       	cli

00003922 <__stop_program>:
    3922:	ff cf       	rjmp	.-2      	; 0x3922 <__stop_program>

Disassembly of section .bootloader:

00003960 <boot_program_page>:

#define MAX_BOOT_PAGE 133

void boot_program_page (uint32_t page, uint8_t *buf, uint8_t count) BOOTLOADER_SECTION;
void boot_program_page (uint32_t page, uint8_t *buf, uint8_t count)	
    {
    3960:	0f 93       	push	r16
    3962:	1f 93       	push	r17
    3964:	cf 93       	push	r28
    3966:	df 93       	push	r29
    3968:	da 01       	movw	r26, r20
        uint8_t sreg;
		uint16_t w;

        // Disable interrupts.

        sreg = SREG;
    396a:	0f b7       	in	r16, 0x3f	; 63
        cli();
    396c:	f8 94       	cli
    
        eeprom_busy_wait ();
    396e:	f9 99       	sbic	0x1f, 1	; 31
    3970:	fe cf       	rjmp	.-4      	; 0x396e <boot_program_page+0xe>
	
        boot_page_erase (page);
    3972:	ab 01       	movw	r20, r22
    3974:	83 e0       	ldi	r24, 0x03	; 3
    3976:	fb 01       	movw	r30, r22
    3978:	80 93 57 00 	sts	0x0057, r24
    397c:	e8 95       	spm
        boot_spm_busy_wait ();      // Wait until the memory is erased.
    397e:	07 b6       	in	r0, 0x37	; 55
    3980:	00 fc       	sbrc	r0, 0
    3982:	fd cf       	rjmp	.-6      	; 0x397e <boot_program_page+0x1e>
    3984:	fa 01       	movw	r30, r20

        for (i=0; i<SPM_PAGESIZE; i+=2)
        {
           	w = *buf++;
           	w += (*buf++) << 8;
		    boot_page_fill (page + i, w);
    3986:	11 e0       	ldi	r17, 0x01	; 1
        eeprom_busy_wait ();
	
        boot_page_erase (page);
        boot_spm_busy_wait ();      // Wait until the memory is erased.

        for (i=0; i<SPM_PAGESIZE; i+=2)
    3988:	ba 01       	movw	r22, r20
    398a:	60 58       	subi	r22, 0x80	; 128
    398c:	7f 4f       	sbci	r23, 0xFF	; 255
        {
           	w = *buf++;
    398e:	8c 91       	ld	r24, X
           	w += (*buf++) << 8;
    3990:	11 96       	adiw	r26, 0x01	; 1
    3992:	3c 91       	ld	r19, X
    3994:	11 97       	sbiw	r26, 0x01	; 1
    3996:	20 e0       	ldi	r18, 0x00	; 0
    3998:	e9 01       	movw	r28, r18
    399a:	c8 0f       	add	r28, r24
    399c:	d1 1d       	adc	r29, r1

#define MAX_BOOT_PAGE 133

void boot_program_page (uint32_t page, uint8_t *buf, uint8_t count) BOOTLOADER_SECTION;
void boot_program_page (uint32_t page, uint8_t *buf, uint8_t count)	
    {
    399e:	12 96       	adiw	r26, 0x02	; 2

        for (i=0; i<SPM_PAGESIZE; i+=2)
        {
           	w = *buf++;
           	w += (*buf++) << 8;
		    boot_page_fill (page + i, w);
    39a0:	0e 01       	movw	r0, r28
    39a2:	10 93 57 00 	sts	0x0057, r17
    39a6:	e8 95       	spm
    39a8:	11 24       	eor	r1, r1
    39aa:	32 96       	adiw	r30, 0x02	; 2
        eeprom_busy_wait ();
	
        boot_page_erase (page);
        boot_spm_busy_wait ();      // Wait until the memory is erased.

        for (i=0; i<SPM_PAGESIZE; i+=2)
    39ac:	e6 17       	cp	r30, r22
    39ae:	f7 07       	cpc	r31, r23
    39b0:	71 f7       	brne	.-36     	; 0x398e <boot_program_page+0x2e>
        {
           	w = *buf++;
           	w += (*buf++) << 8;
		    boot_page_fill (page + i, w);
		}
        boot_page_write (page);     // Store buffer in flash page.
    39b2:	85 e0       	ldi	r24, 0x05	; 5
    39b4:	fa 01       	movw	r30, r20
    39b6:	80 93 57 00 	sts	0x0057, r24
    39ba:	e8 95       	spm
        boot_spm_busy_wait();       // Wait until the memory is written.
    39bc:	07 b6       	in	r0, 0x37	; 55
    39be:	00 fc       	sbrc	r0, 0
    39c0:	fd cf       	rjmp	.-6      	; 0x39bc <boot_program_page+0x5c>

        // Reenable RWW-section again. We need this if we want to jump back
        // to the application after bootloading.

        boot_rww_enable ();
    39c2:	81 e1       	ldi	r24, 0x11	; 17
    39c4:	80 93 57 00 	sts	0x0057, r24
    39c8:	e8 95       	spm

        // Re-enable interrupts (if they were ever enabled).

        SREG = sreg;
    39ca:	0f bf       	out	0x3f, r16	; 63
    }
    39cc:	df 91       	pop	r29
    39ce:	cf 91       	pop	r28
    39d0:	1f 91       	pop	r17
    39d2:	0f 91       	pop	r16
    39d4:	08 95       	ret
